
############## Private\EquipmentSystemCore.cpp ###############
﻿#include "EquipmentSystemCore.h"

#define LOCTEXT_NAMESPACE "FEquipmentSystemCoreModule"

void FEquipmentSystemCoreModule::StartupModule()
{
}

void FEquipmentSystemCoreModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FEquipmentSystemCoreModule, EquipmentSystemCore)


############## Private\Abilities\EquipmentGameplayAbility.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Abilities/EquipmentGameplayAbility.h"
#include "Instances/EquipmentInstance.h"
#include "Instances/ItemInstance.h"

#if WITH_EDITOR
#include "Misc/DataValidation.h"
#endif

UEquipmentGameplayAbility::UEquipmentGameplayAbility(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
}

UEquipmentInstance* UEquipmentGameplayAbility::GetSourceEquipmentInstance() const
{
	return TryGetSourceObject<UEquipmentInstance>();
}

UEquipmentInstance* UEquipmentGameplayAbility::GetTypedSourceEquipmentInstance(const TSubclassOf<UEquipmentInstance>& InstanceClass) const
{
	if (UEquipmentInstance* Instance = TryGetSourceObject<UEquipmentInstance>(); IsValid(Instance) && Instance->IsA(InstanceClass))
	{
		return Instance;
	}
	return nullptr;
}

UItemInstance* UEquipmentGameplayAbility::GetSourceItemInstance() const
{
	if (const UEquipmentInstance* Instance = GetSourceEquipmentInstance(); IsValid(Instance))
	{
		return Cast<UItemInstance>(Instance->GetSourceItem());
	}
	return nullptr;
}

UItemInstance* UEquipmentGameplayAbility::GetTypedSourceItemInstance(const TSubclassOf<UItemInstance>& InstanceClass) const
{
	if (UItemInstance* Instance = GetSourceItemInstance(); IsValid(Instance) && Instance->IsA(InstanceClass))
	{
		return Instance;
	}
	return nullptr;
}

#if WITH_EDITOR
EDataValidationResult UEquipmentGameplayAbility::IsDataValid(FDataValidationContext& Context) const
{
	EDataValidationResult Result = Super::IsDataValid(Context);

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// Ensure that equipment abilities are always instanced
	if (InstancingPolicy == EGameplayAbilityInstancingPolicy::NonInstanced)
	{
		Context.AddError(FText::FromString("Equipment abilities must be instanced."));
		Result = EDataValidationResult::Invalid;
	}
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

	return Result;
}
#endif


############## Private\Actors\EquipmentActor.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Actors/EquipmentActor.h"

AEquipmentActor::AEquipmentActor(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer.Get())
{
	PrimaryActorTick.bCanEverTick = false;

	SetReplicates(true);
}

APawn* AEquipmentActor::GetPawn()
{
	return Cast<APawn>(GetOwner());
}


############## Private\Actors\WeaponActor.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Actors/WeaponActor.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemInterface.h"
#include "Collisions/ShapeElementSet.h"
#include "GameplayTags/EquipmentGameplayTags.h"
#include "PhysicsEngine/PhysicsAsset.h"
#include "PhysicsEngine/SkeletalBodySetup.h"
#include "Settings/EquipmentSystemSettings.h"
#include "Utils/DebugDrawExtension.h"

// For Unreal Profiler
DECLARE_CYCLE_STAT(TEXT("CollisionTick"), STAT_CollisionTick, STATGROUP_WeaponBase);

AWeaponActor::AWeaponActor(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer.Get())
{
	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.bStartWithTickEnabled = true;
	bReplicates = true;

	SkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("SkeletalMeshComponent"));
	SetRootComponent(SkeletalMeshComponent);
}

void AWeaponActor::BeginPlay()
{
	Super::BeginPlay();

	UpdateShapeElementSets();

	AsyncTraceDelegate.BindUObject(this, &ThisClass::OnAsyncTraceComplete);
}

void AWeaponActor::Tick(const float DeltaTime)
{
	Super::Tick(DeltaTime);

#if !UE_BUILD_SHIPPING
	const UWorld* const World = GetWorld();
	if (!IsValid(World) || !IsValid(SkeletalMeshComponent))
	{
		return;
	}
	
	// Don't draw the debug collision if we're in GameWorld and haven't enabled collision drawing with the console variable
	if (World->IsGameWorld() && !GET_EQUIPMENT_SETTINGS_VAR(bDrawWeaponColliders))
	{
		return;
	}
	
	const float Thickness = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesLineThickness);

	for (auto& [ShapeElement, BoneName, LastTransform, CollisionEnabled, ForwardHandle, BackwardHandle] : ShapeElementSets)
	{
		const FTransform BoneTransform = SkeletalMeshComponent->GetBoneTransform(BoneName, RTS_World);
		
		FTransform ShapeTransform;
		FTransform WorldTransform;
		const FVector Scale = BoneTransform.GetScale3D();
		FColor Color;
		GetCollisionColor(CollisionEnabled, Color);

		if (ShapeElement.IsType<FKSphereElem>())
		{
			FKSphereElem& Elem = ShapeElement.Get<FKSphereElem>();
			
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;
			const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
			
			DrawDebugSphere( World, WorldTransform.GetLocation(), Radius, 12, Color, false, -1, 0, Thickness);
		}
		else if (ShapeElement.IsType<FKBoxElem>())
		{
			FKBoxElem& Elem = ShapeElement.Get<FKBoxElem>();
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;

			FVector Extent = FVector(Elem.X * Scale.X, Elem.Y * Scale.Y, Elem.Z * Scale.Z) * 0.5f;
			
			DrawDebugBox( World, WorldTransform.GetLocation(), Extent, WorldTransform.GetRotation(), Color, false, -1, 0, Thickness);
		}
		else if (ShapeElement.IsType<FKSphylElem>())
		{
			FKSphylElem& Elem = ShapeElement.Get<FKSphylElem>();
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;

			const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
			const float HalfHeight = (Elem.Length + Radius*2.f) * 0.5f * Scale.Z;
			
			DrawDebugCapsule( World, WorldTransform.GetLocation(), HalfHeight, Radius, WorldTransform.GetRotation(), Color, false, -1, 0, Thickness);
		}
		else if (ShapeElement.IsType<FKConvexElem>())
		{
			FKConvexElem& Elem = ShapeElement.Get<FKConvexElem>();
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;

			TArray<FVector> Vertices = Elem.VertexData;
			for (FVector& Vertex : Vertices)
			{
				Vertex = WorldTransform.TransformPosition(Vertex);
			}
			TArray<int32> Indices = Elem.IndexData;
			
			DrawDebugMesh( World, Vertices, Indices, Color, false, -1, 0);
		}
	}
#endif
}

void AWeaponActor::OpenCollisionWindow(ECollisionHitPolicy& HitPolicy)
{
	const UWorld* World = GetWorld();
	if (!IsValid(World))
	{
		return;
	}

	CollisionWindow = FCollisionWindow(HitPolicy);
	
	// Update collision shape element sets on initial state
	UpdateShapeElementSets();
	
	World->GetTimerManager().SetTimer(
		CollisionWindow.TimerHandle,
		this,
		&AWeaponActor::OnCollisionTick,
		GET_EQUIPMENT_SETTINGS_VAR(SweepTraceTickRate),
		true);
}

void AWeaponActor::CloseCollisionWindow()
{
	const UWorld* World = GetWorld();
	if (!IsValid(World))
	{
		return;
	}

	World->GetTimerManager().ClearTimer(CollisionWindow.TimerHandle);
}

void AWeaponActor::SetPhysicsAssets(UPhysicsAsset* PhysicsAsset)
{
	const UWorld* const World = GetWorld();
	if (!IsValid(World) || !IsValid(SkeletalMeshComponent))
	{
		return;
	}

	SkeletalMeshComponent->SetPhysicsAsset(PhysicsAsset);
	UpdateShapeElementSets();
}

void AWeaponActor::OnCollisionTick()
{
	UWorld* World = GetWorld();
	if (!IsValid(World))
	{
		return;
	}
	
	// Do not start a new trace if we're blocked could cause access conflict
	if (!bIsPreviousTraceComplete)
	{
		return;
	}

	
	SCOPE_CYCLE_COUNTER(STAT_CollisionTick);

	ForwardHitResults.Empty();
	
	// Prepare sweep test parameters
	FCollisionQueryParams Params;
	Params.bTraceComplex = bTraceComplex;
	Params.bReturnFaceIndex = bReturnFaceIndex;
	Params.bReturnPhysicalMaterial = bReturnPhysicalMaterial;
	Params.bIgnoreBlocks = bIgnoreBlocks;
	Params.bIgnoreTouches = bIgnoreTouches;
	Params.bSkipNarrowPhase = bSkipNarrowPhase;
	Params.bReturnPhysicalMaterial = true;

	ECollisionChannel SweepChannel = GET_EQUIPMENT_SETTINGS_VAR(SweepChannel);
	
	const TArray<AActor*> HitActors = {this, GetOwner()};
	Params.AddIgnoredActors(HitActors);

	for (auto& [ShapeElement, BoneName, LastLocation, CollisionEnabled, ForwardHandle, BackwardHandle] : ShapeElementSets)
	{
		if (!(CollisionEnabled == ECollisionEnabled::Type::QueryAndPhysics || CollisionEnabled == ECollisionEnabled::Type::QueryAndProbe || CollisionEnabled == ECollisionEnabled::Type::QueryOnly))
			continue;
		
		const FTransform BoneTransform = SkeletalMeshComponent->GetBoneTransform(BoneName, RTS_World);
		
		FTransform ShapeTransform;
		FTransform WorldTransform;
		const FVector Scale = BoneTransform.GetScale3D();
		
		FColor Color;
		GetCollisionColor(CollisionEnabled, Color);
		FCollisionShape CollisionShape;

		if (ShapeElement.IsType<FKSphereElem>())
		{
			const FKSphereElem& Elem = ShapeElement.Get<FKSphereElem>();
			
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;
			const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
			
			CollisionShape = FCollisionShape::MakeSphere(Radius);
		}
		else if (ShapeElement.IsType<FKBoxElem>())
		{
			const FKBoxElem& Elem = ShapeElement.Get<FKBoxElem>();
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;

			FVector Extent = FVector(Elem.X * Scale.X, Elem.Y * Scale.Y, Elem.Z * Scale.Z) * 0.5f;
			
			CollisionShape = FCollisionShape::MakeBox(Extent);
		}
		else if (ShapeElement.IsType<FKSphylElem>())
		{
			const FKSphylElem& Elem = ShapeElement.Get<FKSphylElem>();
			ShapeTransform = Elem.GetTransform();
			WorldTransform = ShapeTransform * BoneTransform;

			const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
			const float HalfHeight = (Elem.Length + Radius*2.f) * 0.5f * Scale.Z;

			CollisionShape = FCollisionShape::MakeCapsule(Radius, HalfHeight);
		}
		else if (ShapeElement.IsType<FKConvexElem>())
		{
			const FKConvexElem& Elem = ShapeElement.Get<FKConvexElem>();
			ShapeTransform = Elem.GetTransform();
			ShapeTransform.SetLocation(Elem.ElemBox.GetCenter());
			WorldTransform = ShapeTransform * BoneTransform;

			// Use the bounding box of the convex hull
			const FBox BoundingBox = Elem.ElemBox;
			const FVector Extent = BoundingBox.GetExtent() * Scale;
			
			CollisionShape = FCollisionShape::MakeBox(Extent);
		}else
		{
			continue;
		}

		FVector EndLocation = WorldTransform.GetLocation();
		
		ForwardHandle = World->AsyncSweepByChannel(
			EAsyncTraceType::Multi,
			LastLocation,
			EndLocation,
			WorldTransform.GetRotation(),
			SweepChannel,
			CollisionShape,
			Params,
			FCollisionResponseParams::DefaultResponseParam,
			&AsyncTraceDelegate);

		LastLocation = EndLocation;
	}
}

void AWeaponActor::OnAsyncTraceComplete(const FTraceHandle& TraceHandle, FTraceDatum& Data)
{
	const UWorld* World = GetWorld();
	if (!IsValid(World))
	{
		return;
	}
	
	auto Predicate = [&](const FShapeElementSet& Set)
	{
		return Set.ForwardTraceHandle.IsValid() && Set.ForwardTraceHandle == TraceHandle;
	};
	
	FShapeElementSet* const ShapeElementSetPtr = ShapeElementSets.FindByPredicate(Predicate);
	if (!ShapeElementSetPtr) return;		

	// Clear forward trace handle
	ShapeElementSetPtr->ForwardTraceHandle = FTraceHandle();

	for (const FHitResult& HitResult : Data.OutHits)
	{
		if (HitResult.bBlockingHit)
		{
			ForwardHitResults.Add(HitResult);
		}
	}

#if !UE_BUILD_SHIPPING
	// Gather console settings
	const bool bDrawSweepTraces = GET_EQUIPMENT_SETTINGS_VAR(bDrawSweepTraces);
	const float SweepTraceDuration = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesDuration);
	const FColor SweepTraceColor = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesColor);
	const bool bDrawHitNormal = GET_EQUIPMENT_SETTINGS_VAR(bDrawSweepTracesHitNormals);
	const float HitDuration = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesHitNormalsDuration);
	const float LineThickness = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesLineThickness);
	const FColor HitNormalColor = GET_EQUIPMENT_SETTINGS_VAR(SweepTracesHitNormalsColor);

	const FTransform BoneTransform = SkeletalMeshComponent->GetBoneTransform(ShapeElementSetPtr->BoneName, RTS_World);
	const FVector Scale = BoneTransform.GetScale3D();
	
	
	TVariant<FKSphereElem, FKBoxElem, FKSphylElem, FKConvexElem>& ShapeElement = ShapeElementSetPtr->ShapeElement;
	if (ShapeElement.IsType<FKSphereElem>())
	{
		const FKSphereElem& Elem = ShapeElement.Get<FKSphereElem>();
			
		const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
		UDebugDrawExtension::DrawSphereSweep(World, Data.Start, Data.End, Radius, Data.OutHits, bDrawSweepTraces, SweepTraceColor, SweepTraceDuration, bDrawHitNormal, HitNormalColor, HitDuration, LineThickness);
	}
	else if (ShapeElement.IsType<FKBoxElem>())
	{
		const FKBoxElem& Elem = ShapeElement.Get<FKBoxElem>();
		const FTransform ShapeTransform = Elem.GetTransform();
		const FTransform WorldTransform = ShapeTransform * BoneTransform;

		FVector Extent = FVector(Elem.X * Scale.X, Elem.Y * Scale.Y, Elem.Z * Scale.Z) * 0.5f;
			
		UDebugDrawExtension::DrawBoxSweep(World, Data.Start, Data.End, Extent, WorldTransform.GetRotation(), Data.OutHits, bDrawSweepTraces, SweepTraceColor, SweepTraceDuration, bDrawHitNormal, HitNormalColor, HitDuration, LineThickness);
	}
	else if (ShapeElement.IsType<FKSphylElem>())
	{
		const FKSphylElem& Elem = ShapeElement.Get<FKSphylElem>();
		const FTransform ShapeTransform = Elem.GetTransform();
		const FTransform WorldTransform = ShapeTransform * BoneTransform;

		const float Radius = Elem.Radius * FMath::Max(Scale.X, Scale.Y);
		const float HalfHeight = (Elem.Length + Radius*2.f) * 0.5f * Scale.Z;

		UDebugDrawExtension::DrawCapsuleSweep(World, Data.Start, Data.End, HalfHeight, Radius, WorldTransform.GetRotation(), Data.OutHits, bDrawSweepTraces, SweepTraceColor, SweepTraceDuration, bDrawHitNormal, HitNormalColor, HitDuration, LineThickness);
	}
	else if (ShapeElement.IsType<FKConvexElem>())
	{
		const FKConvexElem& Elem = ShapeElement.Get<FKConvexElem>();
		const FTransform ShapeTransform = Elem.GetTransform();
		const FTransform WorldTransform = ShapeTransform * BoneTransform;

		// Use the bounding box of the convex hull
		const FBox BoundingBox = Elem.ElemBox;
		const FVector Extent = BoundingBox.GetExtent() * Scale;
			
		UDebugDrawExtension::DrawBoxSweep(World, Data.Start, Data.End, Extent, WorldTransform.GetRotation(), Data.OutHits, bDrawSweepTraces, SweepTraceColor, SweepTraceDuration, bDrawHitNormal, HitNormalColor, HitDuration, LineThickness);
	}
#endif

	// Check if all the async traces are finished
	bool AreAllTracesFinished = true;
	for (FShapeElementSet& ElementSet : ShapeElementSets)
	{
		if (ElementSet.ForwardTraceHandle.IsValid())
		{
			AreAllTracesFinished = false;
			break;
		}
	}

	if (AreAllTracesFinished) ProcessHitResults();

	bIsPreviousTraceComplete = AreAllTracesFinished;
}

void AWeaponActor::ProcessHitResults()
{
	for (const FHitResult& HitResult : ForwardHitResults)
	{
		ComputeCollisionHit(HitResult);
	}
}

void AWeaponActor::ComputeCollisionHit(const FHitResult& SweepResult)
{
	OnSweepCollisionHit.Broadcast(SweepResult);
	K2_OnSweepCollisionHit(SweepResult);

	// Do not do anything if we already touched an actor in OneHitOnly
	if (CollisionWindow.Policy == ECollisionHitPolicy::OneHitOnly && CollisionWindow.HitActors.Num() > 0)
	{
		return;		
	}
	
	const APawn* const InstigatorPawn = GetInstigator();
	AActor* const TargetActor = SweepResult.GetActor();	
	if (IsValid(TargetActor) && IsValid(InstigatorPawn) && InstigatorPawn != TargetActor)
	{
		// Do not send event if we already hit this actor in OneHitPerActor or OneHitPerSuccessiveActor
		if (CollisionWindow.Policy > ECollisionHitPolicy::OneHitOnly
			&& CollisionWindow.HitActors.Contains(TargetActor))
		{
			return;
		}

		// Send gameplay event to instigator ability system component
		if (InstigatorPawn->Implements<UAbilitySystemInterface>())
		{
			if (const IAbilitySystemInterface* Implementer = Cast<IAbilitySystemInterface>(InstigatorPawn))
			{
				if (UAbilitySystemComponent* InstigatorASC = Implementer->GetAbilitySystemComponent(); IsValid(InstigatorASC))
				{
					FScopedPredictionWindow PredictionWindow(InstigatorASC, true);

					FGameplayAbilityTargetData_SingleTargetHit* TargetData = new FGameplayAbilityTargetData_SingleTargetHit();
					TargetData->HitResult = SweepResult;

					FGameplayEventData Payload;
					Payload.Instigator = InstigatorPawn;
					Payload.Target = TargetActor;
					Payload.EventTag = EquipmentSystemGameplayTags::TAG_Equipment_Event_CollisionHit;
					Payload.InstigatorTags = InstigatorASC->GetOwnedGameplayTags();
					Payload.OptionalObject = this;
					Payload.TargetData = FGameplayAbilityTargetDataHandle(TargetData);

					if (TargetActor->Implements<UAbilitySystemInterface>())
					{
						if (UAbilitySystemComponent* TargetASC = Implementer->GetAbilitySystemComponent(); IsValid(TargetASC))
						{
							Payload.TargetTags = TargetASC->GetOwnedGameplayTags();
						}
					}

					InstigatorASC->HandleGameplayEvent(Payload.EventTag, &Payload);
				}
			}			
		}

		// Manage hit history depending on the window policy
		if (CollisionWindow.Policy == ECollisionHitPolicy::OneHitPerSuccessiveActor)
		{
			CollisionWindow.HitActors.Empty(1);
		}
		CollisionWindow.HitActors.Emplace(TargetActor);
	}
}

void AWeaponActor::UpdateShapeElementSets()
{
	UPhysicsAsset* PhysicsAsset = SkeletalMeshComponent->GetPhysicsAsset();
	if (!IsValid(PhysicsAsset))
	{
		ShapeElementSets.Empty();
		CachedPhysicsAsset = nullptr;
		return;
	}

	ShapeElementSets.Empty(PhysicsAsset->SkeletalBodySetups.Num());

	for (USkeletalBodySetup* const BodySetup : PhysicsAsset->SkeletalBodySetups)
	{
		if (!IsValid(BodySetup)) continue;

		FName BoneName = BodySetup->BoneName;
		const FTransform BoneTransform = SkeletalMeshComponent->GetBoneTransform(BoneName, RTS_World);
		const FVector Scale = BoneTransform.GetScale3D();

		for (FKSphereElem& Elem : BodySetup->AggGeom.SphereElems)
		{
			FShapeElementSet Set;
			Set.ShapeElement.Set<FKSphereElem>(Elem);
			
			Set.BoneName = BoneName;
			Set.CollisionEnabled = Elem.GetCollisionEnabled();
			Set.LastLocation = (Elem.GetTransform() * BoneTransform).GetLocation();
			
			ShapeElementSets.Emplace(Set);
		}
		for (FKBoxElem& Elem : BodySetup->AggGeom.BoxElems)
		{
			FShapeElementSet Set;
			Set.ShapeElement.Set<FKBoxElem>(Elem);
			Set.BoneName = BoneName;
			Set.CollisionEnabled = Elem.GetCollisionEnabled();
			Set.LastLocation = (Elem.GetTransform() * BoneTransform).GetLocation();
			
			ShapeElementSets.Emplace(Set);
		}
		for (FKSphylElem& Elem : BodySetup->AggGeom.SphylElems)
		{
			FShapeElementSet Set;
			Set.ShapeElement.Set<FKSphylElem>(Elem);
			Set.BoneName = BoneName;
			Set.CollisionEnabled = Elem.GetCollisionEnabled();
			Set.LastLocation = (Elem.GetTransform() * BoneTransform).GetLocation();
			
			ShapeElementSets.Emplace(Set);
		}
		for (FKConvexElem& Elem : BodySetup->AggGeom.ConvexElems)
		{
			FShapeElementSet Set;
			Set.ShapeElement.Set<FKConvexElem>(Elem);
			Set.BoneName = BoneName;
			Set.CollisionEnabled = Elem.GetCollisionEnabled();
			
			FTransform ShapeTransform = Elem.GetTransform();
			ShapeTransform.SetLocation(Elem.ElemBox.GetCenter());
			Set.LastLocation = (BoneTransform * ShapeTransform).GetLocation();
			
			ShapeElementSets.Emplace(Set);
		}
	}

	CachedPhysicsAsset = PhysicsAsset;
}

void AWeaponActor::GetCollisionColor(const ECollisionEnabled::Type CollisionType, FColor& Color)
{
	switch (CollisionType)
	{
	case ECollisionEnabled::NoCollision:
		Color = FColor::Red;
		break;
	case ECollisionEnabled::QueryOnly:
		Color = FColor::Blue;
		break;
	case ECollisionEnabled::PhysicsOnly:
		Color = FColor::Yellow;
		break;
	case ECollisionEnabled::QueryAndPhysics:
		Color = FColor::Green;
		break;
	case ECollisionEnabled::ProbeOnly:
		Color = FColor::Magenta;
		break;
	case ECollisionEnabled::QueryAndProbe:
		Color = FColor::Purple;
		break;
	default:
		Color = FColor::White;
		break;
	}
}


############## Private\Animation\CollisionNotifyState.cpp ###############
﻿// // Licensed under the MIT License. See the LICENSE file in the project root for full license information.


#include "Animation/CollisionNotifyState.h"

#include "Actors/WeaponActor.h"
#include "Components/EquipmentSystemComponent.h"
#include "Interfaces/EquipmentSystemInterface.h"

FString UCollisionNotifyState::GetNotifyName_Implementation() const
{
	return FString::Printf(TEXT("Collision [%s]"), *BoneName.ToString());
}

void UCollisionNotifyState::NotifyBegin(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration, const FAnimNotifyEventReference& EventReference)
{
	Super::NotifyBegin(MeshComp, Animation, TotalDuration, EventReference);

	if (!IsValid(MeshComp))
	{
		UE_LOG(LogAnimation, Warning, TEXT("Attempt to begin a notification with an invalid component or collision set."));
		return;
	}

	AActor* Owner = MeshComp->GetOwner();
	
	if (!IsValid(Owner) || !Owner->Implements<UEquipmentSystemInterface>())
	{
		return;
	}

	if (const IEquipmentSystemInterface* Implementer = Cast<IEquipmentSystemInterface>(Owner))
	{
		if (const UEquipmentSystemComponent* const EquipmentSystemComponent = Implementer->GetEquipmentSystemComponent(); IsValid(EquipmentSystemComponent))
		{
			if (AWeaponActor* Weapon = EquipmentSystemComponent->FindWeaponActorAttachedToBone(BoneName); IsValid(Weapon))
			{
				Weapon->OpenCollisionWindow(HitPolicy);
				CachedWeapon = Weapon;
			}			
		}
	}
}

void UCollisionNotifyState::NotifyEnd(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference)
{
	Super::NotifyEnd(MeshComp, Animation, EventReference);

	if (!IsValid(MeshComp))
	{
		UE_LOG(LogAnimation, Warning, TEXT("Attempt to end a notification with an invalid component or collision set."));
		return;
	}

	if (IsValid(CachedWeapon))
	{
		CachedWeapon->CloseCollisionWindow();
	}
}


############## Private\Components\EquipmentSystemComponent.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/EquipmentSystemComponent.h"

#include "Actors/WeaponActor.h"
#include "Data/EquipmentCache.h"
#include "Data/EquipmentEntry.h"
#include "Data/Slots/EquipmentSlotMapData.h"
#include "Data/Slots/SlotDefinition.h"
#include "Definitions/Fragments/ItemFragment_Equippable.h"
#include "Engine/ActorChannel.h"
#include "GameplayTags/EquipmentGameplayTags.h"
#include "Instances/EquipmentInstance.h"
#include "Instances/ItemInstance.h"
#include "Log/EquipmentSystemLog.h"
#include "Net/UnrealNetwork.h"
#include "Policies/SlotPolicy.h"

#include "Stats/EquipmentSystemStats.h"

#define LOCTEXT_NAMESPACE "UEquipmentSystemComponent"

UEquipmentSystemComponent::UEquipmentSystemComponent(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer), EquipmentList(this)
{
	PrimaryComponentTick.bCanEverTick = false;
	bWantsInitializeComponent = true;

	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
}

void UEquipmentSystemComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, EquipmentList);
}

bool UEquipmentSystemComponent::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)
{
	bool bReplicated = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			bReplicated |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return bReplicated;
}

void UEquipmentSystemComponent::ReadyForReplication()
{
	Super::ReadyForReplication();

	// Register all equipment instances ready for replication with the actor component
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FEquipmentEntry& Entry : EquipmentList.Entries)
		{
			if (UEquipmentInstance* Instance = Entry.Instance; IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}

void UEquipmentSystemComponent::InitializeComponent()
{
	Super::InitializeComponent();

	// Cache initialization
	Cache = NewObject<UEquipmentCache>(this, "Cache");

	if (IsValid(SlotMapData))
	{
		for (const FSlotDefinition& Def : SlotMapData->Slots)
		{
			if (Def.SlotTag.IsValid())
			{
				SlotMapRuntime.Add(Def.SlotTag, FDynamicEquipmentSlot{});
			}
		}
	}
}

void UEquipmentSystemComponent::UninitializeComponent()
{
	TArray<FGameplayTag> SlotsToUnequip;
	for (const auto& Pair : SlotMapRuntime)
	{
		if (IsValid(Pair.Value.ItemInstance))
		{
			SlotsToUnequip.Add(Pair.Key);
		}
	}

	FGameplayTag FailureReason;
	for (const FGameplayTag& SlotTag : SlotsToUnequip)
	{
		TryUnequipSlot(SlotTag, FailureReason);
	}

	Super::UninitializeComponent();
}

FEquipmentResult UEquipmentSystemComponent::TryEquipItem(UItemInstance* ItemInstance)
{
	FEquipmentResult Result;
	if (!IsValid(ItemInstance))
	{
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_NullItem;
		return Result;
	}

	const UItemFragment_Equippable* Frag = ItemInstance->FindFragmentByClass<UItemFragment_Equippable>();
	if (!Frag || !Frag->EquipmentDefinition)
	{
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_MissingDefinition;
		return Result;
	}

	const UEquipmentDefinition* Definition = GetCachedDefinition(Frag->EquipmentDefinition);
	const FGameplayTag SlotTag = Definition->SlotTag;

	return TryEquipItemOnSlot(ItemInstance, Definition->SlotTag);
}

FEquipmentResult UEquipmentSystemComponent::TryEquipItemOnSlot(UItemInstance* ItemInstance, const FGameplayTag& SlotTag)
{
	FEquipmentResult Result;
	if (!IsValid(ItemInstance))
	{
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_NullItem;
		return Result;
	}

	const UItemFragment_Equippable* Frag = ItemInstance->FindFragmentByClass<UItemFragment_Equippable>();
	if (!Frag || !Frag->EquipmentDefinition)
	{
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_MissingDefinition;
		return Result;
	}

	const UEquipmentDefinition* Definition = GetCachedDefinition(Frag->EquipmentDefinition);

	// De-equip the current slot if necessary
	if (const FDynamicEquipmentSlot* CurrentSlot = FindSlot(SlotTag))
	{
		if (IsValid(CurrentSlot->ItemInstance))
		{
			if (!Internal_ProcessUnequip(SlotTag, Result.FailureReason))
			{
				return Result;
			}
		}
	}

	return Internal_ProcessEquip(ItemInstance, SlotTag, Definition);
}

bool UEquipmentSystemComponent::TryUnequipItem(UItemInstance* ItemInstance, FGameplayTag& OutFailureReason)
{
	if (!IsValid(ItemInstance))
	{
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_NullItem;
		return false;
	}

	const FGameplayTag Slot = GetSlotForItem(ItemInstance);
	if (!Slot.IsValid())
	{
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotNotFound;
		return false;
	}

	return TryUnequipSlot(Slot, OutFailureReason);
}

bool UEquipmentSystemComponent::TryUnequipSlot(const FGameplayTag SlotTag, FGameplayTag& OutFailureReason)
{
	return Internal_ProcessUnequip(SlotTag, OutFailureReason);
}

bool UEquipmentSystemComponent::TrySwapSlots(const FGameplayTag& SlotA, const FGameplayTag& SlotB, FGameplayTag& OutFailureReason)
{
	// First validate that both slots exist in our runtime map
	if (!SlotMapRuntime.Contains(SlotA) || !SlotMapRuntime.Contains(SlotB))
	{
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotNotFound;
		return false;
	}

	const FDynamicEquipmentSlot& SlotDataA = SlotMapRuntime.FindChecked(SlotA);
	const FDynamicEquipmentSlot& SlotDataB = SlotMapRuntime.FindChecked(SlotB);

	// If both slots are empty, no swap is needed
	if (!IsValid(SlotDataA.ItemInstance) && !IsValid(SlotDataB.ItemInstance))
	{
		return true;
	}

	// Store slot A contents before we start moving things around
	UItemInstance* TempItemA = SlotDataA.ItemInstance;
	UEquipmentInstance* TempEquipA = SlotDataA.EquipmentInstance;

	// First phase: Unequip both slots while preserving the item references
	if (IsValid(SlotDataA.ItemInstance))
	{
		if (!Internal_ProcessUnequip(SlotA, OutFailureReason, true))
		{
			return false;
		}
	}

	if (IsValid(SlotDataB.ItemInstance))
	{
		if (!Internal_ProcessUnequip(SlotB, OutFailureReason, true))
		{
			// On failure, restore slot A to its original state
			if (IsValid(TempItemA))
			{
				if (const UItemFragment_Equippable* Frag = TempItemA->FindFragmentByClass<UItemFragment_Equippable>(); Frag->EquipmentDefinition)
				{
					Internal_ProcessEquip(TempItemA, SlotA, GetCachedDefinition(Frag->EquipmentDefinition));
				}
			}
			return false;
		}
	}

	// Second phase: Cross-equip items into their new slots
	bool bSuccess = true;
	if (IsValid(SlotDataB.ItemInstance))
	{
		if (const UItemFragment_Equippable* Frag = SlotDataB.ItemInstance->FindFragmentByClass<UItemFragment_Equippable>(); Frag->EquipmentDefinition)
		{
			const FEquipmentResult Result = Internal_ProcessEquip(SlotDataB.ItemInstance, SlotA, GetCachedDefinition(Frag->EquipmentDefinition));
			bSuccess = Result.Succeeded();
		}
	}

	if (bSuccess && IsValid(TempItemA))
	{
		if (const UItemFragment_Equippable* Frag = TempItemA->FindFragmentByClass<UItemFragment_Equippable>(); Frag->EquipmentDefinition)
		{
			const FEquipmentResult Result = Internal_ProcessEquip(TempItemA, SlotB, GetCachedDefinition(Frag->EquipmentDefinition));
			bSuccess = Result.Succeeded();
		}
	}

	return bSuccess;
}

bool UEquipmentSystemComponent::IsSlotBlocked(const FGameplayTag& SlotTag, const bool bExact) const
{
	if (bExact)
	{
		return BlockedSlots.GetTagCount(SlotTag) > 0;
	}
	return BlockedSlots.HasMatchingGameplayTag(SlotTag);
}

const FDynamicEquipmentSlot* UEquipmentSystemComponent::FindSlot(const FGameplayTag& SlotTag) const
{
	return SlotMapRuntime.Find(SlotTag);
}

const FGameplayTag& UEquipmentSystemComponent::GetSlotForItem(UItemInstance* ItemInstance)
{
	if (IsValid(ItemInstance))
	{
		for (const auto& [SlotTag, SlotData] : SlotMapRuntime)
		{
			if (SlotData.ItemInstance == ItemInstance)
			{
				return SlotTag;
			}
		}
	}
	return FGameplayTag::EmptyTag;
}

UItemInstance* UEquipmentSystemComponent::GetItemInSlot(const FGameplayTag& SlotTag)
{
	if (SlotMapRuntime.Contains(SlotTag))
	{
		return SlotMapRuntime.FindChecked(SlotTag).ItemInstance;
	}
	return nullptr;
}

UEquipmentInstance* UEquipmentSystemComponent::GetEquipmentInSlot(const FGameplayTag& SlotTag)
{
	if (SlotMapRuntime.Contains(SlotTag))
	{
		return SlotMapRuntime.FindChecked(SlotTag).EquipmentInstance;
	}
	return nullptr;
}


void UEquipmentSystemComponent::GetEquippedItems(TMap<FGameplayTag, UItemInstance*>& OutItems) const
{
	OutItems.Empty();
	for (const auto& [SlotTag, SlotData] : SlotMapRuntime)
	{
		if (SlotData.ItemInstance)
		{
			OutItems.Add(SlotTag, SlotData.ItemInstance);
		}
	}
}

UEquipmentInstance* UEquipmentSystemComponent::GetInstanceOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass)
{
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA(InstanceClass))
			{
				return Instance;
			}
		}
	}
	return nullptr;
}

TArray<UEquipmentInstance*> UEquipmentSystemComponent::GetAllInstancesOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass)
{
	TArray<UEquipmentInstance*> Results;
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA(InstanceClass))
			{
				Results.Add(Instance);
			}
		}
	}
	return Results;
}

UEquipmentDefinition* UEquipmentSystemComponent::GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class) const
{
	if (IsValid(Cache))
	{
		return Cache->GetCachedDefinition(Class);
	}
	if (IsValid(Class))
	{
		return NewObject<UEquipmentDefinition>(GetOuter(), Class);
	}
	return nullptr;
}

UEquipmentInstance* UEquipmentSystemComponent::GetInstanceFromItem(UItemInstance* ItemInstance)
{
	for (FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->GetSourceItem() == ItemInstance)
			{
				return Instance;
			}
		}
	}
	return nullptr;
}

AWeaponActor* UEquipmentSystemComponent::FindWeaponActorAttachedToBone(const FName& BoneName) const
{
	if (BoneName.IsNone())
		return nullptr;

	auto Predicate = [BoneName](const AActor* Actor)
	{
		if (!IsValid(Actor)) return false;

		if (!Actor->IsA(AWeaponActor::StaticClass()))
			return false;

		if (const USceneComponent* Root = Actor->GetRootComponent(); IsValid(Root))
		{
			return Root->GetAttachSocketName() == BoneName;
		}
		return false;
	};
	
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (const UEquipmentInstance* Instance = Entry.Instance)
		{
			TArray<AActor*> SpawnedActors = Instance->GetSpawnedActors();
			if (AActor* FoundActor = *SpawnedActors.FindByPredicate(Predicate); IsValid(FoundActor))
			{
				return Cast<AWeaponActor>(FoundActor);
			}
		}
	}
	
	return nullptr;
}

void UEquipmentSystemComponent::PostEquipmentEquipped(const FEquipmentChangeData& Data)
{
	OnEquipmentEquipped.Broadcast(Data);
}

void UEquipmentSystemComponent::PostEquipmentUnequipped(const FEquipmentChangeData& Data)
{
	OnEquipmentUnequipped.Broadcast(Data);
}

void UEquipmentSystemComponent::PostEquipmentChanged(const FEquipmentChangeData& Data)
{
	OnEquipmentChanged.Broadcast(Data);
}

void UEquipmentSystemComponent::LockSlots(const FGameplayTagContainer& Tags)
{
	BlockedSlots.UpdateTagCount(Tags, 1);
}

void UEquipmentSystemComponent::UnlockSlots(const FGameplayTagContainer& Tags)
{
	BlockedSlots.UpdateTagCount(Tags, -1);
}

FEquipmentResult UEquipmentSystemComponent::Internal_ProcessEquip(UItemInstance* ItemInstance, const FGameplayTag& TargetSlot, const UEquipmentDefinition* Definition)
{
	SCOPE_CYCLE_COUNTER(STAT_Equipment_ProcessEquip);

	FEquipmentResult Result;
	// Validate input parameters
	if (!IsValid(ItemInstance))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process equipment of a null item instance."));
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_NullItem;
		return Result;
	}

	if (!IsValid(Definition))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process equipment of %s with a null equipment definition."), *GetNameSafe(ItemInstance));
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_MissingDefinition;
		return Result;
	}

	// Validate slot exists in our equipment system
	if (!FindSlot(TargetSlot))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process equipment of %s as %s but did not found slot %s in the slot map."), *GetNameSafe(ItemInstance), *GetNameSafe(Definition), *TargetSlot.ToString());
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotNotFound;
		return Result;
	}

	// Check if slot is currently blocked by another item
	if (IsSlotBlocked(TargetSlot, true))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process equipment of %s as %s on slot %s but the slot is blocked."), *GetNameSafe(ItemInstance), *GetNameSafe(Definition), *TargetSlot.ToString());
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotBlocked;
		return Result;
	}

	// Check if the slot policy allows this equipment
	if (const USlotPolicy* Policy = Definition->SlotPolicy)
	{
		if (!Policy->CanEquipItem(ItemInstance, TargetSlot, this))
		{
			Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_PolicyRefused;
			return Result;
		}
	}

	// Perform the actual equipment operation
	Result = Internal_EquipOnSlot(TargetSlot, ItemInstance, Definition);
	if (!Result.Succeeded())
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process equipment of %s as %s on slot %s but failed to instantiate the equipment."), *GetNameSafe(ItemInstance), *GetNameSafe(Definition), *TargetSlot.ToString());
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_Internal;
		return Result;
	}

	return Result;
}

bool UEquipmentSystemComponent::Internal_ProcessUnequip(const FGameplayTag& SlotTag, FGameplayTag& OutFailureReason, const bool bPreserveItem)
{
	SCOPE_CYCLE_COUNTER(STAT_Equipment_ProcessUnequip);

	// Validate that the slot exists in our runtime map
	if (!SlotMapRuntime.Contains(SlotTag))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process un-equipment but did not found slot %s in the slot map."), *SlotTag.ToString());
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotNotFound;
		return false;
	}

	auto& SlotData = SlotMapRuntime.FindChecked(SlotTag);

	// Check if there's actually something equipped in this slot
	if (!IsValid(SlotData.ItemInstance) || !IsValid(SlotData.EquipmentInstance))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process un-equipment but the slot %s is empty."), *SlotTag.ToString());
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_SlotEmpty;
		return false;
	}

	// Validate that the item has the required equippable fragment
	const UItemFragment_Equippable* Frag = SlotData.ItemInstance->FindFragmentByClass<UItemFragment_Equippable>();
	if (!Frag || !Frag->EquipmentDefinition)
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process un-equipment on the slot %s but did found a non-equipable item."), *SlotTag.ToString());
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_MissingDefinition;
		return false;
	}

	// Get and validate the equipment definition
	const UEquipmentDefinition* Def = GetCachedDefinition(Frag->EquipmentDefinition);
	if (!IsValid(Def))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to process un-equipment on the slot %s but impossible to get the equipment definition."), *SlotTag.ToString());
		OutFailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_Internal;
		return false;
	}

	// Remove any slot blocking applied by this equipment's policy
	if (const USlotPolicy* Policy = Def->SlotPolicy)
	{
		UnlockSlots(Policy->GetBlockedSlotTags());
	}

	// Store the instance before clearing slot data
	UEquipmentInstance* Instance = SlotData.EquipmentInstance;
	if (!bPreserveItem)
	{
		SlotData.ItemInstance = nullptr;
	}
	SlotData.EquipmentInstance = nullptr;

	// Clean up the equipment instance
	if (IsValid(Instance))
	{
		if (IsUsingRegisteredSubObjectList())
		{
			RemoveReplicatedSubObject(Instance);
		}
		Instance->OnUnequipped();
		EquipmentList.Remove(Instance, OutFailureReason);
	}

	OutFailureReason = FGameplayTag::EmptyTag;
	return true;
}


FEquipmentResult UEquipmentSystemComponent::Internal_EquipOnSlot(const FGameplayTag& SlotTag, UItemInstance* ItemInstance, const UEquipmentDefinition* Definition)
{
	SCOPE_CYCLE_COUNTER(STAT_Equipment_EquipOnSlot);

	// Create a new equipment instance and add it to our list
	FEquipmentResult Result = EquipmentList.Add(Definition->GetClass(), ItemInstance);
	if (!Result.Succeeded())
	{
		return Result;
	}

	// Notify the instance it has been equipped
	Result.Instance->OnEquipped();

	// Setup replication if needed
	if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		AddReplicatedSubObject(Result.Instance);
	}

	// Update the runtime slot with the new equipment
	FDynamicEquipmentSlot& RuntimeSlot = SlotMapRuntime.FindChecked(SlotTag);
	RuntimeSlot.SlotTag = SlotTag;
	RuntimeSlot.ItemInstance = ItemInstance;
	RuntimeSlot.EquipmentInstance = Result.Instance;

	// Apply any slot blocking from the equipment policy
	if (const USlotPolicy* Policy = Definition->SlotPolicy)
	{
		LockSlots(Policy->GetBlockedSlotTags());
	}

	return Result;
}

#undef LOCTEXT_NAMESPACE


############## Private\Data\EquipmentCache.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentCache.h"

#include "Definitions/EquipmentDefinition.h"

UEquipmentCache::UEquipmentCache()
{
	// Register the cache for cleanup after garbage collection
	FCoreUObjectDelegates::GetPostGarbageCollect().AddUObject(this, &UEquipmentCache::Clean);
}

UEquipmentCache::~UEquipmentCache()
{
	// Unregister from the garbage collection delegate
	FCoreUObjectDelegates::GetPostGarbageCollect().RemoveAll(this);
}

UEquipmentDefinition* UEquipmentCache::GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class)
{
	if (!IsValid(Class))
	{
		return nullptr;
	}

	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);
	if (const TWeakObjectPtr<UEquipmentDefinition>* const FoundDefinition = CachedDefinitionMap.Find(Class))
	{
		if (UEquipmentDefinition* Definition = FoundDefinition->Get(); IsValid(Definition))
		{
			return Definition;
		}
	}

	// If the definition is not cached, create a new instance
	UEquipmentDefinition* NewDefinition = NewObject<UEquipmentDefinition>(this, Class);
	CachedDefinitionMap.Add(Class, NewDefinition);

	return NewDefinition;
}

bool UEquipmentCache::IsCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class)
{
	FScopeLock Lock(&CacheLock);
	const bool IsCachedDefinition = CachedDefinitionMap.Contains(Class);
	return IsCachedDefinition;
}

void UEquipmentCache::Clean()
{
	if (IsValid(this))
	{
		// Lock the critical section to ensure thread-safe access to the cache
		FScopeLock Lock(&CacheLock);
		for (auto It = CachedDefinitionMap.CreateIterator(); It; ++It)
		{
			if (It.Value() == nullptr || !It.Value().IsValid())
			{
				It.RemoveCurrent();
			}
		}
	}
}


############## Private\Data\EquipmentEntry.cpp ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentEntry.h"

#include "Components/EquipmentSystemComponent.h"
#include "Data/EquipmentList.h"
#include "Definitions/EquipmentDefinition.h"
#include "Instances/EquipmentInstance.h"
#include "Log/EquipmentSystemLog.h"

void FEquipmentEntry::PreReplicatedRemove(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnRemoveEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

void FEquipmentEntry::PostReplicatedAdd(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnAddedEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

void FEquipmentEntry::PostReplicatedChange(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnChangedEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

FString FEquipmentEntry::GetDebugString() const
{
	return FString::Printf(TEXT("%s [Def: %s]"), *GetNameSafe(Instance), *GetNameSafe(EquipmentDefinition.Get()));
}


############## Private\Data\EquipmentList.cpp ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentList.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "Components/EquipmentSystemComponent.h"
#include "Data/AbilitySet.h"
#include "Data/AbilitySetHandles.h"
#include "Data/EquipmentChangeData.h"
#include "GameplayTags/EquipmentGameplayTags.h"
#include "Instances/EquipmentInstance.h"
#include "Log/EquipmentSystemLog.h"

FEquipmentList::FEquipmentList()
{
}

FEquipmentList::FEquipmentList(UEquipmentSystemComponent* InOwnerComponent)
	: OwnerComponent(InOwnerComponent)
{
}

FEquipmentList::~FEquipmentList()
{
	Entries.Empty();
}

void FEquipmentList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (const int32 Index : RemovedIndices)
	{
		if (FEquipmentEntry& Entry = Entries[Index]; Entry.Instance != nullptr)
		{
			Entry.Instance->OnUnequipped();
			Entry.LastInstance = nullptr;

			Internal_OnEntryRemoved(Index, Entry);
		}
	}
}

void FEquipmentList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (const int32 Index : AddedIndices)
	{
		if (FEquipmentEntry& Entry = Entries[Index]; Entry.Instance != nullptr)
		{
			Entry.Instance->OnEquipped();
			Entry.LastInstance = MakeWeakObjectPtr<UEquipmentInstance>(Entry.Instance);

			Internal_OnEntryAdded(Index, Entry);
		}
	}
}

void FEquipmentList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (const int32 Index : ChangedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FEquipmentEntry& Entry = Entries[Index];

			if (IsValid(Entry.Instance))
			{
				Entry.Instance->OnEquipped();
			}

			if (Entry.Instance != Entry.LastInstance.Get() && Entry.LastInstance.IsValid())
			{
				Entry.LastInstance->OnUnequipped();
				Entry.LastInstance = MakeWeakObjectPtr<UEquipmentInstance>(Entry.Instance);
			}

			Internal_OnEntryChanged(Index, Entry);
		}
	}
}

FEquipmentResult FEquipmentList::Add(const TSubclassOf<UEquipmentDefinition>& DefinitionClass, UItemInstance* SourceItemInstance)
{
	FEquipmentResult Result;
	if (DefinitionClass == nullptr || !IsValid(OwnerComponent))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to instantiate an equipment instance from invalid definition class."));
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_MissingDefinition;
		return Result;
	}

	AActor* OwnerActor = OwnerComponent->GetOwner();
	if (!OwnerActor->HasAuthority())
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to instantiate an equipment instance from invalid definition class."));
		Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_NotAuthority;
		return Result;
	}

	UEquipmentDefinition* CachedDefinition = OwnerComponent->GetCachedDefinition(DefinitionClass);
	if (!CachedDefinition->CanBeEquipped(OwnerComponent, Result.FailureReason))
	{
		UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to instantiate an equipment instance from %s, but the definition conditions are not met."), *GetNameSafe(DefinitionClass));
		if (!Result.FailureReason.IsValid())
		{
			Result.FailureReason = EquipmentSystemGameplayTags::TAG_Equipment_Failure_DefinitionRefused;
		}
		return Result;
	}

	// Prepare an instance type to spawn, use the default one by default
	TSubclassOf<UEquipmentInstance> InstanceType = CachedDefinition->InstanceClass;
	if (InstanceType == nullptr)
	{
		InstanceType = UEquipmentDefinition::StaticClass();
	}

	// Add default entry
	FEquipmentEntry& Entry = Entries.AddDefaulted_GetRef();

	Entry.EquipmentDefinition = DefinitionClass;
	Entry.Instance = NewObject<UEquipmentInstance>(OwnerActor, InstanceType);

	UEquipmentInstance* Instance = Entry.Instance;
	Instance->SetDefinition(CachedDefinition);
	Instance->SetInstigator(OwnerActor);
	Instance->SetSourceItem(SourceItemInstance);

	Result.Instance = Instance;

	// Give the ability sets
	if (UAbilitySystemComponent* AbilitySystemComp = GetAbilitySystemComponent())
	{
		for (const TObjectPtr<const UAbilitySet>& AbilitySet : CachedDefinition->AbilitySets)
		{
			AbilitySet->GiveToAbilitySystem(AbilitySystemComp, &Entry.Handles, Instance);
		}
	}

	// Ask the instance to spawn attachment actors
	Instance->SpawnActors(CachedDefinition->ActorsToSpawn);
	Instance->OnSpawned();

	// Mark the item dirty for the serializer replication
	MarkItemDirty(Entry);

	return Result;
}

void FEquipmentList::Remove(UEquipmentInstance* Instance, FGameplayTag& OutFailureReason)
{
	if (!IsValid(Instance))
		return;
	
	for (auto EntryIterator = Entries.CreateIterator(); EntryIterator; ++EntryIterator)
	{
		if (FEquipmentEntry& Entry = *EntryIterator; Entry.Instance == Instance)
		{
			if (UAbilitySystemComponent* AbilitySystemComp = GetAbilitySystemComponent())
			{
					Entry.Handles.TakeFromAbilitySystem(AbilitySystemComp);
			}

			// Ask the instance to destroy its attachment actors
			Instance->DestroyActors();

			EntryIterator.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}

void FEquipmentList::Internal_OnEntryChanged(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = Entry.Instance;
	Data.OldInstance = nullptr;
	Data.ChangeType = EEquipmentChangeType::Modified;

	OwnerComponent->PostEquipmentChanged(Data);
}

void FEquipmentList::Internal_OnEntryAdded(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = Entry.Instance;
	Data.OldInstance = nullptr;
	Data.ChangeType = EEquipmentChangeType::Equipped;

	OwnerComponent->PostEquipmentEquipped(Data);
	OwnerComponent->PostEquipmentChanged(Data);
}

void FEquipmentList::Internal_OnEntryRemoved(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = nullptr;
	Data.OldInstance = Entry.Instance;
	Data.ChangeType = EEquipmentChangeType::Unequipped;

	OwnerComponent->PostEquipmentUnequipped(Data);
	OwnerComponent->PostEquipmentChanged(Data);
}

UAbilitySystemComponent* FEquipmentList::GetAbilitySystemComponent() const
{
	check(OwnerComponent);

	const AActor* OwningActor = OwnerComponent->GetOwner();
	return UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor);
}


############## Private\Data\Slots\EquipmentSlotMapData.cpp ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/Slots/EquipmentSlotMapData.h"

FPrimaryAssetId UEquipmentSlotMapData::GetPrimaryAssetId() const
{
	return FPrimaryAssetId("SlotMap", GetFName());
}


############## Private\Definitions\EquipmentDefinition.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/EquipmentDefinition.h"

#include "Definitions/Fragments/EquipmentFragment.h"
#include "Instances/EquipmentInstance.h"

UEquipmentDefinition::UEquipmentDefinition(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get())
{
	InstanceClass = UEquipmentInstance::StaticClass();
}

#if WITH_EDITOR
void UEquipmentDefinition::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	// Check if the Fragments property has changed
	if (PropertyChangedEvent.Property && PropertyChangedEvent.GetPropertyName() == GET_MEMBER_NAME_CHECKED(UEquipmentDefinition, Fragments))
	{
		TSet<UClass*> FragmentClasses;
		for (int32 i = Fragments.Num() - 1; i >= 0; --i)
		{
			if (const UEquipmentFragment* Fragment = Fragments[i]; IsValid(Fragment) && FragmentClasses.Contains(Fragment->GetClass()))
			{
				// Remove duplicate fragments
				Fragments.RemoveAt(i);

				UE_LOG(LogTemp, Warning, TEXT("Only one fragment per class is allowed. Duplicate fragment removed."));
			}
			else if (Fragment)
			{
				FragmentClasses.Add(Fragment->GetClass());
			}
		}
	}
}
#endif

const UEquipmentFragment* UEquipmentDefinition::FindFragmentByClass(const TSubclassOf<UEquipmentFragment> FragmentClass) const
{
	if (IsValid(FragmentClass))
	{
		for (const UEquipmentFragment* Fragment : Fragments)
		{
			if (IsValid(Fragment) && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}

bool UEquipmentDefinition::CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent, FGameplayTag& OutFailureReason)
{
	return K2_CanBeEquipped(EquipmentSystemComponent, OutFailureReason);
}

bool UEquipmentDefinition::K2_CanBeEquipped_Implementation(UEquipmentSystemComponent* EquipmentSystemComponent, FGameplayTag& OutFailureReason)
{
	return true;
}


############## Private\Definitions\Fragments\EquipmentFragment.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/EquipmentFragment.h"

void UEquipmentFragment::OnInstanceCreated(UEquipmentInstance* Instance) const
{
}


############## Private\Definitions\Fragments\ItemFragment_Equippable.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Equippable.h"

void UItemFragment_Equippable::OnInstanceCreated(UItemInstance* Instance)
{
	Super::OnInstanceCreated(Instance);
}


############## Private\GameplayTags\EquipmentGameplayTags.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "GameplayTags/EquipmentGameplayTags.h"

namespace EquipmentSystemGameplayTags
{
	// Base tag for equipment slots
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Slot, "Equipment.Slot", "Root gameplay tag for equipment slots");

	// Equipment failure tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure, "Equipment.Failure", "Root tag for equipment failures");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_NullItem, "Equipment.Failure.NullItem", "The item to equip is null");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_MissingDefinition, "Equipment.Failure.MissingDefinition", "Equipment definition is missing");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_SlotNotFound, "Equipment.Failure.SlotNotFound", "Requested slot does not exist");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_SlotEmpty, "Equipment.Failure.SlotNotFound", "Requested slot does not exist");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_SlotBlocked, "Equipment.Failure.SlotBlocked", "The slot is currently blocked");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_PolicyRefused, "Equipment.Failure.PolicyRefused", "Equipment policy refused the equipment");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_Internal, "Equipment.Failure.Internal", "Internal error during equipment process");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_DefinitionRefused, "Equipment.Failure.DefinitionRefused", "Equipment definition conditions are not met");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Failure_NotAuthority, "Equipment.Failure.NotAuthority", "Internal error during equipment process");

	// Weapon collision tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Event_CollisionHit, "Equipment.Event.CollisionHit", "Gameplay event sent when a weapon hit an actor");
} // namespace EquipmentSystemGameplayTags


############## Private\Instances\EquipmentInstance.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/EquipmentInstance.h"

#include "GameFramework/Character.h"
#include "Log/EquipmentSystemLog.h"
#include "Net/UnrealNetwork.h"

#if UE_WITH_IRIS
#endif

UEquipmentInstance::UEquipmentInstance(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get())
{
}

UWorld* UEquipmentInstance::GetWorld() const
{
	if (const APawn* OwningPawn = GetPawn(); IsValid(OwningPawn))
	{
		return OwningPawn->GetWorld();
	}
	return nullptr;
}

void UEquipmentInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, DefinitionClass);
	DOREPLIFETIME(ThisClass, Instigator);
	DOREPLIFETIME(ThisClass, SpawnedActors);
	DOREPLIFETIME(ThisClass, Components);
}

APawn* UEquipmentInstance::GetPawn() const
{
	return Cast<APawn>(GetOuter());
}

APawn* UEquipmentInstance::GetTypedPawn(const TSubclassOf<APawn>& PawnType) const
{
	if (UClass* PawnClass = PawnType->GetClass(); IsValid(PawnClass) && IsValid(PawnType))
	{
		if (GetOuter()->IsA(PawnClass))
		{
			return Cast<APawn>(GetOuter());
		}
	}
	return nullptr;
}

UEquipmentComponent* UEquipmentInstance::AddComponent(const TSubclassOf<UEquipmentComponent> ComponentClass)
{
	if (UEquipmentComponent* const Component = NewObject<UEquipmentComponent>(ComponentClass); IsValid(Component))
	{
		Components.Add(Component);
		return Component;
	}
	return nullptr;
}

const UEquipmentComponent* UEquipmentInstance::FindComponentByClass(const TSubclassOf<UEquipmentComponent> ComponentClass) const
{
	if (IsValid(ComponentClass))
	{
		for (const UEquipmentComponent* Component : Components)
		{
			if (IsValid(Component) && Component->IsA(ComponentClass))
			{
				return Component;
			}
		}
	}

	return nullptr;
}

UObject* UEquipmentInstance::GetInstigator() const
{
	return Instigator;
}

void UEquipmentInstance::SetInstigator(UObject* InInstigator)
{
	Instigator = InInstigator;
}

UItemInstance* UEquipmentInstance::GetSourceItem() const
{
	return SourceItem;
}

TSubclassOf<UEquipmentDefinition> UEquipmentInstance::GetDefinitionClass() const
{
	return DefinitionClass;
}

UEquipmentDefinition* UEquipmentInstance::GetDefinition() const
{
	return Definition.Get();
}

void UEquipmentInstance::SetSourceItem(UItemInstance* InSourceObject)
{
	SourceItem = InSourceObject;
}

void UEquipmentInstance::SetDefinition(UEquipmentDefinition* InDefinition)
{
	Definition = InDefinition;
	if (IsValid(InDefinition))
	{
		DefinitionClass = InDefinition->GetClass();
	}
}

void UEquipmentInstance::SpawnActors(const TArray<FEquipmentActorSet>& ActorsToSpawn)
{
	UWorld* World = GetWorld();
	verifyf(IsValid(World), TEXT("Invalid world to spawn actors for %s"), *GetName());

	if (APawn* OwningPawn = GetPawn(); IsValid(OwningPawn))
	{
		// Use a root scene component as an attachment target by default
		USceneComponent* AttachTarget = OwningPawn->GetRootComponent();
		if (const ACharacter* Character = Cast<ACharacter>(OwningPawn))
		{
			AttachTarget = Character->GetMesh();
		}

		for (const auto& [ActorClass, AttachSocket, AttachTransform] : ActorsToSpawn)
		{
			if (!IsValid(ActorClass))
			{
				UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to spawn equipment actors with an invalid actor class for %s!"), *GetName());
				continue;
			}

			if (const auto NewActor = World->SpawnActorDeferred<AActor>(ActorClass, FTransform::Identity, OwningPawn); IsValid(NewActor))
			{
				NewActor->SetInstigator(OwningPawn);
				NewActor->FinishSpawning(FTransform::Identity, true);

				// Set relative transform before attaching
				NewActor->SetActorRelativeTransform(AttachTransform);
				NewActor->AttachToComponent(AttachTarget, FAttachmentTransformRules::KeepRelativeTransform, AttachSocket);

				SpawnedActors.Add(NewActor);
			}
		}
		return;
	}

	UE_LOG(LogEquipmentSystem, Error, TEXT("Tried to spawn equipment actors with an invalid pawn !"));
}

void UEquipmentInstance::DestroyActors()
{
	for (AActor* Actor : SpawnedActors)
	{
		if (IsValid(Actor))
		{
			Actor->Destroy();
		}
	}
}

void UEquipmentInstance::OnEquipped()
{
	K2_OnEquipped();
}

void UEquipmentInstance::OnUnequipped()
{
	K2_OnUnequipped();
}

void UEquipmentInstance::OnSpawned()
{
}

void UEquipmentInstance::OnRep_Instigator()
{
}


############## Private\Instances\Components\EquipmentComponent.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/EquipmentComponent.h"

void UEquipmentComponent::Initialize(UEquipmentInstance* InInstance)
{
	OwningInstance = InInstance;
}

UEquipmentInstance* UEquipmentComponent::GetOwningInstance()
{
	return OwningInstance;
}


############## Private\Log\EquipmentSystemLog.cpp ###############
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Log/EquipmentSystemLog.h"

DEFINE_LOG_CATEGORY(LogEquipmentSystem);


############## Private\Policies\SlotPolicy.cpp ###############
﻿// Fill out your copyright notice in the Description page of Project Settings.


#include "Policies/SlotPolicy.h"

#include "Components/EquipmentSystemComponent.h"

bool USlotPolicy::DoesBlockTag_Implementation(const FGameplayTag& TargetSlot, const UItemInstance* Item, const UObject* Context) const
{
	if (!BlockedSlotTags.IsValid())
	{
		return true;
	}

	return BlockedSlotTags.HasTag(TargetSlot) == false;
}

void USlotPolicy::GetBlockedSlotTags(FGameplayTagContainer& TagContainer) const
{
	TagContainer.Reset();
	TagContainer.AppendTags(BlockedSlotTags);
}

bool USlotPolicy::CanEquipItem(const UItemInstance* Item, const FGameplayTag& TargetSlot, const UObject* Context) const
{
	return K2_CanEquipItem(Item, TargetSlot, Context);
}

const FGameplayTagContainer& USlotPolicy::GetBlockedSlotTags() const
{
	return BlockedSlotTags;
}


############## Private\Settings\EquipmentSystemSettings.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/EquipmentSystemSettings.h"

#include "Misc/ConfigUtilities.h"

DEFINE_LOG_CATEGORY_STATIC(LogEquipmentSettings, Warning, All)

void UEquipmentSystemSettings::PostInitProperties()
{
	Super::PostInitProperties();
	
	if (IsTemplate())
	{
		// We want the .ini file to have precedence over the CVar constructor, so we apply the ini to the CVar before following the regular UDeveloperSettingsBackedByCVars flow
		UE::ConfigUtilities::ApplyCVarSettingsFromIni(TEXT("/Script/EquipmentSystemCore.EquipmentSystemSettings"), *GEngineIni, ECVF_SetByProjectSetting);
	}

	Super::PostInitProperties();
}

FName UEquipmentSystemSettings::GetContainerName() const
{
	static const FName Name("Project");
	return Name;
}

FName UEquipmentSystemSettings::GetCategoryName() const
{
	static const FName Name("Game");
	return Name;
}

UEquipmentSystemSettings* UEquipmentSystemSettings::GetEquipmentSystemSettings()
{
	// This is a singleton. Use a default object
	return GetMutableDefault<UEquipmentSystemSettings>();
}

void UEquipmentSystemSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);
}


############## Private\Stats\EquipmentSystemStats.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Stats/EquipmentSystemStats.h"

DEFINE_STAT(STAT_Equipment_ProcessEquip);
DEFINE_STAT(STAT_Equipment_ProcessUnequip);
DEFINE_STAT(STAT_Equipment_EquipOnSlot);


############## Public\EquipmentSystemCore.h ###############
﻿#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FEquipmentSystemCoreModule final : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};


############## Public\Abilities\EquipmentGameplayAbility.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Abilities/GameplayAbilityBase.h"
#include "CoreMinimal.h"
#include "Instances/ItemInstance.h"

#include "EquipmentGameplayAbility.generated.h"

class UItemInstance;
class UEquipmentInstance;

/**
 * @class UEquipmentGameplayAbility
 * @see UGameplayAbilityBase
 * @brief This class represents a gameplay ability specifically for equipment.
 * It extends the base gameplay ability with equipment-specific functionality.
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UEquipmentGameplayAbility : public UGameplayAbilityBase
{
	GENERATED_BODY()

public:
	UEquipmentGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Gets the source equipment instance for this ability.
	 * @return The UEquipmentInstance associated with this ability.
	 */
	UFUNCTION(BlueprintCallable, Category = "Ability")
	UEquipmentInstance* GetSourceEquipmentInstance() const;

	UFUNCTION(BlueprintCallable, Category = "Ability", BlueprintPure = false, meta = (DeterminesOutputType = InstanceClass))
	UEquipmentInstance* GetTypedSourceEquipmentInstance(const TSubclassOf<UEquipmentInstance>& InstanceClass) const;


	/**
	 * Gets the source item instance for this ability.
	 * @return The UItemInstance associated with this ability's equipment.
	 */
	UFUNCTION(BlueprintCallable, Category = "Ability")
	UItemInstance* GetSourceItemInstance() const;

	UFUNCTION(BlueprintCallable, Category = "Ability", BlueprintPure = false, meta = (DeterminesOutputType = InstanceClass))
	UItemInstance* GetTypedSourceItemInstance(const TSubclassOf<UItemInstance>& InstanceClass) const;

	/** Template method that attempts to get the source object as the specified type.
	 * @tparam T The type to cast the source object to.
	 * @return The source object cast to the specified type, or nullptr if invalid.
	 */
	template <class T>
	T* TryGetSourceObject() const;

	/** Template method that retrieves the source item instance as the specified type.
	 * @tparam T The type to cast the item instance to.
	 * @return The source item instance cast to the specified type, or nullptr if invalid.
	 */
	template <class T>
	T* GetTypedSourceItemInstance();

	/** Template method that retrieves the source equipment instance as the specified type.
	 * @tparam T The type to cast the equipment instance to.
	 * @return The source equipment instance cast to the specified type, or nullptr if invalid.
	 */
	template <class T>
	T* GetTypedSourceEquipmentInstance();

#if WITH_EDITOR
	/**
	 * Validates the data for this ability in the editor.
	 * @param Context The data validation context.
	 * @return The result of the data validation.
	 */
	virtual EDataValidationResult IsDataValid(FDataValidationContext& Context) const override;
#endif
};

template <class T>
T* UEquipmentGameplayAbility::TryGetSourceObject() const
{
	if (UObject* const SourceObject = GetCurrentSourceObject(); IsValid(SourceObject))
	{
		return Cast<T>(SourceObject);
	}
	return nullptr;
}

template <class T>
T* UEquipmentGameplayAbility::GetTypedSourceItemInstance()
{
	if (UItemInstance* Instance = GetSourceItemInstance(); IsValid(Instance))
	{
		return Cast<T>(Instance);
	}
	return nullptr;
}

template <class T>
T* UEquipmentGameplayAbility::GetTypedSourceEquipmentInstance()
{
	return TryGetSourceObject<T>();
}


############## Public\Actors\EquipmentActor.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "EquipmentActor.generated.h"

UCLASS()
class EQUIPMENTSYSTEMCORE_API AEquipmentActor : public AActor
{
	GENERATED_BODY()

public:
	AEquipmentActor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Get the owning pawn of this equipment.
	 * @return The owning pawn if it exists, otherwise nullptr.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment")
	virtual APawn* GetPawn();
};


############## Public\Actors\WeaponActor.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "EquipmentActor.h"
#include "Collisions/CollisionHitPolicy.h"
#include "Collisions/CollisionWindow.h"
#include "WeaponActor.generated.h"

class USkeletalMeshComponent;
struct FShapeElementSet;

// For Unreal Profiler
DECLARE_STATS_GROUP(TEXT("AWeaponActor"), STATGROUP_WeaponBase, STATCAT_Advanced);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam( FOnSweepCollisionHit, const FHitResult&, SweepResult);

/**
 * AWeaponActor
 *
 * Base class for weapons in the game, inheriting from AEquipmentActor.
 * Manages collision profiles, gameplay tags, collision windows, and handles overlap events.
 */
UCLASS(BlueprintType, Blueprintable)
class EQUIPMENTSYSTEMCORE_API AWeaponActor : public AEquipmentActor
{
	GENERATED_BODY()

public:

	AWeaponActor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaTime) override;
	// ~UObject

	/** Delegate called when the weapon collide on a sweep test. */
	UPROPERTY(BlueprintAssignable, Category = "Collision")
	FOnSweepCollisionHit OnSweepCollisionHit;
	
	UFUNCTION(BlueprintCallable, Category = "Collision")
	void OpenCollisionWindow(ECollisionHitPolicy& HitPolicy);
	UFUNCTION(BlueprintCallable, Category = "Collision")
	void CloseCollisionWindow();

	/**
	 * Blueprint event called when a collision component begins overlapping with another component.
	 * @param SweepResult Result of the sweep if it occurred.
	 */
	UFUNCTION(BlueprintImplementableEvent, Category = "Collision", DisplayName = "OnSweepCollisionHit")
	void K2_OnSweepCollisionHit(const FHitResult& SweepResult);


	UFUNCTION(BlueprintCallable, Category = "Collision")
	void SetPhysicsAssets(UPhysicsAsset* PhysicsAsset);
	
protected:

	UFUNCTION()
	virtual void OnCollisionTick();
	
	void OnAsyncTraceComplete(const FTraceHandle& TraceHandle, FTraceDatum& Data);
	
	void ProcessHitResults();
	void ComputeCollisionHit(const FHitResult& SweepResult);

	void UpdateShapeElementSets();

	static void GetCollisionColor(const ECollisionEnabled::Type CollisionType, FColor& Color);

protected:
	
	/** Skeletal mesh component of the weapon */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
	TObjectPtr<USkeletalMeshComponent> SkeletalMeshComponent;

	
	/** Whether we should trace against complex collision */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Trace Complex", AllowPrivateAccess))
	bool bTraceComplex = false;
	
	/** Whether we want to return the triangle face index for complex static mesh traces */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Return Face Index", AllowPrivateAccess))
	bool bReturnFaceIndex = false;

	/** Whether we want to include the physical material in the results. */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Return Physical Material", AllowPrivateAccess))
	bool bReturnPhysicalMaterial = false;

	/** Whether to ignore blocking results. */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Ignore Blocks", AllowPrivateAccess))
	bool bIgnoreBlocks = false;

	/** Whether to ignore touch/overlap results. */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Ignore Touches", AllowPrivateAccess))
	bool bIgnoreTouches = false;

	/** Whether to skip narrow phase checks (only for overlaps). */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Collision|Sweep Collision", AdvancedDisplay, meta = (DisplayName = "Skip Narrow Phase", AllowPrivateAccess))
	bool bSkipNarrowPhase = false;

	
	UPROPERTY()
	FCollisionWindow CollisionWindow;

	UPROPERTY()
	TArray<FShapeElementSet> ShapeElementSets;

	UPROPERTY()
	TObjectPtr<UPhysicsAsset> CachedPhysicsAsset = nullptr;

	UPROPERTY()
	bool bIsPreviousTraceComplete = true;

	FTraceDelegate AsyncTraceDelegate;
	TArray<FHitResult> ForwardHitResults;
};


############## Public\Animation\CollisionNotifyState.h ###############
﻿// // Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "Collisions/CollisionHitPolicy.h"
#include "CollisionNotifyState.generated.h"

class AWeaponActor;
/**
 * 
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UCollisionNotifyState : public UAnimNotifyState
{
	GENERATED_BODY()

public:

	// UAnimNotifyState
	virtual FString GetNotifyName_Implementation() const override;
	virtual void NotifyBegin(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration, const FAnimNotifyEventReference& EventReference) override;
	virtual void NotifyEnd(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
	// ~UAnimNotifyState

protected:

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Collision")
	FName BoneName;
	
	/** Policy for handling hits during the collision window */
	UPROPERTY(EditAnywhere, Category = "Collision")
	ECollisionHitPolicy HitPolicy = ECollisionHitPolicy::OneHitPerActor;

	UPROPERTY(Transient)
	TObjectPtr<AWeaponActor> CachedWeapon = nullptr;
};


############## Public\Collisions\CollisionHitPolicy.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

#include "CollisionHitPolicy.generated.h"

/**
 * EHitCollisionPolicy
 *
 * Defines how to handle collision on a weapon actor
 */
UENUM(BlueprintType)
enum class ECollisionHitPolicy : uint8
{
	OneHitOnly UMETA(DisplayName = "One Hit Only", ToolTip = "One hit for the whole window"),
	OneHitPerActor UMETA(DisplayName = "One Hit Per Actor", ToolTip = "One hit is allowed per actor on the whole window"),
	OneHitPerSuccessiveActor UMETA(DisplayName = "One Hit Per Successive Actor", ToolTip = "Only hits actor if different from previous actor"),
	Count UMETA(Hidden)
};

############## Public\Collisions\CollisionWindow.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "CollisionHitPolicy.h"

#include "CollisionWindow.generated.h"


/**
 * FCollisionWindow
 *
 * This structure represents a collision window triggered by the weapon collision anim notify
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FCollisionWindow
{
	GENERATED_BODY();

public:

	/**
	 * Constructor initializing the collision window with provided parameters.
	 *
	 * @param InPolicy The hit policy determining how collisions are processed.
	 */
	explicit FCollisionWindow( const ECollisionHitPolicy InPolicy = ECollisionHitPolicy::OneHitPerActor) : Policy(InPolicy)
	{
		// Reserve space for hit actors based on policy
		if (Policy == ECollisionHitPolicy::OneHitOnly || Policy == ECollisionHitPolicy::OneHitPerSuccessiveActor)
		{
			HitActors.Reserve(1);
		}
	}

public:

	/** Hit policy determining how collisions are processed */
	UPROPERTY(EditAnywhere)
	ECollisionHitPolicy Policy = ECollisionHitPolicy::OneHitPerActor;
	
	/** Array of actors hit during collision detection */
	UPROPERTY(EditAnywhere)
	TArray<AActor*> HitActors = {};
	
	UPROPERTY()
	FTimerHandle TimerHandle = FTimerHandle();
};

############## Public\Collisions\ShapeElementSet.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "PhysicsEngine/BoxElem.h"
#include "PhysicsEngine/ConvexElem.h"
#include "PhysicsEngine/ShapeElem.h"
#include "PhysicsEngine/SphereElem.h"
#include "PhysicsEngine/SphylElem.h"

#include "ShapeElementSet.generated.h"


/**
 * FAggregateGeomSet
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FShapeElementSet
{
	GENERATED_BODY();

public:

	FShapeElementSet() = default;
	FShapeElementSet(const TVariant<FKSphereElem, FKBoxElem, FKSphylElem, FKConvexElem>& InShapeElement, const FName& InBoneName, const FVector& InLocation = FVector::ZeroVector)
		: ShapeElement(InShapeElement), BoneName(InBoneName), LastLocation(InLocation){}

public:

	TVariant<FKSphereElem, FKBoxElem, FKSphylElem, FKConvexElem> ShapeElement;
	
	UPROPERTY()
	FName BoneName = NAME_None;
	
	UPROPERTY()
	FVector LastLocation = FVector::ZeroVector;

	UPROPERTY()
	TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled = ECollisionEnabled::NoCollision;
	
	// Handle for asynchronous tracing
	FTraceHandle ForwardTraceHandle = FTraceHandle();
	FTraceHandle ReverseTraceHandle = FTraceHandle();
};

############## Public\Components\EquipmentSystemComponent.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayEffectTypes.h"
#include "GameplayTagContainer.h"
#include "Components/ActorComponent.h"
#include "Data/EquipmentCache.h"
#include "Data/EquipmentList.h"
#include "Data/Slots/DynamicEquipmentSlot.h"
#include "Instances/EquipmentInstance.h"

#include "EquipmentSystemComponent.generated.h"

class AWeaponActor;
class UItemInstance;
class UEquipmentInstance;
class UEquipmentDefinition;
class UEquipmentSlotMapData;
class USlotPolicy;
struct FEquipmentChangeData;


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEquipmentChange, const FEquipmentChangeData&, Data);

/**
 * @class UEquipmentSystemComponent
 * @see UActorComponent
 * @brief Component managing equipment system functionality for actors
 * @details Manages equipment slots, item equipping/unequipping, and equipment instances.
 * Provides runtime validation of equipment changes through policies, maintains a dynamic
 * slot system, and handles replication of equipped items. Supports blocking/unblocking
 * equipment slots and broadcasting equipment change events.
 */
UCLASS(BlueprintType, meta = (BlueprintSpawnableComponent))
class EQUIPMENTSYSTEMCORE_API UEquipmentSystemComponent : public UActorComponent
{
	GENERATED_BODY()

	friend FEquipmentList;

public:
	explicit UEquipmentSystemComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	// ~UObject

	// AActorComponent
	virtual void InitializeComponent() override;
	virtual void UninitializeComponent() override;
	// ~AActorComponent


	/**
	 * Attempts to equip an item in the first available slot
	 * @param ItemInstance The item to equip
	 * @return True if the item was successfully equipped
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	FEquipmentResult TryEquipItem(UItemInstance* ItemInstance);

	/**
	 * Attempts to equip an item in a specific slot
	 * @param ItemInstance The item to equip
	 * @param SlotTag The target slot to equip the item in
	 * @return True if the item was successfully equipped
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	FEquipmentResult TryEquipItemOnSlot(UItemInstance* ItemInstance, const FGameplayTag& SlotTag);

	/**
	 * Attempts to unequip a currently equipped item
	 * @param ItemInstance The item to unequip
	 * @param OutFailureReason Contains the reason if the operation fails
	 * @return True if the item was successfully unequipped
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	bool TryUnequipItem(UItemInstance* ItemInstance, FGameplayTag& OutFailureReason);

	/**
	 * Attempts to unequip whatever item is in the specified slot
	 * @param SlotTag The slot to unequip
	 * @param OutFailureReason Contains the reason if the operation fails
	 * @return True if the slot was successfully unequipped
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	bool TryUnequipSlot(const FGameplayTag SlotTag, FGameplayTag& OutFailureReason);

	/**
	 * Attempts to swap items between two equipment slots
	 * @param SlotA First slot to swap
	 * @param SlotB Second slot to swap
	 * @param OutFailureReason Contains the reason if the operation fails
	 * @return True if the slots were successfully swapped
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	bool TrySwapSlots(const FGameplayTag& SlotA, const FGameplayTag& SlotB, FGameplayTag& OutFailureReason);


	/**
	 * Checks if a slot is currently blocked from equipment changes
	 * @param SlotTag The slot to check
	 * @param bExact If true, only checks for exact tag match
	 * @return True if the slot is blocked
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	bool IsSlotBlocked(const FGameplayTag& SlotTag, bool bExact = false) const;

	/**
	 * Finds a slot by its tag
	 * @param SlotTag The tag of the slot to find
	 * @return Pointer to the found slot, or nullptr if not found
	 */
	//UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	const FDynamicEquipmentSlot* FindSlot(const FGameplayTag& SlotTag) const;

	/**
	 * Gets the current runtime slot map
	 * @return Map of all equipment slots
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	TMap<FGameplayTag, FDynamicEquipmentSlot> GetSlotMap() const { return SlotMapRuntime; }


	/**
	 * Gets the slot tag where an item is currently equipped
	 * @param ItemInstance The item to find the slot for
	 * @return The tag of the slot containing the item
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	const FGameplayTag& GetSlotForItem(UItemInstance* ItemInstance);

	/**
	 * Gets the item instance equipped in a specific slot
	 * @param SlotTag The slot to check
	 * @return The item in the slot, or nullptr if empty
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	UItemInstance* GetItemInSlot(const FGameplayTag& SlotTag);

	/**
	 * Gets the equipment instance in a specific slot
	 * @param SlotTag The slot to check
	 * @return The equipment in the slot, or nullptr if empty
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment|Slots")
	UEquipmentInstance* GetEquipmentInSlot(const FGameplayTag& SlotTag);

	/**
	 * Gets all currently equipped items
	 * @param OutItems Map of slot tags to equipped items
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure)
	void GetEquippedItems(TMap<FGameplayTag, UItemInstance*>& OutItems) const;


	/**
	 * Gets an instance of the specified equipment type.
	 * @param InstanceClass The class of the equipment instance to find.
	 * @return The first found UEquipmentInstance of the specified type.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = InstanceClass))
	UEquipmentInstance* GetInstanceOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass);
	/**
	 * Gets an instance of specified equipment type using templates
	 * @tparam T The equipment instance type to find
	 * @return The first found instance of type T, or nullptr if none found
	 */
	template <typename T>
	T* GetInstanceOfType() const;

	/**
	 * Gets all instances of the specified equipment type.
	 * @param InstanceClass The class of the equipment instances to find.
	 * @return An array of UEquipmentInstances of the specified type.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = InstanceClass))
	TArray<UEquipmentInstance*> GetAllInstancesOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass);
	/**
	 * Gets all instances of specified equipment type using templates
	 * @tparam T The equipment instance type to find
	 * @return Array of all instances of type T
	 */
	template <typename T>
	TArray<T*> GetAllInstancesOfType() const;

	/**
	 * Retrieves a cached equipment definition
	 * @param Class The class of equipment definition to retrieve
	 * @return The cached equipment definition instance, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment", meta = (DeterminesOutputType = Class))
	UEquipmentDefinition* GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class) const;

	/**
	 * Gets the equipment instance of the associated ItemInstance
	 * @param ItemInstance The instance of the source item
	 * @return The equipment instance associated with the item, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment")
	UEquipmentInstance* GetInstanceFromItem(UItemInstance* ItemInstance);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment")
	AWeaponActor* FindWeaponActorAttachedToBone(const FName& BoneName) const;
	
protected:
	/**
	 * Called after equipment is successfully equipped
	 * @param Data The equipment change data
	 */
	virtual void PostEquipmentEquipped(const FEquipmentChangeData& Data);

	/**
	 * Called after equipment is successfully unequipped
	 * @param Data The equipment change data
	 */
	virtual void PostEquipmentUnequipped(const FEquipmentChangeData& Data);

	/**
	 * Called after any equipment change occurs
	 * @param Data The equipment change data
	 */
	virtual void PostEquipmentChanged(const FEquipmentChangeData& Data);

	/**
	 * Locks specified equipment slots from being modified
	 * @param Tags Container of slot tags to lock
	 */
	void LockSlots(const FGameplayTagContainer& Tags);

	/**
	 * Unlocks previously locked equipment slots
	 * @param Tags Container of slot tags to unlock
	 */
	void UnlockSlots(const FGameplayTagContainer& Tags);

	// Internal Equipment Logic
	FEquipmentResult Internal_ProcessEquip(UItemInstance* ItemInstance, const FGameplayTag& TargetSlot, const UEquipmentDefinition* Definition);
	bool Internal_ProcessUnequip(const FGameplayTag& SlotTag, FGameplayTag& OutFailureReason, bool bPreserveItem = false);
	FEquipmentResult Internal_EquipOnSlot(const FGameplayTag& SlotTag, UItemInstance* ItemInstance, const UEquipmentDefinition* Definition);

public:
	/** Delegate dispatched when an item is equipped */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentChange OnEquipmentChanged;
	/** Broadcasts when equipment is equipped, providing the instance. */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentChange OnEquipmentEquipped;
	/** Broadcasts when equipment is unequipped, providing the instance. */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentChange OnEquipmentUnequipped;

protected:
	/** The list of equipped items. */
	UPROPERTY(Replicated)
	FEquipmentList EquipmentList;

	/** Equipment definitions cache. Not replicated */
	UPROPERTY()
	TObjectPtr<UEquipmentCache> Cache;

	UPROPERTY(EditDefaultsOnly, Category = "Slots")
	TObjectPtr<UEquipmentSlotMapData> SlotMapData;

	UPROPERTY()
	TMap<FGameplayTag, FDynamicEquipmentSlot> SlotMapRuntime;

	FGameplayTagCountContainer BlockedSlots;
};

template <typename T>
T* UEquipmentSystemComponent::GetInstanceOfType() const
{
	return Cast<T>(GetInstanceOfType(T::StaticClass()));
}

template <typename T>
TArray<T*> UEquipmentSystemComponent::GetAllInstancesOfType() const
{
	TArray<T*> Instances;
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA<T>())
			{
				Instances.Add(Cast<T>(Instance));
			}
		}
	}
	return Instances;
}


############## Public\Data\EquipmentActorSet.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once
#include "GameplayTagContainer.h"

#include "EquipmentActorSet.generated.h"

USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentActorSet
{
	GENERATED_BODY()

	FEquipmentActorSet()
	{
	};

	/** The class of actor to spawn and attach. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	TSubclassOf<AActor> ActorClass;

	/** The socket on the owning actor to attach the spawned actor to. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	FName AttachSocket;

	/** The transform (position, rotation, scale) to apply relative to the socket. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	FTransform AttachTransform;
};


############## Public\Data\EquipmentCache.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "EquipmentCache.generated.h"

class UEquipmentDefinition;

/**
 * UEquipmentCache
 *
 * A cache system for EquipmentDefinition to improve performance by reducing object creation.
 * This class manages a thread-safe cache of EquipmentDefinitions.
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UEquipmentCache : public UObject
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;

public:
	UEquipmentCache();
	virtual ~UEquipmentCache() override;

	/**
	 * Get a cached EquipmentDefinition default object.
	 * If the EquipmentDefinition is not in the cache, it creates a new one and adds it to the cache.
	 *
	 * @param Class The class of the EquipmentDefinition to retrieve.
	 * @return A pointer to the cached or newly created EquipmentDefinition.
	 */
	UEquipmentDefinition* GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class);

	/**
	 * Check if the cache contains a cached default object of the given class.
	 *
	 * @param Class The class of the EquipmentDefinition.
	 * @return True if the cache contains a default object of the given class.
	 */
	bool IsCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class);

private:
	/**
	 * Clears the cache of any EquipmentDefinitions that are no longer rooted.
	 * This method is called after garbage collection.
	 */
	void Clean();

	/** Map to store cached EquipmentDefinitions */
	UPROPERTY()
	TMap<TSubclassOf<UEquipmentDefinition>, TWeakObjectPtr<UEquipmentDefinition>> CachedDefinitionMap;

	/** Critical section to ensure thread-safe access to the cache */
	FCriticalSection CacheLock;
};


############## Public\Data\EquipmentChangeData.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "EquipmentChangeData.generated.h"

class UEquipmentInstance;
struct FEquipmentEntry;
class UEquipmentnstance;

/**
 * Defines the types of changes that can occur to Equipment entries
 */
UENUM(BlueprintType)
enum class EEquipmentChangeType : uint8
{
	Equipped, ///< Equipment has just been equipped
	Unequipped, ///< Equipment has just been unequipped
	Modified ///< Equipment properties were modified
};

/**
 * @struct FEquipmentChangeData
 * @see UItemInstance, FEquipmentEntry, EEquipmentChangeType
 * @brief Represents a data payload for tracking Equipment item changes including addition, removal, and modification of items
 * @details Contains information about the affected item instance, its index in the Equipment, the type of change, 
 *		  and stack count changes before and after the modification occurred. Used for notifying systems about
 *		  Equipment state changes and maintaining synchronization.
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentChangeData
{
	GENERATED_BODY()

	FEquipmentChangeData()
	{
	}

	/**
	 * Constructs an Equipment change data instance with the specified parameters
	 * @param InIndex The index of the Equipment entry that was modified
	 * @param Entry The Equipment entry containing the item instance and stack count
	 * @param InChangeType The type of modification that occurred
	 */
	FEquipmentChangeData(const int32 InIndex, const FEquipmentEntry& Entry, const EEquipmentChangeType InChangeType = EEquipmentChangeType::Equipped);

	/** 
	 * Zero-based index of the modified Equipment entry
	 * Set to INDEX_NONE (-1) when the entry is invalid
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	int32 Index = INDEX_NONE;

	/** 
	 * Reference to the new equipment instance
	 * Contains the equipment's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	TObjectPtr<UEquipmentInstance> NewInstance = nullptr;

	/** 
	 * Reference to the previous equipment instance
	 * Contains the equipment's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	TObjectPtr<UEquipmentInstance> OldInstance = nullptr;

	/** 
	 * Specifies whether the item was added, removed, or modified
	 * Defaults to Added when not specified
	 */
	UPROPERTY(BlueprintReadOnly)
	EEquipmentChangeType ChangeType = EEquipmentChangeType::Equipped;

	/**
	 * Checks if this Equipment change data is valid
	 * @return True if the index is valid (not INDEX_NONE), false otherwise
	 */
	bool IsValid() const { return Index != INDEX_NONE; }
};


############## Public\Data\EquipmentEntry.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Data/AbilitySetHandles.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "EquipmentEntry.generated.h"

class UEquipmentDefinition;
class UEquipmentInstance;
/**
 * @class FEquipmentEntry
 *
 * @see FFastArraySerializerItem
 * @brief Entry of single equipped equipment
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;
	friend struct FEquipmentList;

	FEquipmentEntry()
	{
	}

	~FEquipmentEntry()
	{
	};

	// FFastArraySerializer
	// Functions not virtual in FFAstArraySerializer because called by template
	void PreReplicatedRemove(const FEquipmentList& InArraySerializer) const;
	void PostReplicatedAdd(const FEquipmentList& InArraySerializer) const;
	void PostReplicatedChange(const FEquipmentList& InArraySerializer) const;
	FString GetDebugString() const;
	// ~FFastArraySerializer

protected:
	UPROPERTY(SaveGame)
	TObjectPtr<UEquipmentInstance> Instance = nullptr;

	UPROPERTY(SaveGame)
	TSubclassOf<UEquipmentDefinition> EquipmentDefinition;

	// Authority-only list of granted handles for ability sets
	UPROPERTY(NotReplicated)
	FAbilitySetHandles Handles = {};

	UPROPERTY(NotReplicated)
	TWeakObjectPtr<UEquipmentInstance> LastInstance;
};


############## Public\Data\EquipmentList.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Definitions/EquipmentDefinition.h"
#include "EquipmentEntry.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "EquipmentList.generated.h"

class UItemInstance;
class UAbilitySystemComponent;

struct FNetDeltaSerializeInfo;
struct FReplicationFlags;


USTRUCT(BlueprintType)
struct FEquipmentResult
{
	GENERATED_BODY()
	;

	UPROPERTY(BlueprintReadOnly)
	UEquipmentInstance* Instance = nullptr;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag FailureReason;

	bool Succeeded() const { return !FailureReason.IsValid(); };
};


/**
 * @struct FEquipmentList
 * @see FFastArraySerializer
 * @brief Represents a list of equipment items that can be efficiently replicated using FastArraySerializer.
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentList : public FFastArraySerializer
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;
	friend FEquipmentEntry;

	FEquipmentList();
	FEquipmentList(UEquipmentSystemComponent* InOwnerComponent);
	~FEquipmentList();

	// FFastArraySerializer
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);

	/** Implements network delta serialization for the equipment list. */
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms)
	{
		return FastArrayDeltaSerialize<FEquipmentEntry, FEquipmentList>(Entries, DeltaParms, *this);
	}

	// ~FFastArraySerializer

	/** Add a new equipment instance to the list.
	 * @param DefinitionClass Definition of the type of equipment to add.
	 * @param SourceItemInstance
	 * @param OutFailureReason
	 * @return Pointer to entry added */
	FEquipmentResult Add(const TSubclassOf<UEquipmentDefinition>& DefinitionClass, UItemInstance* SourceItemInstance = nullptr);

	/**
	 * Remove the specified equipment instance from the list.
	 * @param Instance The instance to remove.
	 * @param OutFailureReason
	 */
	void Remove(UEquipmentInstance* Instance, FGameplayTag& OutFailureReason);

protected:
	/**
	 * Called when an entry is changed.
	 * @param Index The index of the changed entry.
	 * @param Entry The changed entry.
	 */
	void Internal_OnEntryChanged(int32 Index, const FEquipmentEntry& Entry) const;
	/**
	 * Called when an entry is added.
	 * @param Index The index of the added entry.
	 * @param Entry The added entry.
	 */
	void Internal_OnEntryAdded(int32 Index, const FEquipmentEntry& Entry) const;
	/**
	 * Called when an entry is removed.
	 * @param Index The index of the removed entry.
	 * @param Entry The removed entry.
	 */
	void Internal_OnEntryRemoved(int32 Index, const FEquipmentEntry& Entry) const;

	/** Get the ability system component of the owner. */
	UAbilitySystemComponent* GetAbilitySystemComponent() const;

	/** Array of equipment entries */
	UPROPERTY()
	TArray<FEquipmentEntry> Entries;

	/** Owner component of this equipment list */
	UPROPERTY(NotReplicated)
	TObjectPtr<UEquipmentSystemComponent> OwnerComponent = nullptr;
};

// TStructOpsTypeTraits specialization to enable NetDeltaSerializer for FEquipmentList
template <>
struct TStructOpsTypeTraits<FEquipmentList> : TStructOpsTypeTraitsBase2<FEquipmentList>
{
	enum
	{
		WithNetDeltaSerializer = true
	};
};


############## Public\Data\Slots\DynamicEquipmentSlot.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ActorComponent.h"
#include "CoreMinimal.h"
#include "GameplayTagContainer.h"

#include "DynamicEquipmentSlot.generated.h"

class UEquipmentInstance;
class UItemInstance;

USTRUCT(BlueprintType)
struct FDynamicEquipmentSlot
{
	GENERATED_BODY()

	UPROPERTY()
	FGameplayTag SlotTag;

	UPROPERTY()
	TObjectPtr<UItemInstance> ItemInstance = nullptr;

	UPROPERTY()
	TObjectPtr<UEquipmentInstance> EquipmentInstance = nullptr;
};


############## Public\Data\Slots\EquipmentSlotMapData.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"

#include "EquipmentSlotMapData.generated.h"

struct FSlotDefinition;

/**
 *
 */
UCLASS(BlueprintType, Blueprintable)
class EQUIPMENTSYSTEMCORE_API UEquipmentSlotMapData : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<FSlotDefinition> Slots;

	virtual FPrimaryAssetId GetPrimaryAssetId() const override;
};


############## Public\Data\Slots\SlotDefinition.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "SlotDefinition.generated.h"

class USlotPolicy;
/**
*
*/
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FSlotDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Slot", meta = (Categories = "Equipment.Slot"))
	FGameplayTag SlotTag;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "UI")
	FName UIGroup;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "UI")
	int32 DisplayOrder = 0;
};


############## Public\Definitions\EquipmentDefinition.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Data/EquipmentActorSet.h"
#include "UObject/Object.h"

#include "EquipmentDefinition.generated.h"

class USlotPolicy;
class UEquipmentSystemComponent;
class UEquipmentInstance;
class UAbilitySet;
class UEquipmentFragment;

/**
 * @class UEquipmentDefinition
 * @see UObject
 * @brief Data asset definition of an item that can be equipped by the pawn.
 * And what to do to the pawn on which it is equipped
 */
UCLASS(Blueprintable, Abstract, BlueprintType)
class EQUIPMENTSYSTEMCORE_API UEquipmentDefinition : public UObject
{
	GENERATED_BODY()

	friend struct FEquipmentList;
	friend class UEquipmentSystemComponent;

public:
	UEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
	// ~UObject

	/**
	 * Try to find fragment of class FragmentClass in this equipment definition
	 * @param FragmentClass Class of the EquipmentFragment to search
	 * @return Pointer to the found fragment, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UEquipmentFragment* FindFragmentByClass(TSubclassOf<UEquipmentFragment> FragmentClass) const;

	/**
	 * Template function to find fragment of class T in this equipment definition
	 * @return Pointer to the found fragment of type T, or nullptr if not found
	 */
	template <typename T>
	const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	virtual bool CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent, FGameplayTag& OutFailureReason);

	UFUNCTION(BlueprintNativeEvent, BlueprintPure)
	bool K2_CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent, FGameplayTag& OutFailureReason);

	/**
	 * Get the display name of this equipment
	 * @return Display name as FText
	 */
	FText GetDisplayName() const { return DisplayName; }

protected:
	
	/** Instance class to spawn */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Definition")
	TSubclassOf<UEquipmentInstance> InstanceClass;

	/** Display name of the equipment (used by UI) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Definition")
	FText DisplayName;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Slot")
	FGameplayTag SlotTag;

	UPROPERTY(EditDefaultsOnly, Instanced, BlueprintReadOnly, Category = "Slot")
	TObjectPtr<const USlotPolicy> SlotPolicy;

	/** Actors to spawn on the pawn when this is equipped */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Visual")
	TArray<FEquipmentActorSet> ActorsToSpawn;

	/** Ability sets granted by this equipment */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Gameplay")
	TArray<TObjectPtr<const UAbilitySet>> AbilitySets;

	/** Equipment fragments for additional functionality */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Fragments", Instanced)
	TArray<TObjectPtr<UEquipmentFragment>> Fragments;
};


############## Public\Definitions\Fragments\EquipmentFragment.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "EquipmentFragment.generated.h"

class UEquipmentInstance;

/**
 * @class UEquipmentFragment
 * @see UEquipmentDefinition
 * @brief Represents a fragment of an equipment definition, allow definition extension.
 */
UCLASS(DefaultToInstanced, EditInlineNew, Blueprintable, BlueprintType, Abstract)
class EQUIPMENTSYSTEMCORE_API UEquipmentFragment : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Called when an equipment instance is created.
	 * @param Instance The equipment instance associated with this fragment.
	 */
	virtual void OnInstanceCreated(UEquipmentInstance* Instance) const;
};


############## Public\Definitions\Fragments\ItemFragment_Equippable.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Definitions/Fragments/ItemFragment.h"
#include "ItemFragment_Equippable.generated.h"

class UEquipmentSystemComponent;
class UEquipmentDefinition;

/**
 *
 */
UCLASS(DisplayName = "Equipable")
class EQUIPMENTSYSTEMCORE_API UItemFragment_Equippable : public UItemFragment
{
	GENERATED_BODY()

public:
	/**
	 * Called when an item instance is created. This method initializes any equipable-specific functionality for the item instance.
	 * @param Instance The item instance associated with this fragment.
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance) override;

	/**
	 * The equipment definition associated with this fragment.
	 * @note This defines the properties and behavior of the equipped item.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipable")
	TSubclassOf<UEquipmentDefinition> EquipmentDefinition;
};


############## Public\GameplayTags\EquipmentGameplayTags.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "NativeGameplayTags.h"

namespace EquipmentSystemGameplayTags
{
	EQUIPMENTSYSTEMCORE_API FGameplayTag FindTagByString(const FString& TagString, bool bMatchPartialString = false);

	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Slot);

	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_NullItem);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_MissingDefinition);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_SlotNotFound);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_SlotEmpty);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_SlotBlocked);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_PolicyRefused);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_NotAuthority);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_DefinitionRefused);
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Failure_Internal);

	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Event_CollisionHit);
	
}


############## Public\Instances\EquipmentInstance.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/EquipmentComponent.h"
#include "Data/EquipmentActorSet.h"
#include "Definitions/EquipmentDefinition.h"
#include "Engine/World.h"

#include "EquipmentInstance.generated.h"

class UEquipmentFragment;
/**
 * @class UEquipmentInstance
 * @see UObject
 * @brief Represents an instance of equipment that can be equipped by a pawn.
 */
UCLASS(BlueprintType, Blueprintable)
class EQUIPMENTSYSTEMCORE_API UEquipmentInstance : public UObject
{
	GENERATED_BODY()

	friend struct FEquipmentList;
	friend class UEquipmentSlotComponent;

public:
	UEquipmentInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual bool IsSupportedForNetworking() const override { return true; }
	virtual UWorld* GetWorld() const override final;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// ~UObject

	/** Get the pawn that this equipment instance is attached to. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	APawn* GetPawn() const;
	/** Get the pawn that this equipment instance is attached to, if applicable. */
	UFUNCTION(BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = PawnType))
	APawn* GetTypedPawn(const TSubclassOf<APawn>& PawnType) const;
	/** Get the pawn that this equipment instance is attached to, if applicable. */
	template <class T>
	T* GetPawn() const { return Cast<T>(GetPawn()); }

	/**
	 *	Add a new component object of class ComponentClass to this EquipmentInstance
	 *	@param ComponentClass Class of the EquipmentComponent to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	UEquipmentComponent* AddComponent(TSubclassOf<UEquipmentComponent> ComponentClass);
	/**
	 *	Add a new component object of class ComponentClass to this EquipmentInstance
	 */
	template <typename T>
	T* AddComponent() { return Cast<T>(AddComponent(T::StaticClass())); }

	/**
	 *	Try to find component of class ComponentClass of this equipment instance
	 *	@param ComponentClass Class of the Equipment Instance's component to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = ComponentClass))
	const UEquipmentComponent* FindComponentByClass(TSubclassOf<UEquipmentComponent> ComponentClass) const;
	/**
	 *	Try to find fragment of class ComponentClass of this equipment instance
	 */
	template <typename T>
	const T* FindComponentByClass() const { return Cast<T*>(FindComponentByClass(T::StaticClass())); }

	/** Get the instigator object that caused this equipment instance to be equipped. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	UObject* GetInstigator() const;
	/** Set the instigator object for this equipment instance. */
	void SetInstigator(UObject* InInstigator);

	/** Get the source object that caused this equipment instance to be equipped.  (ItemInstance class)*/
	UFUNCTION(BlueprintPure, Category = "Equipment")
	UItemInstance* GetSourceItem() const;

	/**
	 * Gets the equipment definition class associated with this instance.
	 * @return The equipment definition class.
	 */
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UEquipmentDefinition> GetDefinitionClass() const;

	/**
	 * Gets the equipment definition associated with this instance, cached by the Equipment System Component.
	 * @return The equipment definition default object.
	 */
	UFUNCTION(BlueprintCallable)
	UEquipmentDefinition* GetDefinition() const;

	/**
	 * Spawn actors defined in the given array and attach them to the pawn.
	 * @param ActorsToSpawn Array of actor sets defining which actors to spawn and how to attach them. */
	virtual void SpawnActors(const TArray<FEquipmentActorSet>& ActorsToSpawn);
	/** Destroy all actors spawned by this equipment instance. */
	virtual void DestroyActors();
	/** Get an array of actors spawned by this equipment instance. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	TArray<AActor*> GetSpawnedActors() const { return SpawnedActors; }

	/** Called the equipment instance is equipped. */
	virtual void OnEquipped();
	/** Called the equipment instance is unequipped. */
	virtual void OnUnequipped();

	/** Called the equipment instance is spawned. */
	virtual void OnSpawned();

protected:
	/** Set the source object for this equipment instance. (ItemInstance class)*/
	void SetSourceItem(UItemInstance* InSourceObject);

	/**
	 * Sets the item definition class for this instance.
	 * @param InDefinition - The item definition to set.
	 */
	void SetDefinition(UEquipmentDefinition* InDefinition);

	/** Blueprint event called when this equipment instance is equipped. */
	UFUNCTION(BlueprintImplementableEvent, Category = "Equipment", meta = (DisplayName = "OnEquipped"))
	void K2_OnEquipped();

	/** Blueprint event called when this equipment instance is unequipped. */
	UFUNCTION(BlueprintImplementableEvent, Category = "Equipment", meta = (DisplayName = "OnUnequipped"))
	void K2_OnUnequipped();

	UFUNCTION()
	virtual void OnRep_Instigator();

	UPROPERTY(Replicated)
	TArray<AActor*> SpawnedActors;

	/** The Equipment definition that this instance is based on.
	 * Only replicate the class.
	 */
	UPROPERTY(Replicated)
	TSubclassOf<UEquipmentDefinition> DefinitionClass;

	/** The Equipment Definition default object, cached by the local EquipmentSystemComponent cache */
	UPROPERTY()
	TObjectPtr<UEquipmentDefinition> Definition;

	UPROPERTY()
	TObjectPtr<UItemInstance> SourceItem;

	/** Array of components attached to this item instance. */
	UPROPERTY(Replicated)
	TArray<UEquipmentComponent*> Components;

	UPROPERTY(Replicated, ReplicatedUsing = OnRep_Instigator)
	TObjectPtr<UObject> Instigator;
};


############## Public\Instances\Components\EquipmentComponent.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "EquipmentComponent.generated.h"

class UEquipmentInstance;
/**
 * @class UEquipmentComponent
 * @see UObject
 * @brief Base class for modular components that can be added to equipment instances.
 *
 * This class serves as the foundation for creating specialized components
 * that add specific functionalities to item instances. It allows for a flexible
 * and extensible equipment system.
 */
UCLASS(Abstract)
class EQUIPMENTSYSTEMCORE_API UEquipmentComponent : public UObject
{
	GENERATED_BODY()

public:
	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override
	{
		Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	};
	// ~UObject

	virtual void Initialize(UEquipmentInstance* InInstance);

	/** Returns the owning equipment instance of the component. */
	UFUNCTION(BlueprintCallable, BlueprintPure)
	UEquipmentInstance* GetOwningInstance();

	UPROPERTY(Transient, Replicated)
	TObjectPtr<UEquipmentInstance> OwningInstance = nullptr;
};


############## Public\Interfaces\EquipmentSystemInterface.h ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "EquipmentSystemInterface.generated.h"

class UEquipmentSystemComponent;

/**
 * @class UEquipmentSystemInterface
 * @see IEquipmentSystemInterface
 * @brief Interface class for the Unreal Engine's interface system
 * @details This is the UObject interface declaration required by Unreal Engine.
 * Do not modify this class as it's only used for UObject system registration.
 */
UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UEquipmentSystemInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * @class IEquipmentSystemInterface
 * @see UEquipmentSystemComponent
 * @brief Interface providing access to an actor's equipment system component
 * @details This interface should be implemented by actors that need to expose
 * their equipment system functionality. The component can be owned by the implementing
 * actor or by another actor (e.g., PlayerState owning equipment for its Pawn).
 */
class EQUIPMENTSYSTEMCORE_API IEquipmentSystemInterface
{
	GENERATED_BODY()

public:
	/**
	 * Retrieves the equipment system component associated with this actor
	 * @return The equipment system component to use. May be located on another actor
	 */
	UFUNCTION(BlueprintCallable, Category = "Equipment")
	virtual UEquipmentSystemComponent* GetEquipmentSystemComponent() const = 0;
};


############## Public\Log\EquipmentSystemLog.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogEquipmentSystem, Log, All);


############## Public\Policies\SlotPolicy.h ###############
﻿// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "UObject/Object.h"
#include "SlotPolicy.generated.h"

class UItemInstance;
/**
 * USlotPolicy
 * 
 * Equipment slot policy, business validation rule.
 */
UCLASS(Abstract, Blueprintable, EditInlineNew, DefaultToInstanced)
class EQUIPMENTSYSTEMCORE_API USlotPolicy : public UObject
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintNativeEvent, Category = "Policy")
	bool DoesBlockTag(const FGameplayTag& TargetSlot, const UItemInstance* Item = nullptr, const UObject* Context = nullptr) const;

	virtual bool CanEquipItem(const UItemInstance* Item, const FGameplayTag& TargetSlot, const UObject* Context) const;

	UFUNCTION(BlueprintImplementableEvent, Category = "Policy")
	bool K2_CanEquipItem(const UItemInstance* Item, const FGameplayTag& TargetSlot, const UObject* Context) const;

	UFUNCTION(BlueprintCallable, Category = "Policy")
	const FGameplayTagContainer& GetBlockedSlotTags() const;

	void GetBlockedSlotTags(FGameplayTagContainer& TagContainer) const;

public:
	
	UPROPERTY(EditDefaultsOnly, Category="Policy")
	bool bBlocksAllOtherSlots = false;

	UPROPERTY(EditDefaultsOnly, Category="Policy", Meta = (Categories = "Equipment.Slot"))
	FGameplayTagContainer BlockedSlotTags;
};


############## Public\Settings\EquipmentSystemSettings.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "Engine/DeveloperSettingsBackedByCVars.h"
#include "EquipmentSystemSettings.generated.h"

struct FGameplayTag;

#define GET_EQUIPMENT_SETTINGS_VAR(a) (GetDefault<UEquipmentSystemSettings>()->a)

namespace EquipmentSystemVariables
{
	static bool bDrawWeaponColliders = true;
	inline FAutoConsoleVariableRef CVarDrawWeaponColliders{
		TEXT("Gameplay.Collision.DrawWeaponColliders"),
		bDrawWeaponColliders,
		TEXT("True to enable weapon colliders drawing (default = false).")};

	
	static float SweepTraceTickRate = 1.0f / 30.0f;
	inline FAutoConsoleVariableRef CVarSweepTraceTickRate{
		TEXT("Gameplay.Collision.SweepTraceTickRate"),
		SweepTraceTickRate,
		TEXT("Tick rate of the sweep trace collision test (default = 1/30 sec).")};

	
	static bool bDrawSweepTraces = true;
	inline FAutoConsoleVariableRef CVarDrawSweepTraces{
		TEXT("Gameplay.Collision.DrawSweepTraces"),
		bDrawSweepTraces,
		TEXT("True to enable sweep shape trace drawing (default = false).")};
	
	static float SweepTracesDuration = 1.0f;
	inline FAutoConsoleVariableRef CVarDrawSweepTracesDuration{
		TEXT("Gameplay.Collision.SweepTracesDuration"),
		SweepTracesDuration,
		TEXT("Lifetime of the sweep shape trace drawing (default = 1.0 sec).")};
	
	static float SweepTracesLineThickness = 0.2f;
	inline FAutoConsoleVariableRef CVarSweepTracesLineThickness{
		TEXT("Gameplay.Collision.SweepTracesLineThickness"),
		SweepTracesLineThickness,
		TEXT("Collision debug trace line thickness (default = 0.2).")};

	
	static bool bDrawSweepTracesHitNormals = true;
	inline FAutoConsoleVariableRef CVarDrawSweepTracesHitNormals{
		TEXT("Gameplay.Collision.DrawSweepTracesHitNormals"),
		bDrawSweepTraces,
		TEXT("True to enable sweep hit normals trace drawing (default = false).")};
	
	static float SweepTracesHitNormalsDuration = 1.0f;
	inline FAutoConsoleVariableRef CVarSweepTracesHitNormalsDuration{
		TEXT("Gameplay.Collision.SweepTracesHitNormalsDuration"),
		SweepTracesHitNormalsDuration,
		TEXT("Lifetime of the weapon sweep hit trace drawing (default = 1.0 sec).")};
	
	
} // namespace EquipmentSystemVariables


/**
 *
 */
UCLASS(Config = "Game", defaultConfig, meta = (DisplayName = "Equipment System Settings"))
class EQUIPMENTSYSTEMCORE_API UEquipmentSystemSettings : public UDeveloperSettingsBackedByCVars
{
	GENERATED_BODY()

public:
	// UDeveloperSettings
	virtual void PostInitProperties() override;
	virtual FName GetContainerName() const override;
	virtual FName GetCategoryName() const override;
	// ~UDeveloperSettings

	/** Accessor and initializer */
	UFUNCTION(BlueprintPure, Category = "Settings", meta=(DisplayName="Get Equipment System Settings"))
	static UEquipmentSystemSettings* GetEquipmentSystemSettings();

	
public:
	
	UPROPERTY(Config, EditDefaultsOnly, BlueprintReadOnly, Category = "Weapons|Sweep Collision", meta = (DisplayName = "Weapon sweep channel"))
	TEnumAsByte<ECollisionChannel> SweepChannel = ECC_PhysicsBody;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.DrawWeaponColliders"))
	bool bDrawWeaponColliders = true;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.SweepTraceTickRate"))
	float SweepTraceTickRate = 1.0f / 30.0f;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.DrawSweepTraces"))
	bool bDrawSweepTraces = true;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.SweepTracesDuration"))
	float SweepTracesDuration = 1.0f;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.SweepTracesLineThickness"))
	float SweepTracesLineThickness = 0.2f;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display")
	FColor SweepTracesColor = FColor::Red;
	

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.DrawSweepTracesHitNormals"))
	bool bDrawSweepTracesHitNormals = true;

	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display", meta = (ConsoleVariable = "Gameplay.Collision.SweepTracesHitNormalsDuration"))
	float SweepTracesHitNormalsDuration = 1.0f;
	
	UPROPERTY(Config, EditAnywhere, Category = "Weapons|Debug display")
	FColor SweepTracesHitNormalsColor = FColor::Green;
	
private:
	// UObject
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
	// ~UObject
	
	
};


############## Public\Stats\EquipmentSystemStats.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Stats/Stats.h"

DECLARE_STATS_GROUP(TEXT("EquipmentSystem"), STATGROUP_EquipmentSystem, STATCAT_Advanced);

DECLARE_CYCLE_STAT_EXTERN(TEXT("Equipment - Internal_ProcessEquip"), STAT_Equipment_ProcessEquip, STATGROUP_EquipmentSystem,);
DECLARE_CYCLE_STAT_EXTERN(TEXT("Equipment - Internal_ProcessUnequip"), STAT_Equipment_ProcessUnequip, STATGROUP_EquipmentSystem,);
DECLARE_CYCLE_STAT_EXTERN(TEXT("Equipment - Internal_EquipOnSlot"), STAT_Equipment_EquipOnSlot, STATGROUP_EquipmentSystem,);

