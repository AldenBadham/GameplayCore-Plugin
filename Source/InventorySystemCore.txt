
############## Private\InventorySystemCore.cpp ###############
﻿#include "InventorySystemCore.h"

#define LOCTEXT_NAMESPACE "FInventorySystemCoreModule"

void FInventorySystemCoreModule::StartupModule()
{
}

void FInventorySystemCoreModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FInventorySystemCoreModule, InventorySystemCore)


############## Private\Components\InventorySystemComponent.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/InventorySystemComponent.h"

#include "GameplayTagContainer.h"
#include "Containers/InventoryContainer.h"
#include "Data/InventoryCache.h"
#include "Data/InventoryEntry.h"
#include "Data/InventorySet.h"
#include "Engine/ActorChannel.h"
#include "GameplayTags/InventoryGameplayTags.h"
#include "Instances/ItemInstance.h"

UInventorySystemComponent::UInventorySystemComponent(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get())
{
	PrimaryComponentTick.bCanEverTick = false;
	bWantsInitializeComponent = true;

	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
}

void UInventorySystemComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
}

bool UInventorySystemComponent::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)
{
	bool bReplicated = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (const auto& [Tag, Container] : Containers)
	{
		if (IsValid(Container))
		{
			bReplicated |= Channel->ReplicateSubobject(Container, *Bunch, *RepFlags);
			bReplicated |= Container->ReplicateSubobjects(Channel, Bunch, RepFlags);
		}
	}

	return bReplicated;
}

void UInventorySystemComponent::ReadyForReplication()
{
	Super::ReadyForReplication();

	// Register all item instances ready for replication with the actor component
	if (IsUsingRegisteredSubObjectList())
	{
		for (const auto& [Tag, Container] : Containers)
		{
			if (IsValid(Container))
			{
				AddReplicatedSubObject(Container);

				FInventoryList& InventoryList = Container->GetInventoryList();
				for (const FInventoryEntry& Entry : InventoryList.Entries)
				{
					if (UItemInstance* Instance = Entry.Instance; IsValid(Instance))
					{
						AddReplicatedSubObject(Instance);
					}
				}
			}
		}
	}
}

void UInventorySystemComponent::InitializeComponent()
{
	Super::InitializeComponent();

	// Cache initialization
	Cache = NewObject<UInventoryCache>(this);

	if (IsValid(DefaultContainerClass) && !Containers.Contains(DefaultContainerTag) && IsValidContainerTag(DefaultContainerTag))
	{
		UInventoryContainer* DefaultContainer = NewObject<UInventoryContainer>(this, DefaultContainerClass);
		RegisterContainer(DefaultContainerTag, DefaultContainer);
	}

	if (IsValid(DefaultInventorySet))
	{
		DefaultInventorySet->GiveToInventorySystem(this);
	}
}

void UInventorySystemComponent::UninitializeComponent()
{
	Super::UninitializeComponent();
}

FInventoryResult UInventorySystemComponent::TryAddItemDefinitionIn(const FGameplayTag& ContainerTag, const TSubclassOf<UItemDefinition> ItemDefinition, const int32 Count)
{
	if (UInventoryContainer* Container = GetContainer(ContainerTag))
	{
		FInventoryResult Result = Container->TryAddItemDefinition(ItemDefinition, Count);
		if (Result.Succeeded() && IsUsingRegisteredSubObjectList() && IsReadyForReplication())
		{
			for (UItemInstance* Instance : Result.Instances)
			{
				if (!IsReplicatedSubObjectRegistered(Instance))
				{
					AddReplicatedSubObject(Instance);
				}
			}
		}
		return Result;
	}
	return {{}, InventorySystemGameplayTags::TAG_Inventory_Failure_ContainerNotFound};
}

FInventoryResult UInventorySystemComponent::TryAddItemInstanceIn(const FGameplayTag& ContainerTag, UItemInstance* ItemInstance, const int32 StackCount)
{
	if (UInventoryContainer* Container = GetContainer(ContainerTag))
	{
		FInventoryResult Result = Container->TryAddItemInstance(ItemInstance, StackCount);
		if (Result.Succeeded() && IsUsingRegisteredSubObjectList() && IsReadyForReplication())
		{
			for (UItemInstance* Instance : Result.Instances)
			{
				if (!IsReplicatedSubObjectRegistered(Instance))
				{
					AddReplicatedSubObject(Instance);
				}
			}
		}
		return Result;
	}
	return {{}, InventorySystemGameplayTags::TAG_Inventory_Failure_ContainerNotFound};
}

FInventoryResult UInventorySystemComponent::TryAddItemDefinition(const TSubclassOf<UItemDefinition>& ItemDefinition, const int32 Count)
{
	return TryAddItemDefinitionIn(DefaultContainerTag, ItemDefinition, Count);
}

FInventoryResult UInventorySystemComponent::TryAddItemInstance(UItemInstance* ItemInstance, const int32 StackCount)
{
	return TryAddItemInstanceIn(DefaultContainerTag, ItemInstance, StackCount);
}

bool UInventorySystemComponent::TryRemoveFromHandle(FInventoryEntryHandle Handle, FGameplayTag& OutFailureReason)
{
	if (!Handle.IsHandleValid() || !IsValid(Handle.Container))
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle;
		return false;
	}

	const bool Succeed = Handle.Container->TryRemoveItem(Handle, OutFailureReason);
	if (Succeed && IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		RemoveReplicatedSubObject(Handle.ItemInstance);
	}
	return Succeed;
}

FInventoryResult UInventorySystemComponent::TryMoveByHandle(const FInventoryEntryHandle Handle, UInventoryContainer* TargetContainer)
{
	if (!Handle.IsHandleValid() || !IsValid(Handle.Container) || !IsValid(TargetContainer))
	{
		return {{}, InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle};
	}
	return Handle.Container->TryMoveItemTo(Handle, TargetContainer);
}

void UInventorySystemComponent::Empty()
{
	if (!IsUsingRegisteredSubObjectList())
	{
		return;
	}

	TArray<FInventoryEntryHandle> Handles;
	for (const auto& Pair : Containers)
	{
		if (UInventoryContainer* Container = Pair.Value)
		{
			FInventoryList& InventoryList = Container->GetInventoryList();
			for (const FInventoryEntry& Entry : InventoryList.Entries)
			{
				if (UItemInstance* Instance = Entry.Instance; IsValid(Instance))
				{
					RemoveReplicatedSubObject(Instance);
				}
			}
			Container->GetInventoryList().Entries.Empty();
		}
	}
}

FInventoryEntryHandle UInventorySystemComponent::FindHandleFromInstanceIn(const FGameplayTag& ContainerTag, UItemInstance* Instance) const
{
	for (const auto& Pair : Containers)
	{
		if (const UInventoryContainer* Container = Pair.Value)
		{
			FInventoryEntryHandle Handle = Container->FindHandle(Instance);
			if (Handle.IsHandleValid())
			{
				return Handle;
			}
		}
	}
	return FInventoryEntryHandle();
}

FInventoryEntryHandle UInventorySystemComponent::FindHandleFromInstance(UItemInstance* Instance) const
{
	return FindHandleFromInstanceIn(InventorySystemGameplayTags::TAG_Inventory_Container, Instance);
}

TArray<FInventoryEntryHandle> UInventorySystemComponent::GetAllStacks() const
{
	TArray<FInventoryEntryHandle> Handles;
	for (const auto& Pair : Containers)
	{
		if (UInventoryContainer* Container = Pair.Value)
		{
			Handles.Append(Container->GetInventoryList().GetAllHandles());
		}
	}
	return Handles;
}

int32 UInventorySystemComponent::GetStackCountByDefinitionIn(const TSubclassOf<UItemDefinition> DefinitionClass, const FGameplayTag& ContainerTag) const
{
	int32 Count = 0;
	if (const UInventoryContainer* Container = GetContainer(ContainerTag); IsValid(Container))
	{
		Count += Container->GetStackCountByDefinition(DefinitionClass);
	}
	return Count;
}

int32 UInventorySystemComponent::GetTotalCountByDefinitionIn(const TSubclassOf<UItemDefinition> DefinitionClass, const FGameplayTag& ContainerTag) const
{
	int32 Count = 0;
	if (const UInventoryContainer* Container = GetContainer(ContainerTag); IsValid(Container))
	{
		Count += Container->GetTotalCountByDefinition(DefinitionClass);
	}
	return Count;
}

int32 UInventorySystemComponent::GetStackCountByDefinition(const TSubclassOf<UItemDefinition> DefinitionClass) const
{
	int32 Count = 0;
	for (const auto& Pair : Containers)
	{
		Count += GetStackCountByDefinitionIn(DefinitionClass, Pair.Key);
	}
	return Count;
}

int32 UInventorySystemComponent::GetTotalCountByDefinition(const TSubclassOf<UItemDefinition> DefinitionClass) const
{
	int32 Count = 0;
	for (const auto& Pair : Containers)
	{
		Count += GetTotalCountByDefinitionIn(DefinitionClass, Pair.Key);
	}
	return Count;
}

bool UInventorySystemComponent::RegisterContainer(const FGameplayTag& Tag, UInventoryContainer* Container)
{
	if (!IsValid(Container) || !Tag.IsValid() || !IsValidContainerTag(Tag))
	{
		return false;
	}
	Container->SetOwnerComponent(this);

	Containers.Add(Tag, Container);
	if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		if (!IsReplicatedSubObjectRegistered(Container))
		{
			AddReplicatedSubObject(Container);
		}
	}
	return true;
}

bool UInventorySystemComponent::UnregisterContainer(const FGameplayTag& Tag)
{
	if (!Tag.IsValid() || !Containers.Contains(Tag))
	{
		return false;
	}

	if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		if (UInventoryContainer* Container = Containers.FindRef(Tag))
		{
			RemoveReplicatedSubObject(Container);
		}
	}
	Containers.Remove(Tag);
	return true;
}

UInventoryContainer* UInventorySystemComponent::GetContainer(const FGameplayTag& ContainerTag) const
{
	if (const TObjectPtr<UInventoryContainer>* Container = Containers.Find(ContainerTag))
	{
		return *Container;
	}
	return nullptr;
}

TMap<FGameplayTag, UInventoryContainer*> UInventorySystemComponent::GetAllContainers() const
{
	TMap<FGameplayTag, UInventoryContainer*> Out;
	for (const auto& Pair : Containers)
	{
		Out.Add(Pair.Key, Pair.Value);
	}
	return Out;
}


UItemDefinition* UInventorySystemComponent::GetCachedDefinition(const TSubclassOf<UItemDefinition>& Class) const
{
	if (IsValid(Cache))
	{
		return Cache->GetCachedDefinition(Class);
	}
	if (IsValid(Class))
	{
		return NewObject<UItemDefinition>(GetOuter(), Class);
	}
	return nullptr;
}

bool UInventorySystemComponent::IsValidContainerTag(const FGameplayTag& Tag)
{
	return Tag.MatchesTag(InventorySystemGameplayTags::TAG_Inventory_Container);
}

void UInventorySystemComponent::PostInventoryEntryAdded(const FInventoryChangeData& Data)
{
	OnInventoryEntryAdded.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryEntryRemoved(const FInventoryChangeData& Data)
{
	OnInventoryEntryRemoved.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryEntryChanged(const FInventoryChangeData& Data)
{
	OnInventoryEntryChanged.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryChanged(const FInventoryChangeData& Data)
{
	OnInventoryChanged.Broadcast(Data);
}


############## Private\Containers\InventoryContainer.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.


#include "Containers/InventoryContainer.h"

#include "Containers/Policies/StoragePolicy.h"
#include "Definitions/ItemDefinition.h"
#include "Engine/ActorChannel.h"
#include "GameplayTags/InventoryGameplayTags.h"
#include "Instances/ItemInstance.h"
#include "Net/UnrealNetwork.h"

UInventoryContainer::UInventoryContainer(const FObjectInitializer& ObjectInitializer)
{
	InventoryList.SetOwningContainer(this);
}

void UInventoryContainer::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(UInventoryContainer, InventoryList);
}

bool UInventoryContainer::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)
{
	bool bReplicated = true;
	for (FInventoryEntry& Entry : InventoryList.Entries)
	{
		if (UItemInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			bReplicated |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}
	return bReplicated;
}

FInventoryResult UInventoryContainer::TryAddItemDefinition(const TSubclassOf<UItemDefinition> Definition, const int32 Count)
{
	FInventoryResult Result;
	if (!IsValid(Definition))
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidDefinition;
		return Result;
	}
	if (Count <= 0)
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidCount;
		return Result;
	}

	Result = InventoryList.AddFromDefinition(Definition, Count);
	return Result;
}

FInventoryResult UInventoryContainer::TryAddItemInstance(UItemInstance* Instance, const int32 Count)
{
	FInventoryResult Result;
	if (!IsValid(Instance))
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidInstance;
		return Result;
	}
	if (Count <= 0)
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidCount;
		return Result;
	}
	if (!ValidateStorage(Instance, Result.FailureReason))
	{
		return Result;
	}

	Result = InventoryList.AddInstance(Instance, Count);
	return Result;
}

bool UInventoryContainer::TryRemoveItem(FInventoryEntryHandle& Handle, FGameplayTag& OutFailureReason)
{
	if (!Handle.IsHandleValid())
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidInstance;
		return false;
	}

	if (InventoryList.RemoveFromHandle(Handle, OutFailureReason))
	{
		return true;
	}
	OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle;
	return false;
}

FInventoryResult UInventoryContainer::TryMoveItemTo(FInventoryEntryHandle Handle, UInventoryContainer* TargetContainer)
{
	FInventoryResult Result;

	if (!Handle.IsHandleValid())
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle;
		return Result;
	}
	if (!IsValid(TargetContainer))
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidContainer;
		return Result;
	}

	UItemInstance* Instance = Handle.ItemInstance;
	if (!IsValid(Instance))
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidInstance;
		return Result;
	}

	Result = TargetContainer->TryAddItemInstance(Instance, Handle.StackCount);
	if (!Result.Succeeded())
	{
		return Result;
	}

	if (!TryRemoveItem(Handle, Result.FailureReason))
	{
		return Result;
	}

	return Result;
}

FInventoryEntryHandle UInventoryContainer::FindHandle(UItemInstance* Instance) const
{
	return InventoryList.FindHandleFromInstance(Instance);
}

void UInventoryContainer::SetOwnerComponent(UInventorySystemComponent* NewOwner)
{
	OwnerComponent = NewOwner;
	InventoryList.SetOwningComponent(NewOwner);
}

int32 UInventoryContainer::GetStackCountByDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const
{
	return InventoryList.GetStackCountByDefinition(DefinitionClass);
}

int32 UInventoryContainer::GetTotalCountByDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const
{
	return InventoryList.GetTotalCountByDefinition(DefinitionClass);
}

bool UInventoryContainer::ValidateStorage(UItemInstance* Instance, FGameplayTag& OutFailureReason) const
{
	for (const TObjectPtr<UStoragePolicy>& Policy : Policies)
	{
		if (IsValid(Policy) && !Policy->CanStoreItem(Instance, OutFailureReason))
		{
			return false;
		}
	}

	OutFailureReason = FGameplayTag::EmptyTag;
	return true;
}

void UInventoryContainer::AddStoragePolicy(UStoragePolicy* Policy)
{
	if (IsValid(Policy))
	{
		Policies.Add(Policy);
	}
}


############## Private\Containers\Policies\StoragePolicy.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.


#include "Containers/Policies/StoragePolicy.h"

bool UStoragePolicy::CanStoreItem_Implementation(UItemInstance* Instance, FGameplayTag& OutFailureReason) const
{
	return true;
}


############## Private\Containers\Policies\StoragePolicy_TagRequirement.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.


#include "Containers/Policies/StoragePolicy_TagRequirement.h"

#include "Instances/ItemInstance.h"

bool UStoragePolicy_TagRequirement::CanStoreItem_Implementation(UItemInstance* Instance, FGameplayTag& OutFailureReason) const
{
	if (!Super::CanStoreItem_Implementation(Instance, OutFailureReason))
	{
		return false;
	}

	FGameplayTagContainer TagContainer;
	Instance->GetOwnedGameplayTags(TagContainer);

	if (bExactMatch && TagContainer.HasAllExact(RequiredTags) && !TagContainer.HasAnyExact(ForbiddenTags))
	{
		return true;
	}
	if (!bExactMatch && TagContainer.HasAny(RequiredTags) && !TagContainer.HasAny(ForbiddenTags))
	{
		return true;
	}

	return false;
}


############## Private\Data\InventoryCache.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryCache.h"

#include "Definitions/ItemDefinition.h"

UInventoryCache::UInventoryCache()
{
	// Register the cache for cleanup after garbage collection
	FCoreUObjectDelegates::GetPostGarbageCollect().AddUObject(this, &UInventoryCache::Clear);
}

UInventoryCache::~UInventoryCache()
{
	// Unregister from the garbage collection delegate
	FCoreUObjectDelegates::GetPostGarbageCollect().RemoveAll(this);
}

UItemDefinition* UInventoryCache::GetCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass)
{
	if (!IsValid(ItemDefinitionClass))
	{
		return nullptr;
	}

	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);

	if (const TWeakObjectPtr<UItemDefinition>* FoundDefinition = CachedDefinitionMap.Find(ItemDefinitionClass))
	{
		if (UItemDefinition* Definition = FoundDefinition->Get(); IsValid(Definition))
		{
			return Definition;
		}
	}

	// If the definition is not cached, create a new instance
	UItemDefinition* NewDefinition = NewObject<UItemDefinition>(this, ItemDefinitionClass);
	CachedDefinitionMap.Add(ItemDefinitionClass, NewDefinition);

	return NewDefinition;
}

bool UInventoryCache::IsCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const
{
	return CachedDefinitionMap.Contains(ItemDefinitionClass);
}

void UInventoryCache::Clear()
{
	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);

	for (auto& Pair : CachedDefinitionMap)
	{
		if (Pair.Value != nullptr && !Pair.Value->IsRooted())
		{
			CachedDefinitionMap.Remove(Pair.Key);
		}
	}
}


############## Private\Data\InventoryChangeData.cpp ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryChangeData.h"

#include "Data/InventoryEntry.h"

FInventoryChangeData::FInventoryChangeData(const int32 InIndex, const FInventoryEntry& Entry, const EInventoryChangeType InChangeType)
{
	Index = InIndex;
	Instance = Entry.Instance;
	OldCount = Entry.LastStackCount;
	NewCount = Entry.StackCount;
	ChangeType = InChangeType;
}


############## Private\Data\InventoryEntry.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryEntry.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventoryList.h"
#include "Instances/ItemInstance.h"
#include "Log/InventorySystemLog.h"

void FInventoryEntry::PreReplicatedRemove(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwningContainer)
	{
		UE_LOG(LogInventorySystem, Verbose, TEXT("%s: OnRemoveEntry (Non-Auth): %s. Count: %d"), *GetNameSafe(InArraySerializer.OwningComponent->GetOwner()), *GetNameSafe(Instance), StackCount);
	}
}

void FInventoryEntry::PostReplicatedAdd(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwningContainer)
	{
		UE_LOG(LogInventorySystem, Verbose, TEXT("%s: OnAddedEntry (Non-Auth): %s. Count: %d"), *GetNameSafe(InArraySerializer.OwningComponent->GetOwner()), *GetNameSafe(Instance), StackCount);
	}
}

void FInventoryEntry::PostReplicatedChange(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwningContainer)
	{
		UE_LOG(LogInventorySystem, Verbose, TEXT("%s: OnAddedChanged (Non-Auth): %s. Count: %d   LastCount: %d"), *GetNameSafe(InArraySerializer.OwningComponent->GetOwner()), *GetNameSafe(Instance), StackCount, LastStackCount);
	}
}

FString FInventoryEntry::GetDebugString() const
{
	return FString::Printf(TEXT("(%s)"), *GetNameSafe(Instance));
}


############## Private\Data\InventoryEntryHandle.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Data/InventoryEntryHandle.h"

#include "Containers/InventoryContainer.h"

bool FInventoryEntryHandle::IsHandleValid() const
{
	return EntryIndex != INDEX_NONE && IsValid(Container);
}


############## Private\Data\InventoryList.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryList.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventoryEntry.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "Definitions/Fragments/ItemFragment_Storable.h"
#include "GameplayTags/InventoryGameplayTags.h"
#include "Instances/ItemInstance.h"
#include "Log/InventorySystemLog.h"

FInventoryList::FInventoryList()
{
}

FInventoryList::FInventoryList(UInventorySystemComponent* InOwnerComponent)
	: OwningComponent(InOwnerComponent)
{
}

void FInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (const int32 Index : RemovedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			Entry.LastStackCount = 0;

			Internal_OnEntryRemoved(Index, Entry);
		}
	}
}

void FInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (const int32 Index : AddedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			Entry.LastStackCount = Entry.StackCount;

			Internal_OnEntryAdded(Index, Entry);
		}
	}
}

void FInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (const int32 Index : ChangedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			ensureMsgf(Entry.LastStackCount != INDEX_NONE, TEXT("LastStackCount is invalid (INDEX_NONE) for entry at index %d. Should replicate this change" ), Index);

			Internal_OnEntryChanged(Index, Entry);
			Entry.LastStackCount = Entry.StackCount;
		}
	}
}

FInventoryResult FInventoryList::AddFromDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass, const int32 Count)
{
	FInventoryResult Result;

	if (!IsValid(DefinitionClass) || !OwningComponent)
	{
		UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate an item instance from invalid definition class."));
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidDefinition;
		return Result;
	}

	if (const AActor* OwnerActor = OwningComponent->GetOwner(); !OwnerActor->HasAuthority())
	{
		UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate an item instance from invalid definition class."));
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_NotAuthority;
		return Result;
	}

	// Check validity of the definition instance, and storable fragments
	if (!CanAdd(DefinitionClass, Result.FailureReason, Count))
	{
		return Result;
	}

	int32 RemainingCount = Count;

	const UItemDefinition* CachedDefinition = OwningComponent->GetCachedDefinition(DefinitionClass);
	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();

	// Handles stacking if the object is stackable
	if (StorableFragment->CanStack())
	{
		for (int32 Index = 0; Index < Entries.Num() && RemainingCount > 0; ++Index)
		{
			FInventoryEntry& Entry = Entries[Index];
			if (Entry.Instance->DefinitionClass != DefinitionClass)
			{
				continue;
			}

			const int32 FreeCount = StorableFragment->MaxStackCount - Entry.StackCount;
			const int32 ToAdd = FMath::Min(RemainingCount, FreeCount);

			if (ToAdd > 0)
			{
				Entry.StackCount += ToAdd;
				RemainingCount -= ToAdd;

				Internal_OnEntryChanged(Index, Entry);
				Entry.LastStackCount = Entry.StackCount;
				MarkItemDirty(Entry);

				Result.Instances.Add(Entry.Instance);
			}
		}
	}

	// Calculate the number of new stacks required
	const int32 MaxStackCount = StorableFragment->CanStack() ? StorableFragment->MaxStackCount : 1;
	const int32 NeededStacks = FMath::DivideAndRoundUp(RemainingCount, MaxStackCount);

	// Create new stacks for the rest
	for (int32 i = 0; i < NeededStacks && RemainingCount > 0; ++i)
	{
		if (!CanAdd(DefinitionClass, Result.FailureReason, RemainingCount))
		{
			break;
		}

		int32 CurrentCount = RemainingCount;
		if (UItemInstance* NewInstance = CreateItemInstance(DefinitionClass, CurrentCount))
		{
			Result.Instances.Add(NewInstance);
			RemainingCount = CurrentCount;
		}
	}

	return Result;
}

FInventoryResult FInventoryList::AddInstance(UItemInstance* ItemInstance, const int32 Count)
{
	FInventoryResult Result;

	if (!IsValid(ItemInstance))
	{
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidInstance;
		return Result;
	}

	// Check if the item can be added
	if (const TSubclassOf<UItemDefinition> DefinitionClass = ItemInstance->GetDefinitionClass())
	{
		if (!CanAdd(DefinitionClass, Result.FailureReason, Count))
		{
			return Result;
		}
	}

	// Creating and configuring the new input
	FInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
	const int32 NewIndex = Entries.Num() - 1;

	NewEntry.Instance = ItemInstance;
	NewEntry.StackCount = Count;
	NewEntry.LastStackCount = Count;

	Result.Instances.Add(ItemInstance);

	// Notification du changement
	Internal_OnEntryAdded(NewIndex, NewEntry);
	MarkItemDirty(NewEntry);

	return Result;
}

void FInventoryList::RemoveInstance(UItemInstance* Instance)
{
	for (auto EntryIterator = Entries.CreateIterator(); EntryIterator; ++EntryIterator)
	{
		if (FInventoryEntry Entry = *EntryIterator; Entry.Instance == Instance)
		{
			Internal_OnEntryRemoved(EntryIterator.GetIndex(), Entry);
			EntryIterator.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}

bool FInventoryList::RemoveFromHandle(const FInventoryEntryHandle& Handle, FGameplayTag& OutFailureReason)
{
	if (!Handle.IsHandleValid())
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle;
		return false;
	}

	if (!Entries.IsValidIndex(Handle.EntryIndex))
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidHandle;
		return false;
	}

	const FInventoryEntry& Entry = Entries[Handle.EntryIndex];
	if (Entry.Instance != Handle.ItemInstance)
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_HandleMismatch;
		return false;
	}

	Internal_OnEntryRemoved(Handle.EntryIndex, Entry);
	Entries.RemoveAt(Handle.EntryIndex);
	MarkArrayDirty();

	OutFailureReason = FGameplayTag::EmptyTag;
	return true;
}

bool FInventoryList::RemoveFromIndex(const int32 Index, FGameplayTag& OutFailureReason)
{
	if (!Entries.IsValidIndex(Index))
	{
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidIndex;
		return false;
	}

	Internal_OnEntryRemoved(Index, Entries[Index]);
	Entries.RemoveAt(Index);
	MarkArrayDirty();
	return true;
}

FInventoryEntryHandle FInventoryList::MakeHandle(const int32 Index) const
{
	if (!Entries.IsValidIndex(Index))
	{
		return FInventoryEntryHandle();
	}
	const FInventoryEntry& Entry = Entries[Index];
	return FInventoryEntryHandle(Index, Entry.Instance, Entry.StackCount, OwningContainer);
}

FInventoryEntryHandle FInventoryList::FindHandleFromInstance(UItemInstance* Instance) const
{
	FInventoryEntryHandle Handle;
	if (IsValid(Instance))
	{
		for (int32 Index = 0; Index < Entries.Num(); ++Index)
		{
			if (const FInventoryEntry& Entry = Entries[Index]; Entry.Instance == Instance)
			{
				Handle = FInventoryEntryHandle(Index, Entry);
				break;
			}
		}
	}
	return Handle;
}

FInventoryEntryHandle FInventoryList::FindHandleOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	for (int Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance) && Entry.Instance->GetDefinitionClass() == ItemDefinition)
		{
			return FInventoryEntryHandle(Index, Entry);
		}
	}
	return {};
}

TArray<FInventoryEntryHandle> FInventoryList::GetAllHandles() const
{
	TArray<FInventoryEntryHandle> Handles = {};

	// Pre-reserve memory for the array
	Handles.Reserve(Entries.Num());

	for (int32 Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance))
		{
			FInventoryEntryHandle Handle = FInventoryEntryHandle(Index, Entry);
			Handles.Add(Handle);
		}
	}
	return Handles;
}

TArray<FInventoryEntryHandle> FInventoryList::GetHandlesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	TArray<FInventoryEntryHandle> Handles = {};

	if (!IsValid(ItemDefinition))
	{
		return Handles;
	}

	for (int32 Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance) && Entry.Instance->GetDefinitionClass()->IsInA(ItemDefinition))
		{
			FInventoryEntryHandle Handle = FInventoryEntryHandle(Index, Entry);
			Handles.Add(Handle);
		}
	}
	return Handles;
}

TArray<FInventoryEntry*> FInventoryList::GetAllEntries()
{
	TArray<FInventoryEntry*> InventoryEntries;

	// Pre-reserve memory for the array
	InventoryEntries.Reserve(Entries.Num());

	for (FInventoryEntry& Entry : Entries)
	{
		InventoryEntries.Add(&Entry);
	}
	return InventoryEntries;
}

FInventoryEntry* FInventoryList::FindEntryOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	if (!IsValid(ItemDefinition))
	{
		return nullptr;
	}

	return Entries.FindByPredicate([ItemDefinition](const FInventoryEntry& Entry)
	{
		return Entry.Instance->GetDefinitionClass()->IsInA(ItemDefinition);
	});
}

TArray<FInventoryEntry*> FInventoryList::GetEntriesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	TArray<FInventoryEntry*> InventoryEntries = {};

	if (!IsValid(ItemDefinition))
	{
		return InventoryEntries;
	}

	for (FInventoryEntry& Entry : Entries)
	{
		if (IsValid(Entry.Instance) && Entry.Instance->GetDefinitionClass()->IsInA(ItemDefinition))
		{
			InventoryEntries.Add(&Entry);
		}
	}
	return InventoryEntries;
}

int32 FInventoryList::GetStackCountByDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const
{
	int32 Count = 0;
	for (const FInventoryEntry& Entry : Entries)
	{
		if (Entry.Instance && Entry.Instance->GetDefinitionClass() == ItemDefinitionClass)
		{
			++Count;
		}
	}
	return Count;
}

int32 FInventoryList::GetTotalCountByDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const
{
	int32 Total = 0;
	for (const FInventoryEntry& Entry : Entries)
	{
		if (Entry.Instance && Entry.Instance->GetDefinitionClass() == ItemDefinitionClass)
		{
			Total += Entry.StackCount;
		}
	}
	return Total;
}

void FInventoryList::SetOwningComponent(UInventorySystemComponent* Component)
{
	OwningComponent = Component;
}

void FInventoryList::SetOwningContainer(UInventoryContainer* Container)
{
	OwningContainer = Container;
}

UItemInstance* FInventoryList::CreateItemInstance(const TSubclassOf<UItemDefinition>& DefinitionClass, int32& Count)
{
	AActor* OwnerActor = OwningComponent->GetOwner();
	if (!OwnerActor->HasAuthority())
	{
		return nullptr;
	}

	// Get item definition instance
	UItemDefinition* CachedDefinition = OwningComponent->GetCachedDefinition(DefinitionClass);
	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();
	if (!IsValid(StorableFragment))
	{
		return nullptr;
	}

	// Create a new entry
	FInventoryEntry& Entry = Entries.AddDefaulted_GetRef();
	const int32 Index = Entries.Num();

	Entry.Instance = NewObject<UItemInstance>(OwnerActor);
	Entry.Instance->SetDefinition(CachedDefinition);
	Entry.OwningContainer = OwningContainer;
	Entry.StackCount = StorableFragment->CanStack() ? FMath::Min(Count, StorableFragment->MaxStackCount) : 1;
	Count -= Entry.StackCount;

	for (auto Fragment : CachedDefinition->Fragments)
	{
		if (IsValid(Fragment))
		{
			Fragment->OnInstanceCreated(Entry.Instance);
		}
	}

	Internal_OnEntryAdded(Index, Entry);
	MarkItemDirty(Entry);

	return Entry.Instance;
}

bool FInventoryList::CanAdd(const TSubclassOf<UItemDefinition>& DefinitionClass, FGameplayTag& OutFailureReason, const int32 InCount)
{
	UItemDefinition* CachedDefinition = OwningComponent->GetCachedDefinition(DefinitionClass);
	if (!IsValid(CachedDefinition))
	{
		UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate an item instance from invalid definition class."));
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidDefinition;
		return false;
	}

	if (!CachedDefinition->CanBeGiven(OwningComponent, OutFailureReason))
	{
		UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate an item instance from %s, but the definition conditions are not met."), *GetNameSafe(DefinitionClass));
		if (!OutFailureReason.IsValid())
		{
			OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_DefinitionRefused;
		}
		return false;
	}

	// If the object has no storable fragment, it cannot be added to the inventory
	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();
	if (!IsValid(StorableFragment))
	{
		UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate an item instance of %s but do not own UItemFragment_Storable fragment."), *GetNameSafe(CachedDefinition));
		OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_NotStorable;
		return false;
	}

	// Check if the object is unique
	if (StorableFragment->IsUnique())
	{
		if (const FInventoryEntryHandle Handle = FindHandleOfType(DefinitionClass); Handle.IsHandleValid())
		{
			// Allow if we can fit in the existing stack
			if (StorableFragment->CanStack() && StorableFragment->MaxStackCount - Handle.StackCount <= InCount)
			{
				return true;
			}

			UE_LOG(LogInventorySystem, Warning, TEXT("Tried to instantiate a single item instance %s but another instance already exists."), *GetNameSafe(CachedDefinition));
			OutFailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_Uniqueness;
			return false;
		}
	}
	return true;
}

void FInventoryList::Internal_OnEntryChanged(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Modified;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwningComponent->PostInventoryEntryChanged(Data);
	OwningComponent->PostInventoryChanged(Data);
}

void FInventoryList::Internal_OnEntryAdded(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Added;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwningComponent->PostInventoryEntryAdded(Data);
	OwningComponent->PostInventoryChanged(Data);
}

void FInventoryList::Internal_OnEntryRemoved(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Removed;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwningComponent->PostInventoryEntryRemoved(Data);
	OwningComponent->PostInventoryChanged(Data);
}


############## Private\Data\InventorySet.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventorySet.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventorySet_ItemSet.h"
#include "GameplayTags/InventoryGameplayTags.h"
#include "Log/InventorySystemLog.h"

FInventoryResult UInventorySet::GiveToInventorySystem(UInventorySystemComponent* InventorySystemComp)
{
	FInventoryResult Result;

	if (!IsValid(InventorySystemComp))
	{
		UE_LOG(LogInventorySystem, Error, TEXT("Tried to give InventorySet [%s] to an invalid InventorySystemComponent"), *GetFName().ToString());
		Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidComponent;
		return Result;
	}

	for (auto& [ItemDefinition, Quantity] : Items)
	{
		if (!IsValid(ItemDefinition) || Quantity <= 0)
		{
			UE_LOG(LogInventorySystem, Error, TEXT("Tried to give an invalid item [%s] or with a invalid quantity [%d] in the InventorySet [%s]"), *GetNameSafe(ItemDefinition), Quantity, *GetFName().ToString());
			Result.FailureReason = InventorySystemGameplayTags::TAG_Inventory_Failure_InvalidCount;
			continue;
		}

		return InventorySystemComp->TryAddItemDefinitionIn(TargetContainer, ItemDefinition, Quantity);
	}
	return Result;
}


############## Private\Definitions\ItemDefinition.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/ItemDefinition.h"

#include "GameplayTagContainer.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "Framework/Notifications/NotificationManager.h"
#include "Log/InventorySystemLog.h"
#include "Settings/InventorySystemSettings.h"
#include "Settings/ItemFragmentRule.h"
#include "Widgets/Notifications/SNotificationList.h"

UItemDefinition::UItemDefinition(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get())
{
}

void UItemDefinition::PostLoad()
{
	UObject::PostLoad();

#if WITH_EDITORONLY_DATA
	PreviousFragments = Fragments;
#endif
}

#if WITH_EDITOR
void UItemDefinition::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property && PropertyChangedEvent.GetPropertyName() == GET_MEMBER_NAME_CHECKED(UItemDefinition, Fragments))
	{
		// Check Fragment rules from the Inventory System Settings
		const UInventorySystemSettings* InventorySettings = GetDefault<UInventorySystemSettings>();
		ensureMsgf(IsValid(InventorySettings), TEXT("Invalid Inventory System Settings class get."));

		// Identify newly added fragments
		TMap<int32, UItemFragment*> NewFragments;
		TArray<TSubclassOf<UItemFragment>> ExistingClasses;

		for (int32 Index = 0; Index < Fragments.Num(); ++Index)
		{
			if (UItemFragment* const Fragment = Fragments[Index]; IsValid(Fragment))
			{
				if (!PreviousFragments.Contains(Fragment))
				{
					NewFragments.Add(Index, Fragment);
					continue;
				}
				ExistingClasses.Add(Fragment->GetClass());
			}
		}

		// Quick duplicate check
		for (auto& [Index, NewFragment] : NewFragments)
		{
			TSubclassOf<UItemFragment> NewFragmentClass = NewFragment->GetClass();
			if (ExistingClasses.Contains(NewFragmentClass))
			{
				FString Context = FString::Printf(TEXT("Duplicated item fragment on %s."), *this->GetName());

				FNotificationInfo Info(FText::FromString(Context));
				FSlateNotificationManager::Get().AddNotification(Info)->SetCompletionState(SNotificationItem::CS_Fail);

				UE_LOG(LogInventorySystem, Error, TEXT("Duplicated item fragment %s of %s."), *NewFragmentClass->GetName(), *this->GetName());

				if (Fragments.IsValidIndex(Index))
				{
					Fragments[Index] = nullptr;
				}
			}
		}

		// Check rule validity for new fragments
		for (auto& [Index, NewFragment] : NewFragments)
		{
			TSubclassOf<UItemFragment> NewFragmentClass = NewFragment->GetClass();
			if (const FItemFragmentRule* Rule = InventorySettings->FindRuleForClass(NewFragmentClass))
			{
				if (FString ErrorMessage; !Rule->IsRuleSatisfied(ExistingClasses, ErrorMessage))
				{
					FString Context = FString::Printf(TEXT("Fragment rule not filled on %s."), *this->GetName());

					FNotificationInfo Info(FText::FromString(Context));
					FSlateNotificationManager::Get().AddNotification(Info)->SetCompletionState(SNotificationItem::CS_Fail);

					UE_LOG(LogInventorySystem, Error, TEXT("Fragment rule not filled for fragment %s of %s. %s"), *NewFragmentClass->GetName(), *this->GetName(), *ErrorMessage);

					if (Fragments.IsValidIndex(Index))
					{
						Fragments[Index] = nullptr;
					}
				}
			}
		}

		// Previous fragments update
		PreviousFragments = Fragments;

		PostEditChange();
	}
}
#endif

void UItemDefinition::GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const
{
	TagContainer.AppendTags(Tags);
}

const UItemFragment* UItemDefinition::FindFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (IsValid(FragmentClass))
	{
		for (const UItemFragment* Fragment : Fragments)
		{
			if (IsValid(Fragment) && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}

bool UItemDefinition::HasFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	const bool bFound = FindFragmentByClass(FragmentClass) != nullptr;
	return bFound;
}

bool UItemDefinition::CanBeGiven(UInventorySystemComponent* InventorySystemComponent, FGameplayTag& OutFailureReason)
{
	return K2_CanBeGiven(InventorySystemComponent, OutFailureReason);
}

bool UItemDefinition::K2_CanBeGiven_Implementation(UInventorySystemComponent* InventorySystemComponent, FGameplayTag& OutFailureReason)
{
	return true;
}


############## Private\Definitions\Fragments\ItemFragment.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment.h"


############## Private\Definitions\Fragments\ItemFragment_Consumable.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Consumable.h"
#include "Instances/ItemInstance.h"

#include "Instances/Components/ItemComponent_Consumable.h"
#include "Log/InventorySystemLog.h"

void UItemFragment_Consumable::OnInstanceCreated(UItemInstance* Instance)
{
	Super::OnInstanceCreated(Instance);

	if (const auto Component = Instance->AddComponent<UItemComponent_Consumable>(); IsValid(Component))
	{
		Component->GameplayEffect = GameplayEffect;
		Component->MaxUseCount = MaxUsesCount;
		Component->Initialize(*Instance);
		return;
	}

	UE_LOG(LogInventorySystem, Warning, TEXT("Failed to add ItemComponent_Consumable to ItemInstance: %s"), *GetNameSafe(Instance->GetDefinitionClass()));
}


############## Private\Definitions\Fragments\ItemFragment_Storable.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Storable.h"

bool UItemFragment_Storable::CanStack() const
{
	return MaxStackCount > 1;
}

bool UItemFragment_Storable::IsUnique() const
{
	return (StorageFlags & static_cast<int32>(EItemStorageFlags::Unique)) != 0;
}


############## Private\GameplayTags\InventoryGameplayTags.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "GameplayTags/InventoryGameplayTags.h"

namespace InventorySystemGameplayTags
{
	// Inventory container tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Container, "Inventory.Container", "Root tag for inventory containers");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Container_Default, "Inventory.Container.Default", "Default gameplay tag used for inventory container");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Container_Bag, "Inventory.Container.Bag", "Default gameplay tag used for inventory container");

	// Inventory failure tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure, "Inventory.Failure", "Root tag for inventory failures");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_ContainerNotFound, "Inventory.Failure.ContainerNotFound", "Root tag for inventory failures");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidDefinition, "Inventory.Failure.InvalidDefinition", "The item to equip is null");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidCount, "Inventory.Failure.InvalidCount", "Zero or negative quantity given");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidInstance, "Inventory.Failure.InvalidInstance", "The given item instance is invalid");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_NotAuthority, "Inventory.Failure.NotAuthority", "The item to equip is null");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_NotStorable, "Inventory.Failure.NotStorable", "The item do not own UItemFragment_Storable fragment");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_Uniqueness, "Inventory.Failure.Uniqueness", "An instance of the unique item already exist");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_DefinitionRefused, "Inventory.Failure.DefinitionRefused", "Item definition conditions are not met");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_Internal, "Inventory.Failure.Internal", "Internal error during inventory process");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidComponent, "Inventory.Failure.InvalidComponent", "Invalid InventorySystemComponent");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidContainer, "Inventory.Failure.InvalidContainer", "Invalid InventoryContainer");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidHandle, "Inventory.Failure.InvalidHandle", "Invalid inventory entry handle");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_HandleMismatch, "Inventory.Failure.HandleMismatch", "Invalid inventory entry handle");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Inventory_Failure_InvalidIndex, "Inventory.Failure.InvalidIndex", "Invalid inventory entry handle");
} // namespace InventorySystemGameplayTags


############## Private\Instances\ItemInstance.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/ItemInstance.h"

#include "Components/InventorySystemComponent.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "Interfaces/InventorySystemInterface.h"
#include "Net/UnrealNetwork.h"

UItemInstance::UItemInstance(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	OwningActor = GetTypedOuter<AActor>();
}

void UItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, DefinitionClass);
}

void UItemInstance::GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const
{
	if (IsValid(Definition.Get()))
	{
		Definition->GetOwnedGameplayTags(TagContainer);
	}
	TagContainer.AppendTags(Tags);
}

void UItemInstance::Initialize(UItemDefinition* InDefinition)
{
	SetDefinition(InDefinition);

	for (UItemFragment* Fragment : InDefinition->Fragments)
	{
		if (IsValid(Fragment))
		{
			Fragment->OnInstanceCreated(this);
		}
	}

	PostInitialize();
}

void UItemInstance::Uninitialize()
{
	for (UItemComponent* Component : Components)
	{
		Component->Uninitialize();
	}
}

UInventorySystemComponent* UItemInstance::GetInventorySystemComponent() const
{
	if (!IsValid(OwningActor) || !OwningActor->Implements<UInventorySystemInterface>())
	{
		return nullptr;
	}

	if (const IInventorySystemInterface* Implementer = Cast<IInventorySystemInterface>(OwningActor))
	{
		return Implementer->GetInventorySystemComponent();
	}
	return nullptr;
}

AActor* UItemInstance::GetOwningActor() const
{
	return OwningActor;
}

TSubclassOf<UItemDefinition> UItemInstance::GetDefinitionClass() const
{
	return DefinitionClass;
}

UItemDefinition* UItemInstance::GetDefinition() const
{
	return Definition.Get();
}

const UItemFragment* UItemInstance::FindFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (Definition.IsValid() && IsValid(FragmentClass))
	{
		return Definition->FindFragmentByClass(FragmentClass);
	}

	return nullptr;
}

bool UItemInstance::HasFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (Definition.IsValid() && IsValid(FragmentClass))
	{
		return Definition->HasFragmentByClass(FragmentClass);
	}

	return false;
}

UItemComponent* UItemInstance::AddComponent(const TSubclassOf<UItemComponent> ComponentClass)
{
	if (UItemComponent* Component = NewObject<UItemComponent>(this, ComponentClass); IsValid(Component))
	{
		Component->Initialize(*this);
		Components.Add(Component);
		return Component;
	}
	return nullptr;
}

void UItemInstance::PostInitialize()
{
	for (UItemComponent* Component : Components)
	{
		if (IsValid(Component))
		{
			Component->PostInitialize();	
		}
	}
}

void UItemInstance::SetDefinition(UItemDefinition* InDefinition)
{
	Definition = InDefinition;
	DefinitionClass = InDefinition->GetClass();
}

const UItemComponent* UItemInstance::FindComponentByClass(const TSubclassOf<UItemComponent> ComponentClass) const
{
	if (IsValid(ComponentClass))
	{
		for (const UItemComponent* Component : Components)
		{
			if (IsValid(Component) && Component->IsA(ComponentClass))
			{
				return Component;
			}
		}
	}

	return nullptr;
}


############## Private\Instances\Components\ItemComponent.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/ItemComponent.h"


void UItemComponent::Initialize(UItemInstance& InInstance, UItemFragment* InSourceFragment)
{
	OwningInstance = &InInstance;
	SourceFragment = InSourceFragment;
}

UItemInstance* UItemComponent::GetOwningInstance()
{
	return OwningInstance;
}

############## Private\Instances\Components\ItemComponent_Consumable.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/ItemComponent_Consumable.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "Definitions/Fragments/ItemFragment_Consumable.h"
#include "GeometryCollection/GeometryCollectionComponent.h"
#include "Instances/ItemInstance.h"
#include "Log/InventorySystemLog.h"
#include "Net/UnrealNetwork.h"

void UItemComponent_Consumable::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(UItemComponent_Consumable, RemainingUses);
}

bool UItemComponent_Consumable::CanConsume(const int32 UseCount) const
{
	return RemainingUses >= UseCount;
}

void UItemComponent_Consumable::Consume(const int32 UseCount)
{
	if (!CanConsume(UseCount) && !IsValid(GameplayEffect))
	{
		return;
	}

	const AActor* OwnerActor = OwningInstance->GetOwningActor();
	if (!OwnerActor)
	{
		return;
	}
	
	if (UAbilitySystemComponent* const TargetAbilityComponent = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwnerActor))
	{
		FGameplayEffectContextHandle EffectContext = TargetAbilityComponent->MakeEffectContext();
		EffectContext.AddSourceObject(OwningInstance.Get());

		const int32 EffectCount = ShouldStackEffects ? UseCount : 1;
		
		// Even if one time has succeeded, reduce the count of uses left.
		bool Succeeded = false;
		for (int32 i = 0; i < EffectCount; ++i)
		{
			const UGameplayEffect* const GameplayEffectCDO = GameplayEffect->GetDefaultObject<UGameplayEffect>();
			const FActiveGameplayEffectHandle GameplayEffectHandle = TargetAbilityComponent->ApplyGameplayEffectToSelf(GameplayEffectCDO, 0, EffectContext);

			Succeeded |= GameplayEffectHandle.WasSuccessfullyApplied();
		}
			
		if (Succeeded)
		{
			RemainingUses -= UseCount;
		}
	}
}

void UItemComponent_Consumable::SetRemainingUses(const int32 Count)
{
	UE_CLOG(Count > MaxUseCount, LogInventorySystem, Warning, TEXT("Tried to set remaining uses for consumable item [%s] to %d but clamps to maximum use count %d."), *GetNameSafe(OwningInstance->GetDefinitionClass()), Count, MaxUseCount);
	RemainingUses = FMath::Clamp(Count, 0, MaxUseCount);
}

void UItemComponent_Consumable::RestoreUses()
{
	RemainingUses = MaxUseCount;
}

############## Private\Interfaces\InventorySystemInterface.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Interfaces/InventorySystemInterface.h"

// Add default functionality here for any IInventorySystemInterface functions that are not pure virtual.


############## Private\Library\InventoryFunctionLibrary.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Library/InventoryFunctionLibrary.h"

#include "Definitions/Fragments/ItemFragment.h"
#include "Definitions/ItemDefinition.h"

const UItemFragment* UInventoryFunctionLibrary::FindItemDefinitionFragment(const TSubclassOf<UItemDefinition> ItemDef, const TSubclassOf<UItemFragment> FragmentClass)
{
	if (IsValid(ItemDef) && IsValid(FragmentClass))
	{
		return GetDefault<UItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}
	return nullptr;
}


############## Private\Log\InventorySystemLog.cpp ###############
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Log/InventorySystemLog.h"

DEFINE_LOG_CATEGORY(LogInventorySystem);


############## Private\Settings\InventorySystemSettings.cpp ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/InventorySystemSettings.h"

#include "Settings/ItemFragmentRule.h"

#if WITH_EDITOR
const FItemFragmentRule* UInventorySystemSettings::FindRuleForClass(const TSubclassOf<UItemFragment>& FragmentClass) const
{
	return FragmentRules.Find(FragmentClass);
}
#endif


############## Private\Settings\ItemFragmentRule.cpp ###############
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/ItemFragmentRule.h"

#include "Definitions/Fragments/ItemFragment.h"

bool FItemFragmentRule::IsRuleSatisfied(const TArray<TSubclassOf<UItemFragment>>& FragmentClasses, FString& ErrorContext) const
{
	bool bIsSatisfied = true;
	TArray<FString> BlockingClasses;
	TArray<FString> MissingClasses;

	for (TSubclassOf FragmentClass : FragmentClasses)
	{
		if (BlockedFragments.Contains(FragmentClass))
		{
			bIsSatisfied = false;
			BlockingClasses.Add(FragmentClass->GetName());
		}
	}

	for (TSubclassOf FragmentClass : RequiredFragments)
	{
		if (!FragmentClasses.Contains(FragmentClass))
		{
			bIsSatisfied = false;
			MissingClasses.Add(FragmentClass->GetName());
		}
	}

	const FString BlockingClassesString = FString::Join(BlockingClasses, TEXT(", "));
	const FString MissingClassesString = FString::Join(MissingClasses, TEXT(", "));

	ErrorContext = FString::Printf(TEXT("Blocking fragment classes : %s - Missing fragment classes : %s"), *BlockingClassesString, *MissingClassesString);

	return bIsSatisfied;
}


############## Public\InventorySystemCore.h ###############
﻿#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FInventorySystemCoreModule final : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};


############## Public\Components\InventorySystemComponent.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ActorComponent.h"
#include "CoreMinimal.h"
#include "Containers/InventoryContainer.h"
#include "Data/InventoryCache.h"
#include "Data/InventoryList.h"
#include "Definitions/ItemDefinition.h"
#include "GameplayTags/InventoryGameplayTags.h"

#include "InventorySystemComponent.generated.h"

class UInventorySet;
struct FGameplayTag;
class UEquipmentComponent;


/**
 * Multicast delegate that broadcasts inventory change events to all listeners
 * @param Data Detailed information about the inventory change including the affected item, previous state, and type of change
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInventoryChange, const FInventoryChangeData&, Data);

/**
 * @class UInventorySystemComponent
 * @see UActorComponent
 * @brief A component that manages an actor's inventory system with network replication support
 * @details Provides a flexible inventory system that can store, manage, and replicate items.
 * Supports dynamic item addition/removal, quantity tracking, and cache management for optimal performance.
 * Implements a robust replication system for multiplayer games. All operations are replicated to clients
 * and changes can be tracked through delegates.
 */

UCLASS(BlueprintType, ClassGroup = ("Equipment"), meta = (BlueprintSpawnableComponent))
class INVENTORYSYSTEMCORE_API UInventorySystemComponent : public UActorComponent
{
	GENERATED_BODY()

	friend FInventoryList;

public:
	UInventorySystemComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	// ~UObject

	// AActorComponent
	virtual void InitializeComponent() override;
	virtual void UninitializeComponent() override;
	// ~AActorComponent


	UFUNCTION(BlueprintCallable, Category="Inventory", meta = (Categories = "Inventory.Container"))
	FInventoryResult TryAddItemDefinitionIn(const FGameplayTag& ContainerTag, TSubclassOf<UItemDefinition> ItemDefinition, int32 Count);
	UFUNCTION(BlueprintCallable, Category="Inventory", meta = (Categories = "Inventory.Container"))
	FInventoryResult TryAddItemInstanceIn(const FGameplayTag& ContainerTag, UItemInstance* ItemInstance, int32 StackCount);

	UFUNCTION(BlueprintCallable, Category="Inventory")
	FInventoryResult TryAddItemDefinition(const TSubclassOf<UItemDefinition>& ItemDefinition, int32 Count);
	UFUNCTION(BlueprintCallable, Category="Inventory")
	FInventoryResult TryAddItemInstance(UItemInstance* ItemInstance, int32 StackCount);

	UFUNCTION(BlueprintCallable, Category="Inventory")
	bool TryRemoveFromHandle(FInventoryEntryHandle Handle, FGameplayTag& OutFailureReason);
	UFUNCTION(BlueprintCallable, Category="Inventory")
	FInventoryResult TryMoveByHandle(FInventoryEntryHandle Handle, UInventoryContainer* TargetContainer);

	UFUNCTION(BlueprintCallable, Category="Inventory")
	void Empty();

	UFUNCTION(BlueprintCallable, Category="Inventory|Query", meta = (Categories = "Inventory.Container"))
	FInventoryEntryHandle FindHandleFromInstanceIn(const FGameplayTag& ContainerTag, UItemInstance* Instance) const;
	UFUNCTION(BlueprintCallable, Category="Inventory|Query")
	FInventoryEntryHandle FindHandleFromInstance(UItemInstance* Instance) const;
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	TArray<FInventoryEntryHandle> GetAllStacks() const;

	UFUNCTION(BlueprintCallable, Category = "Inventory", meta = (Categories = "Inventory.Container"))
	int32 GetStackCountByDefinitionIn(TSubclassOf<UItemDefinition> DefinitionClass, const FGameplayTag& ContainerTag) const;
	UFUNCTION(BlueprintCallable, Category = "Inventory", meta = (Categories = "Inventory.Container"))
	int32 GetTotalCountByDefinitionIn(TSubclassOf<UItemDefinition> DefinitionClass, const FGameplayTag& ContainerTag) const;

	UFUNCTION(BlueprintCallable, Category = "Inventory")
	int32 GetStackCountByDefinition(TSubclassOf<UItemDefinition> DefinitionClass) const;
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	int32 GetTotalCountByDefinition(TSubclassOf<UItemDefinition> DefinitionClass) const;


	UFUNCTION(BlueprintCallable, Category="Inventory|Container", meta = (Categories = "Inventory.Container"))
	bool RegisterContainer(const FGameplayTag& Tag, UInventoryContainer* Container);
	UFUNCTION(BlueprintCallable, Category="Inventory|Container", meta = (Categories = "Inventory.Container"))
	bool UnregisterContainer(const FGameplayTag& Tag);
	UFUNCTION(BlueprintPure, Category="Inventory|Container", meta = (Categories = "Inventory.Container"))
	UInventoryContainer* GetContainer(const FGameplayTag& ContainerTag) const;
	UFUNCTION(BlueprintPure, Category="Inventory|Container")
	TMap<FGameplayTag, UInventoryContainer*> GetAllContainers() const;


	UFUNCTION(BlueprintCallable, Category = "Inventory", meta = (DeterminesOutputType = DefinitionClass))
	UItemDefinition* GetCachedDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const;

protected:
	static bool IsValidContainerTag(const FGameplayTag& Tag);

	/**
	 * Called after an item is added to the inventory
	 * @param Data Information about the added inventory entry
	 */
	virtual void PostInventoryEntryAdded(const FInventoryChangeData& Data);

	/**
	 * Called after an item is removed from the inventory
	 * @param Data Information about the removed inventory entry
	 */
	virtual void PostInventoryEntryRemoved(const FInventoryChangeData& Data);

	/**
	 * Called after an inventory entry is modified
	 * @param Data Information about the modified inventory entry
	 */
	virtual void PostInventoryEntryChanged(const FInventoryChangeData& Data);

	/**
	 * Called after any change to the inventory
	 * @param Data Information about the inventory change
	 */
	virtual void PostInventoryChanged(const FInventoryChangeData& Data);

	/** Event fired when an item is added to the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryAdded;

	/** Event fired when an item is removed from the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryRemoved;

	/** Event fired when an inventory entry is modified */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryChanged;

	/** Event fired after any change to the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryChanged;

	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TSubclassOf<UInventoryContainer> DefaultContainerClass = UInventoryContainer::StaticClass();

	UPROPERTY(EditDefaultsOnly, Category = "Inventory", meta = (Categories = "Inventory.Container"))
	FGameplayTag DefaultContainerTag = InventorySystemGameplayTags::TAG_Inventory_Container_Default;

	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	TObjectPtr<UInventorySet> DefaultInventorySet;

	UPROPERTY(/* Replicated */) // Should be marked as replicated but not supported, so replicated as subobjects
	TMap<FGameplayTag, TObjectPtr<UInventoryContainer>> Containers;

	/** Inventory definitions cache. Not replicated */
	UPROPERTY()
	TObjectPtr<UInventoryCache> Cache;
};


############## Public\Containers\InventoryContainer.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Data/InventoryList.h"
#include "UObject/Object.h"
#include "InventoryContainer.generated.h"

class UItemDefinition;
class UItemInstance;
class UInventorySystemComponent;
class UStoragePolicy;


/**
 * 
 */
UCLASS(BlueprintType, Blueprintable)
class INVENTORYSYSTEMCORE_API UInventoryContainer : public UObject
{
	GENERATED_BODY()

public:
	UInventoryContainer(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual bool IsSupportedForNetworking() const override { return true; }
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// ~UObject

	virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags);


	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	FInventoryResult TryAddItemDefinition(TSubclassOf<UItemDefinition> Definition, int32 Count);

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	FInventoryResult TryAddItemInstance(UItemInstance* Instance, int32 Count);

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	bool TryRemoveItem(FInventoryEntryHandle& Handle, FGameplayTag& OutFailureReason);

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	FInventoryResult TryMoveItemTo(FInventoryEntryHandle Handle, UInventoryContainer* TargetContainer);

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	FInventoryEntryHandle FindHandle(UItemInstance* Instance) const;

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	FInventoryList& GetInventoryList() { return InventoryList; }

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	void SetOwnerComponent(UInventorySystemComponent* NewOwner);
	int32 GetStackCountByDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const;
	int32 GetTotalCountByDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const;

	UFUNCTION(BlueprintCallable, Category="Inventory|Container")
	void AddStoragePolicy(UStoragePolicy* Policy);

protected:
	bool ValidateStorage(UItemInstance* Instance, FGameplayTag& OutFailureReason) const;

	UPROPERTY()
	UInventorySystemComponent* OwnerComponent = nullptr;

	// Replicated list of items in this container
	UPROPERTY(Replicated)
	FInventoryList InventoryList;

	// Policies local to this container (not replicated)
	UPROPERTY()
	TArray<TObjectPtr<UStoragePolicy>> Policies;
};


############## Public\Containers\Policies\StoragePolicy.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "StoragePolicy.generated.h"

struct FGameplayTag;
class UItemInstance;
/**
 * @class UStoragePolicy
 * Base abstract class for container policies.
 * Implementations should define CanStoreItem and provide validation rules.
 */
UCLASS(Abstract, BlueprintType, Blueprintable, EditInlineNew, DefaultToInstanced)
class INVENTORYSYSTEMCORE_API UStoragePolicy : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Determines whether the given item instance can be stored in the container.
	 * @param Instance - the item being considered
	 * @param OutFailureReason - if false, the reason the item is rejected
	 */
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Inventory|Policy")
	bool CanStoreItem(UItemInstance* Instance, FGameplayTag& OutFailureReason) const;
};


############## Public\Containers\Policies\StoragePolicy_TagRequirement.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "StoragePolicy.h"
#include "UObject/Object.h"
#include "StoragePolicy_TagRequirement.generated.h"

/**
 * 
 */
UCLASS(DisplayName = "Tag Requirements")
class INVENTORYSYSTEMCORE_API UStoragePolicy_TagRequirement : public UStoragePolicy
{
	GENERATED_BODY()

public:
	/** Required tag the item must have to be accepted */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Policy")
	FGameplayTagContainer RequiredTags;

	/** Required tag the item must not have to be accepted */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Policy")
	FGameplayTagContainer ForbiddenTags;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Policy")
	bool bExactMatch = true;

	virtual bool CanStoreItem_Implementation(UItemInstance* Instance, FGameplayTag& OutFailureReason) const override;
};


############## Public\Data\InventoryCache.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "InventoryCache.generated.h"

class UItemDefinition;

/**
 * @class UInventoryCache
 * @see UObject
 * @brief A thread-safe cache system for ItemDefinitions
 * @details This class manages a cache of ItemDefinitions to improve performance by reducing object creation 
 * and providing thread-safe access to cached objects.
 */
UCLASS(HideDropdown, Hidden)
class INVENTORYSYSTEMCORE_API UInventoryCache : public UObject
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;

public:
	UInventoryCache();
	virtual ~UInventoryCache() override;

	/**
	 * Gets or creates a cached ItemDefinition instance in a thread-safe manner
	 * If the ItemDefinition is not in the cache, creates a new one and adds it to the cache
	 *
	 * @param ItemDefinitionClass The class of the ItemDefinition to retrieve or create
	 * @return A pointer to the cached or newly created ItemDefinition instance
	 * @see UItemDefinition
	 */
	UItemDefinition* GetCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass);

	/**
	 * Checks if an ItemDefinition of the specified class exists in the cache
	 *
	 * @param ItemDefinitionClass The class of the ItemDefinition to check
	 * @return True if the cache contains a valid instance of the specified class, false otherwise
	 * @see UItemDefinition
	 */
	bool IsCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const;

private:
	/**
	 * Clears the cache of any ItemDefinitions that are no longer rooted
	 * This method is called after garbage collection and is thread-safe
	 * @see CacheLock
	 */
	void Clear();

	/**
	 * Storage for cached ItemDefinition instances
	 * Maps ItemDefinition classes to their corresponding cached instances
	 */
	UPROPERTY()
	TMap<TSubclassOf<UItemDefinition>, TWeakObjectPtr<UItemDefinition>> CachedDefinitionMap;

	/**
	 * Synchronization primitive for thread-safe access to the CachedDefinitionMap
	 * Used to prevent concurrent modifications to the cache
	 */
	FCriticalSection CacheLock;
};


############## Public\Data\InventoryChangeData.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "InventoryChangeData.generated.h"

struct FInventoryEntry;
class UItemInstance;

/**
 * Defines the types of changes that can occur to inventory entries
 */
UENUM(BlueprintType)
enum class EInventoryChangeType : uint8
{
	Added, ///< Item was added to the inventory
	Removed, ///< Item was removed from the inventory
	Modified ///< Item's properties were modified (e.g. stack count)
};

/**
 * @struct FInventoryChangeData
 * @see UItemInstance, FInventoryEntry, EInventoryChangeType
 * @brief Represents a data payload for tracking inventory item changes including addition, removal, and modification of items
 * @details Contains information about the affected item instance, its index in the inventory, the type of change, 
 *		  and stack count changes before and after the modification occurred. Used for notifying systems about
 *		  inventory state changes and maintaining synchronization.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryChangeData
{
	GENERATED_BODY()

	FInventoryChangeData()
	{
	}

	/**
	 * Constructs an inventory change data instance with the specified parameters
	 * @param InIndex The index of the inventory entry that was modified
	 * @param Entry The inventory entry containing the item instance and stack count
	 * @param InChangeType The type of modification that occurred
	 */
	FInventoryChangeData(const int32 InIndex, const FInventoryEntry& Entry, const EInventoryChangeType InChangeType = EInventoryChangeType::Added);

	/** 
	 * Zero-based index of the modified inventory entry
	 * Set to INDEX_NONE (-1) when the entry is invalid
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 Index = INDEX_NONE;

	/** 
	 * Reference to the affected item instance
	 * Contains the item's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	TObjectPtr<UItemInstance> Instance = nullptr;

	/** 
	 * Specifies whether the item was added, removed, or modified
	 * Defaults to Added when not specified
	 */
	UPROPERTY(BlueprintReadOnly)
	EInventoryChangeType ChangeType = EInventoryChangeType::Added;

	/** 
	 * Stack count before the inventory modification occurred
	 * Used to track quantity changes
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 OldCount = 0;

	/** 
	 * Stack count after the inventory modification occurred
	 * Represents the current quantity
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 NewCount = 0;

	/**
	 * Checks if this inventory change data is valid
	 * @return True if the index is valid (not INDEX_NONE), false otherwise
	 */
	bool IsValid() const { return Index != INDEX_NONE; }
};


############## Public\Data\InventoryEntry.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "InventoryEntry.generated.h"

class UItemInstance;

/**
 * @struct FInventoryEntry
 * @see FFastArraySerializerItem, UItemInstance, FInventoryList
 * @brief Represents a single inventory entry with item instance and stack management
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;
	friend class UInventoryContainer;
	friend struct FInventoryList;
	friend struct FInventoryChangeData;
	friend struct FInventoryEntryHandle;

	FInventoryEntry()
	{
	};

	~FInventoryEntry()
	{
	};

	// FFastArraySerializer
	// Functions not virtual in FFAstArraySerializer because called by template
	void PreReplicatedRemove(const FInventoryList& InArraySerializer) const;
	void PostReplicatedAdd(const FInventoryList& InArraySerializer) const;
	void PostReplicatedChange(const FInventoryList& InArraySerializer) const;
	FString GetDebugString() const;
	// ~FFastArraySerializer

private:
	/**
	 * The actual item instance being stored in this inventory entry
	 * This instance contains the item's data and properties
	 */
	UPROPERTY()
	TObjectPtr<UItemInstance> Instance = nullptr;

	/**
	 * Current number of items in this stack
	 * Represents how many items of this type are grouped together
	 */
	UPROPERTY()
	int32 StackCount = 0;

	/** 
	 * Used to detect local stack changes without replication
	 * Helps with client-side prediction of stack modifications
	 * @note Not replicated - used for client prediction only
	 */
	UPROPERTY(NotReplicated)
	int32 LastStackCount = INDEX_NONE;

	/** 
	 * Used to detect local stack changes without replication
	 * Helps with client-side prediction of stack modifications
	 * @note Not replicated - used for client prediction only
	 */
	UPROPERTY(NotReplicated, Transient)
	UInventoryContainer* OwningContainer = nullptr;
};


############## Public\Data\InventoryEntryHandle.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "InventoryEntry.h"

#include "InventoryEntryHandle.generated.h"

class UItemInstance;

/**
 * @struct FInventoryEntryHandle
 * @see UItemInstance
 * @brief Represents a handle to an inventory entry, providing access to its index, item instance, and stack count.
 * @details This structure acts as a lightweight wrapper around inventory entry data, allowing access to the entry's
 * position in the inventory, its associated item instance, and the current stack count. Used throughout the inventory
 * system to reference and manipulate inventory entries.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryEntryHandle
{
	GENERATED_BODY()

	FInventoryEntryHandle()
	{
	}

	/**
	 * Creates a handle from an existing inventory entry
	 * @param InIndex Index of the entry in the inventory
	 * @param InEntry The inventory entry to reference
	 */
	FInventoryEntryHandle(const int32 InIndex, const FInventoryEntry& InEntry)
		: EntryIndex(InIndex)
	{
		EntryIndex = InIndex;
		ItemInstance = InEntry.Instance;
		StackCount = InEntry.StackCount;
		Container = InEntry.OwningContainer;
	}

	/**
	 * Creates a handle with specified values
	 * @param InIndex Index of the entry in the inventory
	 * @param InInstance The item instance to reference
	 * @param InStackCount Number of items in the stack
	 * @param InContainer
	 */
	FInventoryEntryHandle(const int32 InIndex, UItemInstance* InInstance, const int32 InStackCount, UInventoryContainer* InContainer)
		: EntryIndex(InIndex), ItemInstance(InInstance), StackCount(InStackCount), Container(InContainer)
	{
	}

	/**
	 * Checks if this handle references a valid inventory entry
	 * @return true if the handle points to a valid entry, false otherwise
	 */
	bool IsHandleValid() const;

	bool operator==(const FInventoryEntryHandle& Other) const
	{
		return EntryIndex == Other.EntryIndex && ItemInstance == Other.ItemInstance && Container == Other.Container;
	}

	/**
	 * Index of the inventory entry in the inventory list
	 * Defaults to INDEX_NONE (-1) if the handle is invalid
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 EntryIndex = INDEX_NONE;

	/**
	 * The item instance associated with this inventory entry
	 * Contains the actual item data and properties
	 */
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UItemInstance> ItemInstance = nullptr;

	/**
	 * Current number of items in this stack
	 * Represents how many items of this type are grouped together
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 StackCount = 0;

	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UInventoryContainer> Container = nullptr;
};


############## Public\Data\InventoryList.h ###############
﻿// Copyright (C) [Year] [Company Name]. All Rights Reserved.

#pragma once

#include "GameplayTagContainer.h"
#include "InventoryChangeData.h"
#include "InventoryEntry.h"
#include "InventoryEntryHandle.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "InventoryList.generated.h"

class UInventoryContainer;
struct FGameplayTag;
class UItemDefinition;
struct FNetDeltaSerializeInfo;
struct FReplicationFlags;


USTRUCT(BlueprintType)
struct FInventoryResult
{
	GENERATED_BODY()
	;

	UPROPERTY(BlueprintReadOnly)
	TArray<UItemInstance*> Instances;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag FailureReason;

	bool Succeeded() const { return FailureReason.IsValid() == false; };

	int32 Num() const { return Instances.Num(); }
};


/**
 * @class FInventoryList
 * @see FFastArraySerializer
 * @brief A replicated container that manages a list of inventory entries
 * @details Handles the storage, replication, and management of inventory entries including
 * addition, removal, and modification of items. Utilizes FastArraySerializer for efficient
 * network replication and provides interfaces for item manipulation and querying.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;
	friend class UInventoryContainer;
	friend FInventoryEntry;

	FInventoryList();
	FInventoryList(UInventorySystemComponent* InOwnerComponent);

	// FFastArraySerializer
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);

	/** Implements network delta serialization for the equipment list. */
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParams)
	{
		return FastArrayDeltaSerialize<FInventoryEntry, FInventoryList>(Entries, DeltaParams, *this);
	}

	// ~FFastArraySerializer


	FInventoryResult AddFromDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass, int32 Count = 1);
	FInventoryResult AddInstance(UItemInstance* ItemInstance, int32 Count = 1);

	void RemoveInstance(UItemInstance* Instance);
	bool RemoveFromHandle(const FInventoryEntryHandle& Handle, FGameplayTag& OutFailureReason);
	bool RemoveFromIndex(int32 Index, FGameplayTag& OutFailureReason);

	FInventoryEntryHandle MakeHandle(int32 Index) const;
	FInventoryEntryHandle FindHandleFromInstance(UItemInstance* Instance) const;
	FInventoryEntryHandle FindHandleOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);

	TArray<FInventoryEntryHandle> GetAllHandles() const;
	TArray<FInventoryEntryHandle> GetHandlesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);
	TArray<FInventoryEntry*> GetAllEntries();
	FInventoryEntry* FindEntryOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);
	TArray<FInventoryEntry*> GetEntriesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);

	int32 GetStackCountByDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const;
	int32 GetTotalCountByDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const;

	void SetOwningComponent(UInventorySystemComponent* Component);
	void SetOwningContainer(UInventoryContainer* Container);

protected:
	UItemInstance* CreateItemInstance(const TSubclassOf<UItemDefinition>& DefinitionClass, int32& Count);

	/**
	 * Checks if an item of the specified definition can be added
	 * @param DefinitionClass The item definition class to check
	 * @param OutFailureReason
	 * @param InCount
	 * @return True if the item can be added, false otherwise
	 */
	bool CanAdd(const TSubclassOf<UItemDefinition>& DefinitionClass, FGameplayTag& OutFailureReason, int32 InCount = 1);

	/**
	 * Called when an entry is changed.
	 * @param Index The index of the changed entry.
	 * @param Entry The changed entry.
	 */
	void Internal_OnEntryChanged(int32 Index, const FInventoryEntry& Entry) const;
	/**
	 * Called when an entry is added.
	 * @param Index The index of the added entry.
	 * @param Entry The added entry.
	 */
	void Internal_OnEntryAdded(int32 Index, const FInventoryEntry& Entry) const;
	/**
	 * Called when an entry is removed.
	 * @param Index The index of the removed entry.
	 * @param Entry The removed entry.
	 */
	void Internal_OnEntryRemoved(int32 Index, const FInventoryEntry& Entry) const;

	/** Array of inventory entries managed by this list */
	UPROPERTY()
	TArray<FInventoryEntry> Entries;

	/** The inventory system component that owns this list. Not replicated */
	UPROPERTY(NotReplicated)
	TObjectPtr<UInventorySystemComponent> OwningComponent = nullptr;

	/** The inventory container that owns this list. Not replicated */
	UPROPERTY(NotReplicated)
	TObjectPtr<UInventoryContainer> OwningContainer = nullptr;
};

// Required to specify that this structure uses a NetDeltaSerializer method to help serialization operation decision
template <>
struct TStructOpsTypeTraits<FInventoryList> : TStructOpsTypeTraitsBase2<FInventoryList>
{
	enum
	{
		WithNetDeltaSerializer = true
	};
};


############## Public\Data\InventorySet.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "InventoryList.h"
#include "Engine/DataAsset.h"
#include "GameplayTags/InventoryGameplayTags.h"

#include "InventorySet.generated.h"

struct FGameplayTag;
struct FInventorySet_ItemSet;
class UItemDefinition;
class UInventorySystemComponent;

/**
 * @class UInventorySet
 * @see UPrimaryDataAsset
 * @brief Data asset storing a predefined set of items to be granted together
 * @details Used to define groups of items that can be given to an inventory system component at once.
 * Commonly used for starting equipment, loot drops, or quest rewards.
 */
UCLASS(CollapseCategories, BlueprintType, meta = (DisplayName = "Inventory Set"))
class INVENTORYSYSTEMCORE_API UInventorySet : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	/**
	 * Grants all items defined in this set to the specified inventory system component
	 * @param InventorySystemComp The target inventory component that will receive the items
	 * @see UInventorySystemComponent
	 */
	FInventoryResult GiveToInventorySystem(UInventorySystemComponent* InventorySystemComp);

protected:
	UPROPERTY(EditDefaultsOnly, Category = "Container")
	FGameplayTag TargetContainer = InventorySystemGameplayTags::TAG_Inventory_Container_Default;
	/**
	 * Collection of item definitions and their quantities to be granted together
	 * Each entry specifies an item type and how many of that item should be given
	 */
	UPROPERTY(EditDefaultsOnly, Category = "Items", meta = (TitleProperty = "[{Quantity}] {ItemDefinition}"))
	TArray<FInventorySet_ItemSet> Items;
};


############## Public\Data\InventorySet_ItemSet.h ###############
#pragma once

#include "Definitions/ItemDefinition.h"

#include "InventorySet_ItemSet.generated.h"

/**
 * @class FInventorySet_ItemSet
 * @see UItemDefinition
 * @brief Data structure used by the InventorySet to manage item definitions and quantities
 * @details Represents a set of items to be added to an inventory, containing both the item definition
 * and the quantity to be given. Used primarily for initial inventory setup and item grants.
 */
USTRUCT(BlueprintType)
struct FInventorySet_ItemSet
{
	GENERATED_BODY()

	/** The item definition class that defines the type of item to be given */
	UPROPERTY(EditDefaultsOnly, DisplayName = "Definition")
	TSubclassOf<UItemDefinition> ItemDefinition = nullptr;

	/** The number of items of this type to give */
	UPROPERTY(EditDefaultsOnly)
	int Quantity = 1;
};


############## Public\Definitions\ItemDefinition.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagAssetInterface.h"
#include "GameplayTagContainer.h"
#include "UObject/Object.h"

#include "ItemDefinition.generated.h"

class UInventorySystemComponent;
class UItemFragment;

/**
 * @class UItemDefinition
 * @see UObject
 * @brief Data asset definition of an item that can be given/owned by a character
 * @details Represents a template for items in the inventory system. Contains basic item information 
 * like name and description, and can be extended with fragments for additional functionality.
 * This is an abstract class that should be inherited to create specific item types.
 */
UCLASS(Blueprintable, Abstract, BlueprintType)
class INVENTORYSYSTEMCORE_API UItemDefinition : public UObject, public IGameplayTagAssetInterface
{
	GENERATED_BODY()

public:
	UItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void PostLoad() override;
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
	// ~UObject

	// IGameplayTagAssetInterface
	virtual void GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const override;
	// ~IGameplayTagAssetInterface

	/**
	 * Searches for a specific fragment type in this item definition
	 * @param FragmentClass The class type of fragment to find
	 * @return The found fragment instance, or nullptr if not found
	 * @see UItemFragment
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UItemFragment* FindFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;

	/**
	 * Checks if this item definition contains a specific fragment type
	 * @param FragmentClass The class type of fragment to check
	 * @return True if the fragment exists, false otherwise
	 * @see UItemFragment
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false)
	bool HasFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;
	/**
	 * Template version of FindFragmentByClass for convenient type-safe fragment access
	 * @tparam T The specific fragment class type to find
	 * @return Typed pointer to the found fragment, or nullptr if not found
	 * @see FindFragmentByClass
	 */
	template <typename T>
	const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	/**
	 * Checks if this item can be given to the specified inventory
	 * @param InventorySystemComponent The target inventory component
	 * @param OutFailureReason
	 * @return True if the item can be given, false otherwise
	 * @see UInventorySystemComponent
	 */
	virtual bool CanBeGiven(UInventorySystemComponent* InventorySystemComponent, FGameplayTag& OutFailureReason);

	/**
	 * Blueprint-accessible version of CanBeGiven
	 * @param InventorySystemComponent The target inventory component
	 * @param OutFailureReason
	 * @return True if the item can be given, false otherwise
	 * @see CanBeGiven
	 */
	UFUNCTION(BlueprintNativeEvent, BlueprintPure)
	bool K2_CanBeGiven(UInventorySystemComponent* InventorySystemComponent, FGameplayTag& OutFailureReason);

	/** The display name of the item shown in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Definition")
	FText DisplayName;

	/** Detailed description of the item shown in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Definition")
	FText Description;

	/** Collection of fragments that define the item's behavior and properties */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Fragments", Instanced)
	TArray<TObjectPtr<UItemFragment>> Fragments;

	/** Tags used to classify or filter this item statically */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Tags")
	FGameplayTagContainer Tags;

#if WITH_EDITORONLY_DATA
	UPROPERTY(Transient)
	TArray<UItemFragment*> PreviousFragments;
#endif
};


############## Public\Definitions\Fragments\ItemFragment.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "ItemFragment.generated.h"

class UItemInstance;

/**
 * @class UItemFragment
 * @see UItemDefinition
 * @brief Represents a fragment of an item definition, allowing definition extension.
 * @details Item fragments are components that can be attached to item definitions to extend their functionality.
 * They are instantiated along with the item instance and can contain both data and behavior.
 */
UCLASS(DefaultToInstanced, EditInlineNew, Blueprintable, BlueprintType, Abstract)
class INVENTORYSYSTEMCORE_API UItemFragment : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Called when the ItemInstance is created and this fragment is attached to it
	 * @param Instance The item instance that owns this fragment
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance)
	{
	}
};


############## Public\Definitions\Fragments\ItemFragment_Consumable.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemFragment.h"

#include "ItemFragment_Consumable.generated.h"

class UGameplayEffect;

/**
 * @class UItemFragment_Consumable
 * @see UItemFragment
 * @brief Fragment that adds consumable behavior to an item
 * @details Allows items to be consumed and apply gameplay effects to the user. 
 * The fragment can be configured with multiple effects and a maximum number of uses.
 */
UCLASS(DisplayName = "Consumable Fragment")
class INVENTORYSYSTEMCORE_API UItemFragment_Consumable : public UItemFragment
{
	GENERATED_BODY()

public:
	/**
	 * Initializes the consumable fragment when the item instance is created
	 * @param Instance The item instance that owns this fragment
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance) override;

	/**
	 * Gameplay effects to apply when the item is consumed
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Consumable")
	TSubclassOf<UGameplayEffect> GameplayEffect = nullptr;

	/**
	 * Maximum number of times this item can be consumed
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Consumable", meta = (ClampMin = 1))
	int32 MaxUsesCount = 1;
};


############## Public\Definitions\Fragments\ItemFragment_Storable.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemFragment.h"
#include "ItemFragment_Storable.generated.h"

/**
 * @enum EItemStorageFlags
 * @brief Enum defining various storage flags for items. These flags can be combined to describe the storage properties of an item.
 */
UENUM(BlueprintType, meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = true))
enum class EItemStorageFlags : uint8
{
	None = 0 UMETA(ToolTip = "No special storage properties.", Hidden),
	Unique = 1 UMETA(ToolTip = "This item should be unique in the inventory. For stacks, only one stack can exist."),
	PersistentOnDeath = 2 UMETA(ToolTip = "The item can't be lost on player death")
};

ENUM_CLASS_FLAGS(EItemStorageFlags);

/**
 * @class UItemFragment_Storable
 * @see UItemFragment
 * @brief UItemFragment_Storable defines storage properties for an item. This fragment can be attached to item definitions to specify how they behave in inventory systems.
 */
UCLASS(DisplayName = "Storable Fragment")
class INVENTORYSYSTEMCORE_API UItemFragment_Storable : public UItemFragment
{
	GENERATED_BODY()

public:
	/** Visual representation of the item in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Appearance")
	FSlateBrush UIBrush;

	/** Determines how many items can be grouped in a single inventory slot. The minimum value is 1 for unstackable items */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (ClampMin = 1))
	int MaxStackCount = 1;

	/** Individual item weight in kilograms. Used for inventory weight calculations. Minimum value is 0 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (ClampMin = 0, Units = "kg"))
	float Weight = 0.f;

	/** Combination of EItemStorageFlags that define special storage behaviors like uniqueness or persistence */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (Bitmask, BitmaskEnum = "/Script/InventorySystemCore.EItemStorageFlags"))
	int32 StorageFlags;

	/**
	 * Checks if this item can be stacked with others of the same type
	 * @return True if the item can be stacked (MaxStackCount > 1), false otherwise
	 */
	UFUNCTION(BlueprintCallable)
	bool CanStack() const;

	/**
	 * Checks if this item is marked as unique in storage
	 * @return True if the item has the Unique storage flag set
	 */
	UFUNCTION(BlueprintCallable)
	bool IsUnique() const;
};


############## Public\GameplayTags\InventoryGameplayTags.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "NativeGameplayTags.h"

namespace InventorySystemGameplayTags
{
	INVENTORYSYSTEMCORE_API FGameplayTag FindTagByString(const FString& TagString, bool bMatchPartialString = false);

	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Container);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Container_Default);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Container_Bag);

	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_ContainerNotFound);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidDefinition);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidCount);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidInstance);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_NotAuthority);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_NotStorable);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_Uniqueness);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_DefinitionRefused);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_Internal);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidComponent);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidContainer);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidHandle);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_HandleMismatch);
	INVENTORYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Inventory_Failure_InvalidIndex);
}


############## Public\Instances\ItemInstance.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ItemComponent.h"
#include "CoreMinimal.h"
#include "Definitions/ItemDefinition.h"
#include "UObject/Object.h"

#include "ItemInstance.generated.h"

struct FInventoryList;

/**
 * @class UItemInstance
 * @see UObject
 * @brief This class represents an instance of an item within the inventory system. It holds a reference
 * to the item definition and provides functionalities related to item management.
 * This class uses a component-based architecture to allow for flexible
 * and efficient item instances. Each instance can have multiple components
 * that add specific functionalities.
 */
UCLASS(BlueprintType, Blueprintable)
class INVENTORYSYSTEMCORE_API UItemInstance : public UObject, public IGameplayTagAssetInterface
{
	GENERATED_BODY()

	friend struct FInventoryList;

public:
	explicit UItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool IsSupportedForNetworking() const override { return true; }
	// ~UObject

	// IGameplayTagAssetInterface
	virtual void GetOwnedGameplayTags(FGameplayTagContainer& TagContainer) const override;
	// ~IGameplayTagAssetInterface

	
	virtual void Initialize(UItemDefinition* InDefinition);
	virtual void Uninitialize();

	
	UFUNCTION(BlueprintCallable, Category="Tags")
	void AddTag(const FGameplayTag Tag) { Tags.AddTag(Tag); }

	UFUNCTION(BlueprintCallable, Category="Tags")
	void RemoveTag(const FGameplayTag Tag) { Tags.RemoveTag(Tag); }

	/**
	 * Gets the inventory system component that owns this item instance
	 * @return The owning inventory system component
	 */
	UFUNCTION(BlueprintCallable, Category = "Instance")
	UInventorySystemComponent* GetInventorySystemComponent() const;

	/**
	 * Gets the actor that owns this item instance
	 * @return The owning actor
	 */
	UFUNCTION(BlueprintCallable, Category = "Instance")
	AActor* GetOwningActor() const;
	/**
	 * Gets the actor cast to the specified type
	 * @return The actor cast to type T, or nullptr if cast fails
	 */
	template <typename T>
	const T* GetOwningActor() const { return Cast<T>(GetOwningActor(T::StaticClass())); }

	/**
	 * Gets the item definition class associated with this instance.
	 * @return The item definition class.
	 */
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UItemDefinition> GetDefinitionClass() const;

	/**
	 * Gets the item definition associated with this instance, cached by the Inventory System Component.
	 * @return The item definition default object.
	 */
	UFUNCTION(BlueprintCallable)
	UItemDefinition* GetDefinition() const;

	/**
	 * Try to find fragment of class FragmentClass in this item's definition
	 * @param FragmentClass Class of the ItemFragment to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UItemFragment* FindFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;
	/**
	 * Try to find fragment of class FragmentClass in this item's definition
	 */
	template <typename T>
	const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	UFUNCTION(BlueprintCallable, BlueprintPure = false)
	bool HasFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;

	/**
	 *	Try to find fragment of class FragmentClass in this item definition
	 *	@param ComponentClass Class of the ItemFragment to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	UItemComponent* AddComponent(TSubclassOf<UItemComponent> ComponentClass);
	/**
	 *	Try to find fragment of class FragmentClass in this item definition
	 */
	template <typename T>
	T* AddComponent() { return Cast<T>(AddComponent(T::StaticClass())); }

	/**
	 *	Try to find component of class ComponentClass of this item instance
	 *	@param ComponentClass Class of the Item Instance's component to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = ComponentClass))
	const UItemComponent* FindComponentByClass(TSubclassOf<UItemComponent> ComponentClass) const;
	/**
	 * Try to find a component of type T attached to this item instance
	 * @return The found component cast to type T, or nullptr if not found or cast fails
	 */
	template <typename T>
	const T* FindComponentByClass() const { return Cast<T*>(FindComponentByClass(T::StaticClass())); }

protected:
	
	virtual void PostInitialize();

	
	/**
	 * Sets the item definition class for this instance.
	 * @param InDefinition - The item definition to set.
	 */
	void SetDefinition(UItemDefinition* InDefinition);

	/** The item definition that this instance is based on.
	 * Only replicate the class.
	 */
	UPROPERTY(Replicated, BlueprintReadOnly, Category="Tags")
	TSubclassOf<UItemDefinition> DefinitionClass;

	/** The Item Definition default object, cached by the local InventorySystemComponent cache */
	UPROPERTY(BlueprintReadOnly, Category="Tags")
	TWeakObjectPtr<UItemDefinition> Definition;

	/** Components attached to this item instance providing additional functionality */
	UPROPERTY(Replicated, BlueprintReadOnly, Category="Tags")
	TArray<UItemComponent*> Components;

	/** Tags used to classify or filter this item statically */
	UPROPERTY(BlueprintReadOnly, Category="Tags")
	FGameplayTagContainer Tags;

	/** Cached pointer to owning inventory system component pawn */
	UPROPERTY(Transient)
	mutable AActor* OwningActor;
};


############## Public\Instances\Components\ItemComponent.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "ItemComponent.generated.h"

class UItemFragment;
class UItemInstance;

/**
 * @class UItemComponent
 * @see UItemInstance
 * @brief Base class for modular components that can be added to item instances.
 * @details This class serves as the foundation for creating specialized components
 * that add specific functionalities to item instances. Components are attached to item
 * instances to extend their capabilities. Each component can implement its own replication
 * logic and functionality while maintaining a modular design approach.
 */
UCLASS(Abstract)
class INVENTORYSYSTEMCORE_API UItemComponent : public UObject
{
	GENERATED_BODY()

public:
	// UObject
	/**
	 * Sets up property replication for the component
	 * @param OutLifetimeProps Array of lifetime properties to be filled with replication properties
	 */
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override
	{
		Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	};
	// ~UObject

	virtual void Initialize(UItemInstance& InInstance, UItemFragment* InSourceFragment = nullptr);
	virtual void PostInitialize() {}
	virtual void Uninitialize() {}

	/**
	 * Returns the item instance that owns this fragment
	 * @return The owning item instance, or nullptr if not attached
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure)
	UItemInstance* GetOwningInstance();	

protected:
	
	/** The item instance that owns this fragment instance */
	UPROPERTY(Transient)
	TObjectPtr<UItemInstance> OwningInstance = nullptr;
	
	/** The item instance that owns this fragment instance */
	UPROPERTY(Transient)
	TObjectPtr<UItemFragment> SourceFragment = nullptr;
};


############## Public\Instances\Components\ItemComponent_Consumable.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemComponent.h"
#include "ItemComponent_Consumable.generated.h"

struct FGameplayEffectContextHandle;
class UGameplayEffect;
class UGameplayAbility;

/**
 * @class UItemComponent_Consumable
 * @see UItemComponent
 * @brief Component for items that can be consumed or used over time.
 * @details This component tracks the usage state of consumable items, such as 
 * potions, food, or other items that can be depleted. It maintains a replicated 
 * current use value that represents the item's consumption progress.
 */
UCLASS()
class INVENTORYSYSTEMCORE_API UItemComponent_Consumable : public UItemComponent
{
	GENERATED_BODY()

	friend class UItemFragment_Consumable;

public:
	
	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// ~UObject

	UFUNCTION(BlueprintCallable, BlueprintPure)
	virtual bool CanConsume(const int32 UseCount = 1) const;

	UFUNCTION(BlueprintCallable)
	virtual void Consume(const int32 UseCount = 1);

	UFUNCTION(BlueprintCallable)
	virtual void SetRemainingUses(const int32 Count = 1);

	UFUNCTION(BlueprintCallable)
	virtual void RestoreUses();
	
protected:
	

	/** Tracks the current usage progress of the consumable item. 0 means unused, higher values indicate usage progress */
	UPROPERTY(Replicated)
	int32 RemainingUses = 0;

	UPROPERTY(Transient)
	int32 MaxUseCount = 0;
	
	UPROPERTY(Transient)
	TSubclassOf<UGameplayEffect> GameplayEffect;
	
	bool ShouldStackEffects = false;
};


############## Public\Interfaces\InventorySystemInterface.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "InventorySystemInterface.generated.h"

class UInventorySystemComponent;

/**
 * @class UInventorySystemInterface
 * @see IInventorySystemInterface
 * @brief Interface class for the Unreal Engine's interface system
 * @details This is the UObject interface declaration required by Unreal Engine.
 * Do not modify this class as it's only used for UObject system registration.
 */
UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UInventorySystemInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * @class IInventorySystemInterface
 * @see UInventorySystemComponent
 * @brief Interface providing access to an actor's inventory system component
 * @details This interface should be implemented by actors that need to expose
 * their inventory system functionality. The component can be owned by the implementing
 * actor or by another actor (e.g., PlayerState owning inventory for its Pawn).
 */
class INVENTORYSYSTEMCORE_API IInventorySystemInterface
{
	GENERATED_BODY()

public:
	/**
	 * Retrieves the inventory system component associated with this actor
	 * @return The inventory system component to use. May be located on another actor
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	virtual UInventorySystemComponent* GetInventorySystemComponent() const = 0;
};


############## Public\Library\InventoryFunctionLibrary.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "InventoryFunctionLibrary.generated.h"

class UItemFragment;
class UItemDefinition;


/**
 * @class UInventoryFunctionLibrary
 * @see UBlueprintFunctionLibrary
 * @brief Function library containing utility functions for the Inventory System.
 * @details Provides helper functions to interact with item definitions and their fragments.
 */
UCLASS()
class INVENTORYSYSTEMCORE_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	/**
	 * Finds a specific fragment in an item definition
	 * @param ItemDef The item definition class to search in
	 * @param FragmentClass The type of fragment to find
	 * @return The found fragment instance, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = FragmentClass))
	static const UItemFragment* FindItemDefinitionFragment(TSubclassOf<UItemDefinition> ItemDef, TSubclassOf<UItemFragment> FragmentClass);
};


############## Public\Log\InventorySystemLog.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogInventorySystem, Log, All);


############## Public\Settings\InventorySystemSettings.h ###############
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "Settings/ItemFragmentRule.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "InventorySystemSettings.generated.h"

/**
 *
 */
UCLASS(config = "GameplayCoreSettings", DefaultConfig, DisplayName = "Inventory")
class INVENTORYSYSTEMCORE_API UInventorySystemSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	// UDeveloperSettings
	virtual FName GetCategoryName() const override { return TEXT("Gameplay"); }
	// ~UDeveloperSettings

#if WITH_EDITOR
	// Try to find the matching rules for the given fragment class
	const FItemFragmentRule* FindRuleForClass(const TSubclassOf<UItemFragment>& FragmentClass) const;
#endif

#if WITH_EDITORONLY_DATA
	// List of rules between fragments
	UPROPERTY(config, EditAnywhere, Category = "Fragment Rules")
	TMap<TSubclassOf<UItemFragment>, FItemFragmentRule> FragmentRules;
#endif

	// TODO : Add item categories
};


############## Public\Settings\ItemFragmentRule.h ###############
// Copyright 2025 TARA Gaming Limited. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "ItemFragmentRule.generated.h"

class UItemFragment;


/**
 * @struct FItemFragmentRule
 * @see UItemFragment
 * @brief Defines rules for validating item fragments in the inventory system.
 * This structure allows specifying blocked and required fragments for validation purposes.
 * It can be used to enforce rules on item composition within the inventory system.
 */
USTRUCT(BlueprintType)
struct FItemFragmentRule
{
	GENERATED_BODY()

	/**
		 * Checks whether the rule is satisfied based on the provided fragment classes.
		 * @param FragmentClasses The array of fragment classes to validate against the rule.
		 * @param ErrorContext A string that will contain details about blocking or missing fragments if the rule is not
		 * satisfied for error context message.
		 * @return True if the rule is satisfied, false otherwise.
		 */
	bool IsRuleSatisfied(const TArray<TSubclassOf<UItemFragment>>& FragmentClasses, FString& ErrorContext) const;

	/**
	 * List of fragment classes that are blocked (cannot coexist with this fragment).
	 */
	UPROPERTY(EditAnywhere)
	TArray<TSubclassOf<UItemFragment>> BlockedFragments;

	/**
	 * List of fragment classes that are required (must be present for this fragment to be valid).
	 */
	UPROPERTY(EditAnywhere)
	TArray<TSubclassOf<UItemFragment>> RequiredFragments;
};

