
--- Source\AbilitySystemCore\AbilitySystemCore.Build.cs ---
﻿using UnrealBuildTool;

public class AbilitySystemCore : ModuleRules
{
	public AbilitySystemCore(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"GameplayAbilities",
				"GameplayTags",
				"GameplayTasks"
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"EnhancedInput"
			}
		);
	}
}
--- Source\AbilitySystemCore\Private\AbilitySystemCore.cpp ---
﻿#include "AbilitySystemCore.h"

#define LOCTEXT_NAMESPACE "FAbilitySystemCoreModule"

void FAbilitySystemCoreModule::StartupModule() {}

void FAbilitySystemCoreModule::ShutdownModule() {}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FAbilitySystemCoreModule, AbilitySystemCore)
--- Source\AbilitySystemCore\Private\AbilitySystemCoreTags.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "AbilitySystemCoreTags.h"

#include "Engine/EngineTypes.h"

namespace AbilitySystemCoreTags
{
	// Activation fail tags

	// Input tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_InputTag, "InputTag", "Root input tag (should only be used for categories or filtering)");

	// Ability Tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_AbilityTag, "AbilityTag", "Root ability tag (should only be used for categories or filtering)");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_AbilityTag_DeathPersistent, "AbilityTag.DeathPersistent", "Tag the ability to be persistent on avatar death");

	// Gameplay tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Gameplay_AbilitiesBlocked, "Gameplay.AbilitiesBlocked", "Block the activation of any ability with input activation policy");

} // namespace AbilitySystemCoreTags
--- Source\AbilitySystemCore\Private\Abilities\GameplayAbilityBase.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Abilities/GameplayAbilityBase.h"

#include "AbilitySystemComponent.h"
#include "Globals/AbilitySystemGlobalsBase.h"

UGameplayAbilityBase::UGameplayAbilityBase(const FObjectInitializer& ObjectInitializer)
{
	ReplicationPolicy = EGameplayAbilityReplicationPolicy::ReplicateNo;
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
	NetExecutionPolicy = EGameplayAbilityNetExecutionPolicy::LocalPredicted;
	NetSecurityPolicy = EGameplayAbilityNetSecurityPolicy::ClientOrServer;

	ActivationPolicy = EAbilityActivationPolicy::OnInputTriggered;
}

void UGameplayAbilityBase::OnAvatarSet(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec)
{
	Super::OnAvatarSet(ActorInfo, Spec);

	// OnAvatarSet being called by Super::OnGiveAbility if it has a valid AvatarActor
	// try to activate the ability
	TryActivateAbilityOnSpawn(ActorInfo, Spec);
}

void UGameplayAbilityBase::OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec)
{
	Super::OnGiveAbility(ActorInfo, Spec);

	// Call blueprint implementation after the ability is given
	K2_OnAbilityGiven();
}

void UGameplayAbilityBase::OnRemoveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec)
{
	// Call blueprint implementation before the ability is removed.
	K2_OnAbilityRemoved();

	Super::OnRemoveAbility(ActorInfo, Spec);
}

void UGameplayAbilityBase::PreActivate(
	const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayAbilityActivationInfo ActivationInfo,
	FOnGameplayAbilityEnded::FDelegate* OnGameplayAbilityEndedDelegate,
	const FGameplayEventData* TriggerEventData)
{
	Super::PreActivate(Handle, ActorInfo, ActivationInfo, OnGameplayAbilityEndedDelegate, TriggerEventData);
}

void UGameplayAbilityBase::ActivateAbility(
	const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayAbilityActivationInfo ActivationInfo,
	const FGameplayEventData* TriggerEventData)
{
	Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);
}

bool UGameplayAbilityBase::CanActivateAbility(
	const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayTagContainer* SourceTags,
	const FGameplayTagContainer* TargetTags,
	FGameplayTagContainer* OptionalRelevantTags) const
{
	return Super::CanActivateAbility(Handle, ActorInfo, SourceTags, TargetTags, OptionalRelevantTags);
}

bool UGameplayAbilityBase::DoesAbilitySatisfyTagRequirements(
	const UAbilitySystemComponent& AbilitySystemComponent,
	const FGameplayTagContainer* SourceTags,
	const FGameplayTagContainer* TargetTags,
	FGameplayTagContainer* OptionalRelevantTags) const
{
	bool bBlocked = false;
	bool bMissing = false;

	const UAbilitySystemGlobalsBase& AbilitySystemGlobals = UAbilitySystemGlobalsBase::Get();
	const FGameplayTag& BlockedTag = AbilitySystemGlobals.ActivateFailTagsBlockedTag;
	const FGameplayTag& MissingTag = AbilitySystemGlobals.ActivateFailTagsMissingTag;

	// Check if any of this ability's tags are currently blocked
	if (AbilitySystemComponent.AreAbilityTagsBlocked(GetAssetTags()))
	{
		bBlocked = true;
	}

	// Check to see the required/blocked tags for this ability
	if (ActivationBlockedTags.Num() || ActivationRequiredTags.Num())
	{
		static FGameplayTagContainer AbilitySystemComponentTags;
		AbilitySystemComponentTags.Reset();

		AbilitySystemComponent.GetOwnedGameplayTags(AbilitySystemComponentTags);
		AbilitySystemComponent.GetBlockedAbilityTags(AbilitySystemComponentTags);

		if (AbilitySystemComponentTags.HasAny(ActivationBlockedTags))
		{
			bBlocked = true;
		}

		if (!AbilitySystemComponentTags.HasAll(ActivationRequiredTags))
		{
			bMissing = true;
		}
	}

	// Check source tags
	if (SourceTags != nullptr)
	{
		if (SourceBlockedTags.Num() || SourceRequiredTags.Num())
		{
			if (SourceTags->HasAny(SourceBlockedTags))
			{
				bBlocked = true;
			}

			if (!SourceTags->HasAll(SourceRequiredTags))
			{
				bMissing = true;
			}
		}
	}

	// Check target tags
	if (TargetTags != nullptr)
	{
		if (TargetBlockedTags.Num() || TargetRequiredTags.Num())
		{
			if (TargetTags->HasAny(TargetBlockedTags))
			{
				bBlocked = true;
			}

			if (!TargetTags->HasAll(TargetRequiredTags))
			{
				bMissing = true;
			}
		}
	}

	// We succeeded if there were no blocked tags and no missing required tags
	return !bBlocked && !bMissing;
}

void UGameplayAbilityBase::EndAbility(
	const FGameplayAbilitySpecHandle Handle,
	const FGameplayAbilityActorInfo* ActorInfo,
	const FGameplayAbilityActivationInfo ActivationInfo,
	const bool bReplicateEndAbility,
	const bool bWasCancelled)
{
	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}

void UGameplayAbilityBase::TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const
{
	const bool bIsPredicting = Spec.GetPrimaryInstance()->GetCurrentActivationInfo().ActivationMode == EGameplayAbilityActivationMode::Predicting;

	// Try to activate if activation policy is OnSpawn.
	if (ActorInfo && !Spec.IsActive() && !bIsPredicting && ActivationPolicy == EAbilityActivationPolicy::OnSpawn)
	{
		UAbilitySystemComponent* AbilitySystemComp = ActorInfo->AbilitySystemComponent.Get();
		const AActor* AvatarActor = ActorInfo->AvatarActor.Get();

		if (IsValid(AbilitySystemComp) && IsValid(AvatarActor))
		{
			// Don't try to activate the ability if the avatar is being destroyed and no longer replicated
			if (!AvatarActor->GetTearOff() && AvatarActor->GetLifeSpan() <= 0.0f)
			{
				// Activate the ability only if we're on the authority
				const bool bIsLocalExecution = NetExecutionPolicy == EGameplayAbilityNetExecutionPolicy::LocalPredicted || NetExecutionPolicy == EGameplayAbilityNetExecutionPolicy::LocalOnly;
				const bool bIsServerExecution = NetExecutionPolicy == EGameplayAbilityNetExecutionPolicy::ServerOnly || NetExecutionPolicy == EGameplayAbilityNetExecutionPolicy::ServerInitiated;

				const bool bClientShouldActivate = ActorInfo->IsLocallyControlled() && bIsLocalExecution;
				const bool bServerShouldActivate = ActorInfo->IsNetAuthority() && bIsServerExecution;

				if (bClientShouldActivate || bServerShouldActivate)
				{
					AbilitySystemComp->TryActivateAbility(Spec.Handle);
				}
			}
		}
	}
}
--- Source\AbilitySystemCore\Private\Animation\AnimInstanceBase.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Animation/AnimInstanceBase.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "Misc/DataValidation.h"

UAnimInstanceBase::UAnimInstanceBase(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

void UAnimInstanceBase::InitializeWithAbilitySystem(UAbilitySystemComponent* AbilitySystemComp)
{
	check(AbilitySystemComp);
	GameplayTagPropertyMap.Initialize(this, AbilitySystemComp);
}

void UAnimInstanceBase::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();

	if (const AActor* OwningActor = GetOwningActor())
	{
		if (UAbilitySystemComponent* AbilitySystemComp = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor); IsValid(AbilitySystemComp))
		{
			InitializeWithAbilitySystem(AbilitySystemComp);
		}
	}
}

float UAnimInstanceBase::CalculateDirection(const FVector& Velocity, const FRotator& BaseRotation)
{
	if (!Velocity.IsNearlyZero())
	{
		const FMatrix RotMatrix = FRotationMatrix(BaseRotation);
		const FVector ForwardVector = RotMatrix.GetScaledAxis(EAxis::X);
		const FVector RightVector = RotMatrix.GetScaledAxis(EAxis::Y);
		const FVector NormalizedVel = Velocity.GetSafeNormal2D();

		// get a cos(alpha) of forward vector vs velocity
		const float ForwardCosAngle = static_cast<float>(FVector::DotProduct(ForwardVector, NormalizedVel));
		// now get the alpha and convert to degree
		float ForwardDeltaDegree = FMath::RadiansToDegrees(FMath::Acos(ForwardCosAngle));

		// depending on where right vector is, flip it
		const float RightCosAngle = static_cast<float>(FVector::DotProduct(RightVector, NormalizedVel));
		if (RightCosAngle < 0.f)
		{
			ForwardDeltaDegree *= -1.f;
		}

		return ForwardDeltaDegree;
	}

	return 0.f;
}

#if WITH_EDITOR
EDataValidationResult UAnimInstanceBase::IsDataValid(FDataValidationContext& Context) const
{
	Super::IsDataValid(Context);

	GameplayTagPropertyMap.IsDataValid(this, Context);

	return Context.GetNumErrors() > 0 ? EDataValidationResult::Invalid : EDataValidationResult::Valid;
}
#endif
--- Source\AbilitySystemCore\Private\Attributes\AttributeSetBase.cpp ---
﻿#include "Attributes/AttributeSetBase.h"

#include "Components/AbilitySystemComponentBase.h"

UAttributeSetBase::UAttributeSetBase(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

UAbilitySystemComponentBase* UAttributeSetBase::GetAbilitySystemComponentBase() const
{
	return Cast<UAbilitySystemComponentBase>(GetOwningAbilitySystemComponent());
}
--- Source\AbilitySystemCore\Private\Components\AbilitySystemComponentBase.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/AbilitySystemComponentBase.h"

#include "Abilities/AbilityActivationPolicy.h"
#include "Abilities/GameplayAbilityBase.h"
#include "AbilitySystemCoreTags.h"

UAbilitySystemComponentBase::UAbilitySystemComponentBase(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

void UAbilitySystemComponentBase::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
}

void UAbilitySystemComponentBase::InitAbilityActorInfo(AActor* InOwnerActor, AActor* InAvatarActor)
{
	if (!IsValid(InOwnerActor))
	{
		return;
	}

	const FGameplayAbilityActorInfo* ActorInfo = AbilityActorInfo.Get();
	if (!ActorInfo)
	{
		return;
	}

	// Check if we have a new pawn avatar
	const bool bHasNewAvatar = Cast<APawn>(InAvatarActor) && InAvatarActor != ActorInfo->AvatarActor;
	Super::InitAbilityActorInfo(InOwnerActor, InAvatarActor);

	// If we get a new pawn as avatar actor, initialize new actor info
	if (bHasNewAvatar)
	{
		InitAbilitiesOnNewActorInfo();
	}
}

void UAbilitySystemComponentBase::NotifyAbilityEnded(const FGameplayAbilitySpecHandle Handle, UGameplayAbility* Ability, const bool bWasCancelled)
{
	Super::NotifyAbilityEnded(Handle, Ability, bWasCancelled);
}

void UAbilitySystemComponentBase::AbilityInputTagPressed(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			if (AbilitySpec.Ability && AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
			{
				InputPressedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.AddUnique(AbilitySpec.Handle);
			}
		}
	}
}

void UAbilitySystemComponentBase::AbilityInputTagReleased(const FGameplayTag& InputTag)
{
	if (InputTag.IsValid())
	{
		for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
		{
			if (AbilitySpec.Ability && AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))
			{
				InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle);
				InputHeldSpecHandles.Remove(AbilitySpec.Handle);
			}
		}
	}
}

void UAbilitySystemComponentBase::ProcessAbilityInput(float DeltaTime, bool bGamePaused)
{
	// Check if abilities input activation is blocked
	if (HasMatchingGameplayTag(AbilitySystemCoreTags::TAG_Gameplay_AbilitiesBlocked))
	{
		ClearAbilityInput();
		return;
	}

	static TArray<FGameplayAbilitySpecHandle> AbilitiesToActivate;
	AbilitiesToActivate.Reset();

	// Process all abilities that activate when the input is held.
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputHeldSpecHandles)
	{
		if (const FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability && !AbilitySpec->IsActive())
			{
				const UGameplayAbilityBase* BaseAbilityCDO = Cast<UGameplayAbilityBase>(AbilitySpec->Ability);
				if (BaseAbilityCDO && BaseAbilityCDO->GetActivationPolicy() == EAbilityActivationPolicy::WhileInputActive)
				{
					AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
				}
			}
		}
	}

	// Process all abilities that had their input pressed this frame.
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputPressedSpecHandles)
	{
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = true;

				if (AbilitySpec->IsActive())
				{
					// Ability is active so pass along the input event.
					AbilitySpecInputPressed(*AbilitySpec);
				}
				else
				{
					const UGameplayAbilityBase* BaseAbilityCDO = Cast<UGameplayAbilityBase>(AbilitySpec->Ability);

					if (BaseAbilityCDO && BaseAbilityCDO->GetActivationPolicy() == EAbilityActivationPolicy::OnInputTriggered)
					{
						AbilitiesToActivate.AddUnique(AbilitySpec->Handle);
					}
				}
			}
		}
	}

	// Try to activate all the abilities that are from presses and holds.
	// We do it all at once so that held inputs don't activate the ability
	// and then also send a input event to the ability because of the press.
	for (const FGameplayAbilitySpecHandle& AbilitySpecHandle : AbilitiesToActivate)
	{
		TryActivateAbility(AbilitySpecHandle);
	}

	// Process all abilities that had their input released this frame.
	for (const FGameplayAbilitySpecHandle& SpecHandle : InputReleasedSpecHandles)
	{
		if (FGameplayAbilitySpec* AbilitySpec = FindAbilitySpecFromHandle(SpecHandle))
		{
			if (AbilitySpec->Ability)
			{
				AbilitySpec->InputPressed = false;

				if (AbilitySpec->IsActive())
				{
					// Ability is active so pass along the input event.
					AbilitySpecInputReleased(*AbilitySpec);
				}
			}
		}
	}

	// Clear the cached ability handles.
	InputPressedSpecHandles.Reset();
	InputReleasedSpecHandles.Reset();
}

void UAbilitySystemComponentBase::ClearAbilityInput()
{
	InputPressedSpecHandles.Reset();
	InputReleasedSpecHandles.Reset();
	InputHeldSpecHandles.Reset();
}

void UAbilitySystemComponentBase::InitAbilitiesOnNewActorInfo()
{
	if ([[maybe_unused]] const FGameplayAbilityActorInfo* ActorInfo = AbilityActorInfo.Get())
	{
		TryActivateAbilitiesOnSpawn();
	}
}

void UAbilitySystemComponentBase::TryActivateAbilitiesOnSpawn()
{
	// Stop from removing ability from the ability system to iterate through the abilities
	ABILITYLIST_SCOPE_LOCK();

	for (const FGameplayAbilitySpec& AbilitySpec : ActivatableAbilities.Items)
	{
		const UGameplayAbilityBase* Ability = CastChecked<UGameplayAbilityBase>(AbilitySpec.Ability);
		Ability->TryActivateAbilityOnSpawn(AbilityActorInfo.Get(), AbilitySpec);
	}
}

void UAbilitySystemComponentBase::AbilitySpecInputPressed(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputPressed(Spec);

	// UE : We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputPress ability task works.
	if (Spec.IsActive())
	{
		FPredictionKey OriginalPredictionKey;
		if (const UGameplayAbility* Instance = Spec.GetPrimaryInstance())
		{
			OriginalPredictionKey = Instance->GetCurrentActivationInfo().GetActivationPredictionKey();
		}

		// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, OriginalPredictionKey);
	}
}

void UAbilitySystemComponentBase::AbilitySpecInputReleased(FGameplayAbilitySpec& Spec)
{
	Super::AbilitySpecInputReleased(Spec);

	// We don't support UGameplayAbility::bReplicateInputDirectly.
	// Use replicated events instead so that the WaitInputRelease ability task works.
	if (Spec.IsActive())
	{
		FPredictionKey OriginalPredictionKey;
		if (const UGameplayAbility* Instance = Spec.GetPrimaryInstance())
		{
			OriginalPredictionKey = Instance->GetCurrentActivationInfo().GetActivationPredictionKey();
		}

		// Invoke the InputReleased event. This is not replicated here. If someone is listening, they may replicate the InputReleased event to the server.
		InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, OriginalPredictionKey);
	}
}
--- Source\AbilitySystemCore\Private\Data\AbilitySet.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/AbilitySet.h"

#include "Abilities/GameplayAbilityBase.h"
#include "Data/AbilitySet_GameplayAbility.h"
#include "Data/AbilitySet_GameplayEffect.h"
#include "Data/AbilitySetHandles.h"
#include "Log/AbilitySystemLog.h"

UAbilitySet::UAbilitySet(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

void UAbilitySet::GiveToAbilitySystem(UAbilitySystemComponent* AbilitySystemComp, FAbilitySetHandles* Handles, UObject* SourceObject) const
{
	check(AbilitySystemComp);
	if (!AbilitySystemComp->IsOwnerActorAuthoritative()) UE_LOG(LogAbilitySystem, Error, TEXT("Must be authoritive to give or take ability sets"));

	// Grant the attribut sets
	for (int Index = 0; Index < AttributeSets.Num(); ++Index)
	{
		const TSubclassOf<UAttributeSet>& AttributeSetClass = AttributeSets[Index];

		UE_CLOG(!IsValid(AttributeSetClass), LogAbilitySystem, Error, TEXT("Attributes[%d] on ability set [%s] is not valid"), Index, *GetNameSafe(this));

		UAttributeSet* AttributeSet = NewObject<UAttributeSet>(AbilitySystemComp, AttributeSetClass);
		AbilitySystemComp->AddAttributeSetSubobject(AttributeSet);

		if (Handles)
		{
			Handles->AddAttributeSet(AttributeSet);
		}
	}

	// Grant the gameplay abilities
	for (int Index = 0; Index < GameplayAbilities.Num(); ++Index)
	{
		const FAbilitySet_GameplayAbility& GameplayAbilitySet = GameplayAbilities[Index];

		UE_CLOG(!IsValid(GameplayAbilitySet.Ability), LogAbilitySystem, Error, TEXT("Attributes[%d] on ability set [%s] is not valid"), Index, *GetNameSafe(this));

		UGameplayAbilityBase* AbilityCDO = GameplayAbilitySet.Ability->GetDefaultObject<UGameplayAbilityBase>();

		FGameplayAbilitySpec AbilitySpec(AbilityCDO, GameplayAbilitySet.AbilityLevel);
		AbilitySpec.SourceObject = SourceObject;
		AbilitySpec.GetDynamicSpecSourceTags().AddTag(GameplayAbilitySet.InputTag);

		const FGameplayAbilitySpecHandle AbilitySpecHandle = AbilitySystemComp->GiveAbility(AbilitySpec);

		if (Handles)
		{
			Handles->AddAbilitySpecHandle(AbilitySpecHandle);
		}
	}

	// Grant the gameplay effects.
	for (int32 Index = 0; Index < GameplayEffects.Num(); ++Index)
	{
		const FAbilitySet_GameplayEffect& GameplayEffectSet = GameplayEffects[Index];

		UE_CLOG(!IsValid(GameplayEffectSet.GameplayEffect), LogAbilitySystem, Error, TEXT("Attributes[%d] on ability set [%s] is not valid"), Index, *GetNameSafe(this));

		const UGameplayEffect* GameplayEffect = GameplayEffectSet.GameplayEffect->GetDefaultObject<UGameplayEffect>();
		const FActiveGameplayEffectHandle GameplayEffectHandle = AbilitySystemComp->ApplyGameplayEffectToSelf(GameplayEffect, GameplayEffectSet.EffectLevel, AbilitySystemComp->MakeEffectContext());

		if (Handles)
		{
			Handles->AddGameplayEffectHandle(GameplayEffectHandle);
		}
	}
}
--- Source\AbilitySystemCore\Private\Data\AbilitySetHandles.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/AbilitySetHandles.h"

#include "Data/AbilitySet.h"

void FAbilitySetHandles::AddAbilitySpecHandle(const FGameplayAbilitySpecHandle& Handle)
{
	if (Handle.IsValid())
	{
		AbilitySpecHandles.Add(Handle);
	}
}

void FAbilitySetHandles::AddGameplayEffectHandle(const FActiveGameplayEffectHandle& Handle)
{
	if (Handle.IsValid())
	{
		GameplayEffectHandles.Add(Handle);
	}
}

void FAbilitySetHandles::AddAttributeSet(UAttributeSet* Set)
{
	GrantedAttributeSets.Add(Set);
}

void FAbilitySetHandles::TakeFromAbilitySystem(UAbilitySystemComponent* AbilitySystemComp)
{
	check(AbilitySystemComp);
	ensure(!AbilitySystemComp->IsOwnerActorAuthoritative());

	for (const FGameplayAbilitySpecHandle& Handle : AbilitySpecHandles)
	{
		if (Handle.IsValid())
		{
			AbilitySystemComp->ClearAbility(Handle);
		}
	}

	for (const FActiveGameplayEffectHandle& Handle : GameplayEffectHandles)
	{
		if (Handle.IsValid())
		{
			AbilitySystemComp->RemoveActiveGameplayEffect(Handle);
		}
	}

	for (UAttributeSet* Set : GrantedAttributeSets)
	{
		AbilitySystemComp->RemoveSpawnedAttribute(Set);
	}

	AbilitySpecHandles.Reset();
	GameplayEffectHandles.Reset();
	GrantedAttributeSets.Reset();
}
--- Source\AbilitySystemCore\Private\GameplayTags\GameplayTagPropertyMap.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "GameplayTags/GameplayTagPropertyMap.h"

#include "AbilitySystemComponent.h"
#include "Log/AbilitySystemLog.h"
#include "Misc/DataValidation.h"

FGameplayTagPropertyMap::FGameplayTagPropertyMap() {}

FGameplayTagPropertyMap::FGameplayTagPropertyMap(const FGameplayTagPropertyMap& Other)
{
	ensureMsgf(Other.CachedOwner.IsExplicitlyNull(), TEXT("FGameplayTagBlueprintPropertyMap cannot be used inside an array or other container that is copied after register!"));
	PropertyMappings = Other.PropertyMappings;
}

FGameplayTagPropertyMap::~FGameplayTagPropertyMap()
{
	Unregister();
}

void FGameplayTagPropertyMap::Initialize(UObject* Owner, UAbilitySystemComponent* AbilitySystemComp)
{
	const UClass* OwnerClass = Owner ? Owner->GetClass() : nullptr;
	if (!OwnerClass)
	{
		UE_LOG(LogAbilitySystem, Error, TEXT("FGameplayTagPropertyMap: Initialize() called with an invalid Owner."));
		return;
	}

	if (!AbilitySystemComp)
	{
		UE_LOG(LogAbilitySystem, Error, TEXT("FGameplayTagPropertyMap: Initialize() called with an invalid AbilitySystemComponent."));
		return;
	}

	if (CachedOwner == Owner && CachedAbilitySystemComponent == AbilitySystemComp)
	{
		// Already initialized.
		return;
	}

	if (CachedOwner.IsValid())
	{
		Unregister();
	}

	// Cache
	CachedOwner = Owner;
	CachedAbilitySystemComponent = AbilitySystemComp;

	const FOnGameplayEffectTagCountChanged::FDelegate Delegate = FOnGameplayEffectTagCountChanged::FDelegate::CreateRaw(this, &FGameplayTagPropertyMap::GameplayTagEventCallback, CachedOwner);

	// Process array starting at the end so we can remove invalid entries.
	for (int32 MappingIndex = PropertyMappings.Num() - 1; MappingIndex >= 0; --MappingIndex)
	{
		FGameplayTagBlueprintPropertyMapping& Mapping = PropertyMappings[MappingIndex];

		if (Mapping.TagToMap.IsValid())
		{
			FProperty* Property = OwnerClass->FindPropertyByName(Mapping.PropertyName);
			if (Property && IsPropertyTypeValid(Property))
			{
				Mapping.PropertyToEdit = Property;
				Mapping.DelegateHandle = AbilitySystemComp->RegisterAndCallGameplayTagEvent(Mapping.TagToMap, Delegate, GetGameplayTagEventType(Property));
				continue;
			}
		}

		// Entry was invalid.  Remove it from the array.
		UE_LOG(
			LogAbilitySystem,
			Error,
			TEXT("FGameplayTagPropertyMap: Removing invalid GameplayTagBlueprintPropertyMapping [Index: %d, Tag:%s, Property:%s] for [%s]."),
			MappingIndex,
			*Mapping.TagToMap.ToString(),
			*Mapping.PropertyName.ToString(),
			*GetNameSafe(Owner));

		PropertyMappings.RemoveAtSwap(MappingIndex, EAllowShrinking::No);
	}
}

void FGameplayTagPropertyMap::ApplyCurrentTags()
{
	UObject* Owner = CachedOwner.Get();
	if (!Owner)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::ApplyCurrentTags called with an invalid Owner."));
		return;
	}

	const UAbilitySystemComponent* AbilitySystemComp = CachedAbilitySystemComponent.Get();
	if (!AbilitySystemComp)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::ApplyCurrentTags called with an invalid AbilitySystemComponent."));
		return;
	}

	// Property mapping
	for (FGameplayTagBlueprintPropertyMapping& Mapping : PropertyMappings)
	{
		if (Mapping.PropertyToEdit.Get() && Mapping.TagToMap.IsValid())
		{
			int32 NewCount = AbilitySystemComp->GetTagCount(Mapping.TagToMap);

			if (const FBoolProperty* BoolProperty = CastField<const FBoolProperty>(Mapping.PropertyToEdit.Get()))
			{
				BoolProperty->SetPropertyValue_InContainer(Owner, NewCount > 0);
			}
			else if (const FIntProperty* IntProperty = CastField<const FIntProperty>(Mapping.PropertyToEdit.Get()))
			{
				IntProperty->SetPropertyValue_InContainer(Owner, NewCount);
			}
			else if (const FFloatProperty* FloatProperty = CastField<const FFloatProperty>(Mapping.PropertyToEdit.Get()))
			{
				FloatProperty->SetPropertyValue_InContainer(Owner, static_cast<float>(NewCount));
			}
		}
	}
}

void FGameplayTagPropertyMap::AddTag(const FGameplayTag& Tag, const FName& PropertyName)
{
	const UObject* Owner = CachedOwner.Get();
	if (!Owner)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::AddTag called with an invalid Owner."));
		return;
	}

	const UClass* OwnerClass = Owner->GetClass();

	UAbilitySystemComponent* AbilitySystemComp = CachedAbilitySystemComponent.Get();
	if (!AbilitySystemComp)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::AddTag called with an invalid AbilitySystemComponent."));
		return;
	}

	FProperty* Property = OwnerClass->FindPropertyByName(PropertyName);
	if (!Property || !IsPropertyTypeValid(Property))
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::AddTag called with an invalid property."));
		return;
	}

	if (!Tag.IsValid())
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagPropertyMap::AddTag called with an invalid gameplay tag."));
		return;
	}

	const FOnGameplayEffectTagCountChanged::FDelegate Delegate = FOnGameplayEffectTagCountChanged::FDelegate::CreateRaw(this, &FGameplayTagPropertyMap::GameplayTagEventCallback, CachedOwner);

	FGameplayTagBlueprintPropertyMapping Mapping;
	Mapping.TagToMap = Tag;
	Mapping.PropertyToEdit = Property;
	Mapping.PropertyName = PropertyName;
	Mapping.DelegateHandle = AbilitySystemComp->RegisterAndCallGameplayTagEvent(Tag, Delegate, GetGameplayTagEventType(Property));

	// Add the mapping to the map to be able to apply it manually
	PropertyMappings.Add(Mapping);
}

void FGameplayTagPropertyMap::Unregister()
{
	// Unregister all delegates for each gameplay tags
	if (UAbilitySystemComponent* AbilitySystemComp = CachedAbilitySystemComponent.Get())
	{
		for (FGameplayTagBlueprintPropertyMapping& Mapping : PropertyMappings)
		{
			if (Mapping.PropertyToEdit.Get() && Mapping.TagToMap.IsValid())
			{
				AbilitySystemComp->UnregisterGameplayTagEvent(Mapping.DelegateHandle, Mapping.TagToMap, GetGameplayTagEventType(Mapping.PropertyToEdit.Get()));
			}

			Mapping.PropertyToEdit = nullptr;
			Mapping.DelegateHandle.Reset();
		}
	}

	CachedOwner = nullptr;
	CachedAbilitySystemComponent = nullptr;
}

void FGameplayTagPropertyMap::GameplayTagEventCallback(const FGameplayTag Tag, const int32 NewCount, const TWeakObjectPtr<> RegisteredOwner)
{
	// If the index and serial don't match with registered owner, the memory might be trashed so abort
	if (!ensure(RegisteredOwner.HasSameIndexAndSerialNumber(CachedOwner)))
	{
		UE_LOG(LogAbilitySystem, Error, TEXT("FGameplayTagBlueprintPropertyMap::GameplayTagEventCallback called with corrupted Owner!"));
		return;
	}

	UObject* Owner = CachedOwner.Get();
	if (!Owner)
	{
		UE_LOG(LogAbilitySystem, Warning, TEXT("FGameplayTagBlueprintPropertyMap::GameplayTagEventCallback has an invalid Owner."));
		return;
	}

	// Find the property mapping corresponding to the given gameplay tag.
	const FGameplayTagBlueprintPropertyMapping* Mapping = PropertyMappings.FindByPredicate([Tag](const FGameplayTagBlueprintPropertyMapping& Test) { return Tag == Test.TagToMap; });

	// If found, update the bound property
	if (Mapping && Mapping->PropertyToEdit.Get())
	{
		if (const FBoolProperty* BoolProperty = CastField<const FBoolProperty>(Mapping->PropertyToEdit.Get()))
		{
			BoolProperty->SetPropertyValue_InContainer(Owner, NewCount > 0);
		}
		else if (const FIntProperty* IntProperty = CastField<const FIntProperty>(Mapping->PropertyToEdit.Get()))
		{
			IntProperty->SetPropertyValue_InContainer(Owner, NewCount);
		}
		else if (const FFloatProperty* FloatProperty = CastField<const FFloatProperty>(Mapping->PropertyToEdit.Get()))
		{
			FloatProperty->SetPropertyValue_InContainer(Owner, static_cast<float>(NewCount));
		}
	}
}

bool FGameplayTagPropertyMap::IsPropertyTypeValid(const FProperty* Property)
{
	check(Property);
	return Property->IsA<FBoolProperty>() || Property->IsA<FIntProperty>() || Property->IsA<FFloatProperty>();
}

EGameplayTagEventType::Type FGameplayTagPropertyMap::GetGameplayTagEventType(const FProperty* Property)
{
	check(Property);
	return Property->IsA(FBoolProperty::StaticClass()) ? EGameplayTagEventType::NewOrRemoved : EGameplayTagEventType::AnyCountChange;
}

EDataValidationResult FGameplayTagPropertyMap::IsDataValid(const UObject* OwningAsset, FDataValidationContext& Context) const
{
	const UClass* OwnerClass = OwningAsset != nullptr ? OwningAsset->GetClass() : nullptr;
	if (!OwnerClass)
	{
		UE_LOG(LogAbilitySystem, Error, TEXT("FGameplayTagBlueprintPropertyMap: IsDataValid() called with an invalid Owner."));
		return EDataValidationResult::Invalid;
	}

	for (const FGameplayTagBlueprintPropertyMapping& Mapping : PropertyMappings)
	{
		if (!Mapping.TagToMap.IsValid())
		{
			Context.AddError(
				FText::Format(FText::FromString("The gameplay tag [{0}] for property [{1}] is empty or invalid."), FText::AsCultureInvariant(Mapping.TagToMap.ToString()), FText::FromName(Mapping.PropertyName)));
		}

		if (const FProperty* Property = OwnerClass->FindPropertyByName(Mapping.PropertyName))
		{
			if (!IsPropertyTypeValid(Property))
			{
				Context.AddError(
					FText::Format(
						FText::FromString("The property [{0}] for gameplay tag [{1}] is not a supported type.  Supported types are: integer, float, and boolean."),
						FText::FromName(Mapping.PropertyName),
						FText::AsCultureInvariant(Mapping.TagToMap.ToString())));
			}
		}
		else
		{
			Context.AddError(
				FText::Format(FText::FromString("The property [{0}] for gameplay tag [{1}] could not be found."), FText::FromName(Mapping.PropertyName), FText::AsCultureInvariant(Mapping.TagToMap.ToString())));
		}
	}

	return Context.GetNumErrors() > 0 ? EDataValidationResult::Invalid : EDataValidationResult::Valid;
}
--- Source\AbilitySystemCore\Private\Globals\AbilitySystemGlobalsBase.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Globals/AbilitySystemGlobalsBase.h"

void UAbilitySystemGlobalsBase::InitGlobalTags()
{
	Super::InitGlobalTags();
}
--- Source\AbilitySystemCore\Private\Input\InputConfig.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Input/InputConfig.h"
#include "Input/InputTagSet.h"

#include "Log/AbilitySystemLog.h"

UInputConfig::UInputConfig(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

const UInputAction* UInputConfig::FindInputActionForTag(const FGameplayTag& Tag, bool bLogNotFound) const
{
	for (const auto& [InputAction, InputTag] : InputTagSets)
	{
		if (InputAction && InputTag == Tag)
		{
			return InputAction;
		}
	}

	UE_LOG(LogAbilitySystem, Error, TEXT("Can't find InputAction matching InputTag [%s] on InputConfig [%s]."), *Tag.ToString(), *GetNameSafe(this));
	return nullptr;
}
--- Source\AbilitySystemCore\Private\Log\AbilitySystemLog.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Log/AbilitySystemLog.h"

DEFINE_LOG_CATEGORY(LogAbilitySystem);
--- Source\AbilitySystemCore\Public\AbilitySystemCore.h ---
﻿#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FAbilitySystemCoreModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
--- Source\AbilitySystemCore\Public\AbilitySystemCoreTags.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "NativeGameplayTags.h"

namespace AbilitySystemCoreTags
{
	ABILITYSYSTEMCORE_API FGameplayTag FindTagByString(const FString& TagString, bool bMatchPartialString = false);

	// Declare all of the custom native tags that the plugin will use
	ABILITYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_InputTag);

	ABILITYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_AbilityTag);

	ABILITYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_AbilityTag_DeathPersistent);
	// Gameplay tags
	ABILITYSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_AbilitiesBlocked);
} // namespace AbilitySystemCoreTags
--- Source\AbilitySystemCore\Public\Abilities\AbilityActivationPolicy.h ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

/**
 *
 */
UENUM(BlueprintType)
enum class EAbilityActivationPolicy : uint8
{
	// Try to activate the ability when the input is triggered.
	OnInputTriggered,

	// Continually try to activate the ability while the input is active.
	WhileInputActive,

	// Try to activate the ability when an GameplayEvent with a specific tag is triggered.
	OnGameplayEvent,

	// Try to activate the ability by tag.
	ByTag,

	// Try to activate the ability when an avatar is assigned.
	OnSpawn
};
--- Source\AbilitySystemCore\Public\Abilities\GameplayAbilityBase.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Abilities/GameplayAbility.h"
#include "AbilityActivationPolicy.h"
#include "CoreMinimal.h"

#include "GameplayAbilityBase.generated.h"

/**
 * UGameplayAbilityBase
 *
 * Abilities define custom game logic that can be activated by players or by external game logic.
 */
UCLASS(Abstract, Blueprintable)
class ABILITYSYSTEMCORE_API UGameplayAbilityBase : public UGameplayAbility
{
	GENERATED_BODY()

	friend class UAbilitySystemComponentBase;

public:
	explicit UGameplayAbilityBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Gets the activation policy for this ability.
	 * @return The activation policy.
	 */
	UFUNCTION(BlueprintCallable, Category = "Ability")
	EAbilityActivationPolicy GetActivationPolicy() const { return ActivationPolicy; }

protected:
	// UGameplayAbility
	virtual void OnAvatarSet(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
	virtual void OnGiveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
	virtual void OnRemoveAbility(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) override;
	virtual void PreActivate(
		const FGameplayAbilitySpecHandle Handle,
		const FGameplayAbilityActorInfo* ActorInfo,
		const FGameplayAbilityActivationInfo ActivationInfo,
		FOnGameplayAbilityEnded::FDelegate* OnGameplayAbilityEndedDelegate,
		const FGameplayEventData* TriggerEventData) override;
	virtual void ActivateAbility(
		const FGameplayAbilitySpecHandle Handle,
		const FGameplayAbilityActorInfo* ActorInfo,
		const FGameplayAbilityActivationInfo ActivationInfo,
		const FGameplayEventData* TriggerEventData) override;
	[[nodiscard]] virtual bool CanActivateAbility(
		const FGameplayAbilitySpecHandle Handle,
		const FGameplayAbilityActorInfo* ActorInfo,
		const FGameplayTagContainer* SourceTags,
		const FGameplayTagContainer* TargetTags,
		FGameplayTagContainer* OptionalRelevantTags) const override;
	virtual bool DoesAbilitySatisfyTagRequirements(
		const UAbilitySystemComponent& AbilitySystemComponent,
		const FGameplayTagContainer* SourceTags,
		const FGameplayTagContainer* TargetTags,
		FGameplayTagContainer* OptionalRelevantTags) const override;
	virtual void EndAbility(
		const FGameplayAbilitySpecHandle Handle,
		const FGameplayAbilityActorInfo* ActorInfo,
		const FGameplayAbilityActivationInfo ActivationInfo,
		bool bReplicateEndAbility,
		bool bWasCancelled) override;
	// ~UGameplayAbility

	/**
	 * Called when this ability is granted to the ability system component.
	 * Can be implemented in Blueprints.
	 */
	UFUNCTION(BlueprintImplementableEvent, Category = "Ability", DisplayName = "OnAbilityAdded")
	void K2_OnAbilityGiven();

	/**
	 * Called when this ability is removed from the ability system component.
	 * Can be implemented in Blueprints.
	 */
	UFUNCTION(BlueprintImplementableEvent, Category = "Ability", DisplayName = "OnAbilityRemoved")
	void K2_OnAbilityRemoved();

	/** Defines how the ability is supposed to be activated. */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Activation")
	EAbilityActivationPolicy ActivationPolicy;

	/** Tries to activate the ability when it spawns. */
	void TryActivateAbilityOnSpawn(const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilitySpec& Spec) const;
};
--- Source\AbilitySystemCore\Public\Animation\AnimInstanceBase.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Animation/AnimInstance.h"
#include "CoreMinimal.h"
#include "GameplayEffectTypes.h"
#include "GameplayTags/GameplayTagPropertyMap.h"
#include "AnimInstanceBase.generated.h"

/**
 *
 */
UCLASS()
class ABILITYSYSTEMCORE_API UAnimInstanceBase : public UAnimInstance
{
	GENERATED_BODY()

public:
	UAnimInstanceBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	virtual void InitializeWithAbilitySystem(UAbilitySystemComponent* AbilitySystemComp);

protected:
	virtual void NativeInitializeAnimation() override;

	static float CalculateDirection(const FVector& Velocity, const FRotator& BaseRotation);

	#if WITH_EDITOR
	virtual EDataValidationResult IsDataValid(FDataValidationContext& Context) const override;
	#endif

	/* Gameplay tags that can be mapped to blueprint variables.
	 * The variables will automatically update as the tags are added or removed.
	 * These should be used instead of manually querying for the gameplay tags.
	 */
	UPROPERTY(EditDefaultsOnly, Category = "GameplayTags")
	FGameplayTagPropertyMap GameplayTagPropertyMap;
};
--- Source\AbilitySystemCore\Public\Attributes\AttributeSetBase.h ---
﻿#pragma once

#include "AttributeSet.h"

#include "AttributeSetBase.generated.h"

class AActor;
class UObject;
class UWorld;
class UAbilitySystemComponentBase;
struct FGameplayEffectSpec;

/**
 * This macro defines a set of helper functions for accessing and initializing attributes.
 *
 * The following example of the macro:
 *		ATTRIBUTE_ACCESSORS(ULyraHealthSet, Health)
 * will create the following functions:
 *		static FGameplayAttribute GetHealthAttribute();
 *		float GetHealth() const;
 *		void SetHealth(float NewVal);
 *		void InitHealth(float NewVal);
 */
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName)           \
	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName)               \
	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName)               \
	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

/**
 * Delegate used to broadcast attribute events, some of these parameters may be null on clients:
 * @param EffectInstigator	The original instigating actor for this event
 * @param EffectCauser		The physical actor that caused the change
 * @param EffectSpec		The full effect spec for this change
 * @param EffectMagnitude	The raw magnitude, this is before clamping
 * @param OldValue			The value of the attribute before it was changed
 * @param NewValue			The value after it was changed
 */
DECLARE_MULTICAST_DELEGATE_SixParams(FAttributeEvent, AActor* /*EffectInstigator*/, AActor* /*EffectCauser*/, const FGameplayEffectSpec* /*EffectSpec*/, float /*EffectMagnitude*/, float /*OldValue*/, float /*NewValue*/);

/**
 *
 */
UCLASS()
class ABILITYSYSTEMCORE_API UAttributeSetBase : public UAttributeSet
{
	GENERATED_BODY()

public:
	UAttributeSetBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	UAbilitySystemComponentBase* GetAbilitySystemComponentBase() const;
};
--- Source\AbilitySystemCore\Public\Components\AbilitySystemComponentBase.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "AbilitySystemComponent.h"
#include "Components/ActorComponent.h"
#include "CoreMinimal.h"

#include "AbilitySystemComponentBase.generated.h"

/**
 * @class UAbilitySystemComponentBase
 * @see UAbilitySystemComponent
 * @brief This class extends the base UAbilitySystemComponent to provide additional functionality.
 */
UCLASS(BlueprintType, ClassGroup = "Abilities", meta = (BlueprintSpawnableComponent))
class ABILITYSYSTEMCORE_API UAbilitySystemComponentBase : public UAbilitySystemComponent
{
	GENERATED_BODY()

	friend class UGameplayAbilityBase;

public:
	UAbilitySystemComponentBase(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UActorComponent
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// ~UActorComponent

	// UAbilitySystemComponent
	/**
	 *	Initialized the Abilities' ActorInfo - the structure that holds information about who we are acting on and who controls us.
	 *      OwnerActor is the actor that logically owns this component.
	 *		AvatarActor is what physical actor in the world we are acting on. Usually a Pawn but it could be a Tower, Building, Turret, etc, may be the same as Owner
	 */
	virtual void InitAbilityActorInfo(AActor* InOwnerActor, AActor* InAvatarActor) override;
	/** Called from the ability to let the component know it is ended */
	virtual void NotifyAbilityEnded(FGameplayAbilitySpecHandle Handle, UGameplayAbility* Ability, bool bWasCancelled) override;
	// ~UAbilitySystemComponent

	/**
	 * Handles the pressing of an ability input tag.
	 * @param InputTag The input tag that was pressed.
	 */
	void AbilityInputTagPressed(const FGameplayTag& InputTag);
	/**
	 * Handles the release of an ability input tag.
	 * @param InputTag The input tag that was released.
	 */
	void AbilityInputTagReleased(const FGameplayTag& InputTag);

	/**
	 * Processes ability input.
	 * @param DeltaTime The time since the last frame.
	 * @param bGamePaused Whether the game is paused.
	 */
	void ProcessAbilityInput(float DeltaTime, bool bGamePaused);

	/** Clears all ability input. */
	void ClearAbilityInput();

protected:
	/** Initializes abilities when a new actor info is set. */
	void InitAbilitiesOnNewActorInfo();

	/** Tries to activate abilities on spawn. Applicable if the activation policy of the ability is EAbilityActivationPolicy::OnSpawn*/
	void TryActivateAbilitiesOnSpawn();

	/**
	 * Handles when an ability spec input is pressed.
	 * @param Spec The ability spec that had its input pressed.
	 */
	virtual void AbilitySpecInputPressed(FGameplayAbilitySpec& Spec) override;
	/**
	 * Handles when an ability spec input is released.
	 * @param Spec The ability spec that had its input released.
	 */
	virtual void AbilitySpecInputReleased(FGameplayAbilitySpec& Spec) override;

	/** Handles to abilities that had their input pressed this frame. */
	TArray<FGameplayAbilitySpecHandle> InputPressedSpecHandles;

	/** Handles to abilities that had their input released this frame. */
	TArray<FGameplayAbilitySpecHandle> InputReleasedSpecHandles;

	/** Handles to abilities that have their input held. */
	TArray<FGameplayAbilitySpecHandle> InputHeldSpecHandles;
};
--- Source\AbilitySystemCore\Public\Data\AbilitySet.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "AbilitySetHandles.h"
#include "AbilitySystemComponent.h"
#include "CoreMinimal.h"

#include "AbilitySet.generated.h"

struct FAbilitySet_GameplayAbility;
struct FAbilitySet_GameplayEffect;
struct FAbilitySet_AttributeSet;

/**
 *	UAbilitySet
 *
 *	Non-mutable data asset used to grant gameplay abilities, gameplay effects and attributes.
 */
UCLASS(BlueprintType, Const)
class ABILITYSYSTEMCORE_API UAbilitySet : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	UAbilitySet(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Grants the ability set to the specified ability system component.
	 * The returned handles can be used later to take away anything that was granted.
	 */
	void GiveToAbilitySystem(UAbilitySystemComponent* AbilitySystemComp, FAbilitySetHandles* Handles, UObject* SourceObject = nullptr) const;

protected:
	/** Gameplay abilities to grant when this ability set is given. */
	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Abilities", meta = (TitleProperty = "Ability"))
	TArray<FAbilitySet_GameplayAbility> GameplayAbilities;

	/** Gameplay effects to grant when this ability set is granted. */
	UPROPERTY(EditDefaultsOnly, Category = "Gameplay Effects", meta = (TitleProperty = "Gameplay Effect"))
	TArray<FAbilitySet_GameplayEffect> GameplayEffects;

	/** Attribute sets to grant when this ability set is granted. */
	UPROPERTY(EditDefaultsOnly, Category = "Attribute Sets", meta = (TitleProperty = "Attribute Set"))
	TArray<TSubclassOf<UAttributeSet>> AttributeSets;
};
--- Source\AbilitySystemCore\Public\Data\AbilitySetHandles.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "ActiveGameplayEffectHandle.h"
#include "AttributeSet.h"
#include "GameplayAbilitySpecHandle.h"

#include "AbilitySetHandles.generated.h"

/**
 * FAbilitySetHandles
 *
 *	Data used to store handles to what has been granted by the ability set.
 */
USTRUCT(BlueprintType)
struct ABILITYSYSTEMCORE_API FAbilitySetHandles
{
	GENERATED_BODY()

	/**
	 * Adds a gameplay ability spec handle to the set.
	 * @param Handle The gameplay ability spec handle to add.
	 */
	void AddAbilitySpecHandle(const FGameplayAbilitySpecHandle& Handle);
	/**
	 * Adds a gameplay effect handle to the set.
	 * @param Handle The gameplay effect handle to add.
	 */
	void AddGameplayEffectHandle(const FActiveGameplayEffectHandle& Handle);
	/**
	 * Adds an attribute set to the granted sets.
	 * @param Set The attribute set to add.
	 */
	void AddAttributeSet(UAttributeSet* Set);

	/**
	 * Removes all granted abilities, effects, and attributes from the given ability system component.
	 * @param AbilitySystemComp The ability system component to remove granted items from.
	 */
	void TakeFromAbilitySystem(UAbilitySystemComponent* AbilitySystemComp);

protected:
	/** Handles to the granted abilities. */
	UPROPERTY()
	TArray<FGameplayAbilitySpecHandle> AbilitySpecHandles;

	/** Handles to the granted gameplay effects. */
	UPROPERTY()
	TArray<FActiveGameplayEffectHandle> GameplayEffectHandles;

	/** Pointers to the granted attribute sets. */
	UPROPERTY()
	TArray<TObjectPtr<UAttributeSet>> GrantedAttributeSets;
};
--- Source\AbilitySystemCore\Public\Data\AbilitySet_GameplayAbility.h ---
﻿#pragma once

#include "GameplayTagContainer.h"
#include "AbilitySet_GameplayAbility.generated.h"

class UGameplayAbilityBase;

/**
 * FAbilitySet_GameplayAbility
 *
 *	Data used by the ability set to grant gameplay abilities.
 */
USTRUCT(BlueprintType)
struct FAbilitySet_GameplayAbility
{
	GENERATED_BODY()

	// Gameplay ability to grant.
	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<UGameplayAbilityBase> Ability = nullptr;

	// Level of ability to grant.
	UPROPERTY(EditDefaultsOnly)
	int32 AbilityLevel = 1;

	// Tag used to process input for the ability.
	UPROPERTY(EditDefaultsOnly, Meta = (Categories = "InputTag"))
	FGameplayTag InputTag;
};
--- Source\AbilitySystemCore\Public\Data\AbilitySet_GameplayEffect.h ---
﻿#pragma once

#include "GameplayEffect.h"

#include "AbilitySet_GameplayEffect.generated.h"

/**
 * FAbilitySet_GameplayEffect
 *
 *	Data used by the ability set to grant gameplay effects.
 */
USTRUCT(BlueprintType)
struct FAbilitySet_GameplayEffect
{
	GENERATED_BODY()

	// Gameplay effect to grant.
	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<UGameplayEffect> GameplayEffect = nullptr;

	// Level of gameplay effect to grant.
	UPROPERTY(EditDefaultsOnly)
	float EffectLevel = 1.0f;
};
--- Source\AbilitySystemCore\Public\GameplayTags\GameplayTagPropertyMap.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayEffectTypes.h"

#include "GameplayTagPropertyMap.generated.h"

/**
 * @class FGameplayTagPropertyMap
 *
 * @brief Struct used to manage gameplay tag blueprint property mappings.
 * It registers the properties with delegates on an ability system component.
 * This struct can not be used in containers (such as TArray) since it uses a raw pointer
 * to bind the delegate and it's address could change causing an invalid binding.
 */
USTRUCT()
struct ABILITYSYSTEMCORE_API FGameplayTagPropertyMap
{
	GENERATED_BODY()

	FGameplayTagPropertyMap();
	FGameplayTagPropertyMap(const FGameplayTagPropertyMap& Other);
	~FGameplayTagPropertyMap();

	/** Call this to initialize and bind the properties with the ability system component. */
	void Initialize(UObject* Owner, UAbilitySystemComponent* AbilitySystemComp);

	/** Call to manually apply the current tag state, can handle cases where callbacks were skipped */
	void ApplyCurrentTags();

	/** Bind the give class property (bool, int or float) to the GameplayTag.
	 * @param Tag Gameplay tag to listen
	 * @param PropertyName FName of the property to bind. Use GET_MEMBER_NAME_CHECKED macro for that
	 */
	void AddTag(const FGameplayTag& Tag, const FName& PropertyName);

	#if WITH_EDITOR
	/** This can optionally be called in the owner's IsDataValid() for data validation. */
	EDataValidationResult IsDataValid(const UObject* ContainingAsset, FDataValidationContext& Context) const;
	#endif

protected:
	void Unregister();

	void GameplayTagEventCallback(const FGameplayTag Tag, int32 NewCount, TWeakObjectPtr<UObject> RegisteredOwner);

	static bool IsPropertyTypeValid(const FProperty* Property);

	static EGameplayTagEventType::Type GetGameplayTagEventType(const FProperty* Property);

	TWeakObjectPtr<UObject> CachedOwner;
	TWeakObjectPtr<UAbilitySystemComponent> CachedAbilitySystemComponent;

	UPROPERTY(EditAnywhere, Category = GameplayTagBlueprintProperty)
	TArray<FGameplayTagBlueprintPropertyMapping> PropertyMappings;
};
--- Source\AbilitySystemCore\Public\Globals\AbilitySystemGlobalsBase.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "AbilitySystemGlobals.h"
#include "CoreMinimal.h"

#include "AbilitySystemGlobalsBase.generated.h"

/**
 *
 */
UCLASS()
class ABILITYSYSTEMCORE_API UAbilitySystemGlobalsBase : public UAbilitySystemGlobals
{
	GENERATED_BODY()

public:
	/** Gets the single instance of the globals object, will create it as necessary. */
	static UAbilitySystemGlobalsBase& Get() { return *Cast<UAbilitySystemGlobalsBase>(IGameplayAbilitiesModule::Get().GetAbilitySystemGlobals()); }

	/** Initialize global tags by reading from config using the names and creating tags for use at runtime */
	virtual void InitGlobalTags() override;

	template <class T> static T* GetAbilitySystemComponentFromActor(const AActor* Actor, const bool bLookForComponent = true)
	{
		return Cast<T>(UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(Actor, bLookForComponent));
	}
};
--- Source\AbilitySystemCore\Public\Input\InputConfig.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"

#include "InputConfig.generated.h"

class UInputAction;
struct FInputTagSet;

/**
 * UInputConfig
 *
 *	Non-mutable data asset that contains input configuration properties.
 */
UCLASS(BlueprintType, Const)
class ABILITYSYSTEMCORE_API UInputConfig : public UDataAsset
{
	GENERATED_BODY()

public:
	UInputConfig(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	UFUNCTION(BlueprintCallable, Category = "Input")
	const UInputAction* FindInputActionForTag(const FGameplayTag& Tag, bool bLogNotFound = true) const;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, meta = (TitleProperty = "InputAction"))
	TArray<FInputTagSet> InputTagSets;
};
--- Source\AbilitySystemCore\Public\Input\InputTagSet.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"

#include "InputTagSet.generated.h"

class UInputAction;

USTRUCT(BlueprintType)
struct ABILITYSYSTEMCORE_API FInputTagSet
{
	GENERATED_BODY()

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TObjectPtr<const UInputAction> InputAction = nullptr;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Meta = (Categories = "InputTag"))
	FGameplayTag InputTag;
};
--- Source\AbilitySystemCore\Public\Log\AbilitySystemLog.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogAbilitySystem, Log, All);
--- Source\EquipmentSystemCore\EquipmentSystemCore.Build.cs ---
﻿using UnrealBuildTool;

public class EquipmentSystemCore : ModuleRules
{
	public EquipmentSystemCore(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[]
			{
				// ... add public include paths required here ...
			}
		);


		PrivateIncludePaths.AddRange(
			new string[]
			{
				// ... add other private include paths required here ...
			}
		);


		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"DeveloperSettings",
				"NetCore",
				"GameplayAbilities"
				// ... add other public dependencies that you statically link with here ...
			}
		);


		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"GameplayAbilities",
				"GameplayTags",
				"InventorySystemCore",
				"AbilitySystemCore"
				// ... add private dependencies that you statically link with here ...	
			}
		);


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
		);
	}
}
--- Source\EquipmentSystemCore\Private\EquipmentSystemCore.cpp ---
﻿#include "EquipmentSystemCore.h"

#define LOCTEXT_NAMESPACE "FEquipmentSystemCoreModule"

void FEquipmentSystemCoreModule::StartupModule() {}

void FEquipmentSystemCoreModule::ShutdownModule() {}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FEquipmentSystemCoreModule, EquipmentSystemCore)
--- Source\EquipmentSystemCore\Private\Abilities\EquipmentGameplayAbility.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Abilities/EquipmentGameplayAbility.h"
#include "Instances/EquipmentInstance.h"
#include "Instances/ItemInstance.h"

#if WITH_EDITOR
#include "Misc/DataValidation.h"
#endif

UEquipmentGameplayAbility::UEquipmentGameplayAbility(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
}

UEquipmentInstance* UEquipmentGameplayAbility::GetSourceEquipmentInstance() const
{
	return TryGetSourceObject<UEquipmentInstance>();
}

UEquipmentInstance* UEquipmentGameplayAbility::GetTypedSourceEquipmentInstance(const TSubclassOf<UEquipmentInstance>& InstanceClass) const
{
	if (UEquipmentInstance* Instance = TryGetSourceObject<UEquipmentInstance>(); IsValid(Instance) && Instance->IsA(InstanceClass))
	{
		return Instance;
	}
	return nullptr;
}

UItemInstance* UEquipmentGameplayAbility::GetSourceItemInstance() const
{
	if (const UEquipmentInstance* Instance = GetSourceEquipmentInstance(); IsValid(Instance))
	{
		return Cast<UItemInstance>(Instance->GetSourceItem());
	}
	return nullptr;
}

UItemInstance* UEquipmentGameplayAbility::GetTypedSourceItemInstance(const TSubclassOf<UItemInstance>& InstanceClass) const
{
	if (UItemInstance* Instance = GetSourceItemInstance(); IsValid(Instance) && Instance->IsA(InstanceClass))
	{
		return Instance;
	}
	return nullptr;
}

#if WITH_EDITOR
EDataValidationResult UEquipmentGameplayAbility::IsDataValid(FDataValidationContext& Context) const
{
	EDataValidationResult Result = Super::IsDataValid(Context);

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// Ensure that equipment abilities are always instanced
	if (InstancingPolicy == EGameplayAbilityInstancingPolicy::NonInstanced)
	{
		Context.AddError(FText::FromString("Equipment abilities must be instanced."));
		Result = EDataValidationResult::Invalid;
	}
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

	return Result;
}
#endif
--- Source\EquipmentSystemCore\Private\Actors\EquipmentActor.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Actors/EquipmentActor.h"

AEquipmentActor::AEquipmentActor(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer.Get())
{
	PrimaryActorTick.bCanEverTick = false;

	SetReplicates(true);
}

APawn* AEquipmentActor::GetPawn()
{
	return Cast<APawn>(GetOwner());
}
--- Source\EquipmentSystemCore\Private\Components\EquipmentSlotComponent.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/EquipmentSlotComponent.h"

#include "Components/EquipmentSystemComponent.h"
#include "Data/EquipmentSlotMapData.h"
#include "Definitions/Fragments/ItemFragment_Equippable.h"
#include "Instances/EquipmentInstance.h"
#include "Instances/ItemInstance.h"
#include "Net/UnrealNetwork.h"

UEquipmentSlotComponent::UEquipmentSlotComponent(const FObjectInitializer& ObjectInitializer)
{
	SetIsReplicatedByDefault(true);

	bWantsInitializeComponent = true;
}

void UEquipmentSlotComponent::BeginPlay()
{
	Slots.Empty();

	for (const FGameplayTag& SlotTag : SlotMap->Slots)
	{
		Slots.Add({SlotTag});
	}

	Super::BeginPlay();
}

void UEquipmentSlotComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, Slots);
}

void UEquipmentSlotComponent::Server_EquipItemAtSlot_Implementation(const FGameplayTag SlotTag)
{
	if (const FEquipmentSlotSet* InstanceSet = FindInstanceSetForSlot(SlotTag))
	{
		if (!IsValid(InstanceSet->ItemInstance))
		{
			return;
		}

		UnequipItemInSlot(SlotTag);
		EquipItemInSlot(SlotTag);
	}
}

void UEquipmentSlotComponent::AddItemToSlot(const FGameplayTag SlotTag, UItemInstance* Item)
{
	if (IsValidSlot(SlotTag) && Item != nullptr)
	{
		if (FEquipmentSlotSet* InstanceSet = FindInstanceSetForSlot(SlotTag))
		{
			InstanceSet->ItemInstance = Item;
			OnRep_Slots();

			// OnItemAddedToSlot.Broadcast(SlotIndex, Item);
		}
	}
}

UItemInstance* UEquipmentSlotComponent::RemoveItemFromSlot(const FGameplayTag SlotTag)
{
	UItemInstance* Result = nullptr;

	UnequipItemInSlot(SlotTag);

	if (IsValidSlot(SlotTag))
	{
		if (FEquipmentSlotSet* InstanceSet = FindInstanceSetForSlot(SlotTag))
		{
			Result = InstanceSet->ItemInstance;
			InstanceSet->ItemInstance = nullptr;

			OnRep_Slots();
		}
	}

	return Result;
}

void UEquipmentSlotComponent::EquipItemInSlot(const FGameplayTag SlotTag)
{
	check(IsValidSlot(SlotTag));

	// Check if we've already an item in the slot
	if (FindInstanceSetForSlot(SlotTag) != nullptr)
	{
		UnequipItemInSlot(SlotTag);
	}

	UEquipmentSystemComponent* EquipmentSystemComp = FindEquipmentSystem();
	if (!EquipmentSystemComp)
	{
		return;
	}

	if (const FEquipmentSlotSet* InstanceSet = FindInstanceSetForSlot(SlotTag))
	{
		UItemInstance* Item = InstanceSet->ItemInstance;

		if (const UItemFragment_EquipableItem* EquipFragment = Item->FindFragmentByClass<UItemFragment_EquipableItem>())
		{
			if (const TSubclassOf<UEquipmentDefinition> EquipmentDefinition = EquipFragment->EquipmentDefinition; IsValid(EquipmentDefinition))
			{
				if (UEquipmentInstance* NewInstance = EquipmentSystemComp->EquipItem(EquipmentDefinition); NewInstance != nullptr)
				{
					NewInstance->SetSourceItem(Item);
				}
			}
		}
	}
}

void UEquipmentSlotComponent::UnequipItemInSlot(const FGameplayTag SlotTag)
{
	if (!IsValidSlot(SlotTag))
	{
		return;
	}

	if (UEquipmentSystemComponent* EquipmentSystem = FindEquipmentSystem())
	{
		if (const FEquipmentSlotSet* InstanceSet = FindInstanceSetForSlot(SlotTag))
		{
			if (UEquipmentInstance* EquipmentInstance = EquipmentSystem->GetInstanceFromItem(InstanceSet->ItemInstance))
			{
				EquipmentSystem->UnequipItem(EquipmentInstance);

				// OnSlotUnequipped.Broadcast(ActiveSlotIndex);
			}
		}
	}
}

FEquipmentSlotSet* UEquipmentSlotComponent::FindInstanceSetForSlot(FGameplayTag SlotTag)
{
	return Slots.FindByPredicate([SlotTag](const FEquipmentSlotSet& Set) { return Set.SlotTag == SlotTag; });
}

bool UEquipmentSlotComponent::IsValidSlot(const FGameplayTag SlotTag) const
{
	return SlotMap->Slots.Contains(SlotTag);
}

UEquipmentSystemComponent* UEquipmentSlotComponent::FindEquipmentSystem() const
{
	if (const AController* OwnerController = Cast<AController>(GetOwner()))
	{
		if (const APawn* Pawn = OwnerController->GetPawn())
		{
			return Pawn->FindComponentByClass<UEquipmentSystemComponent>();
		}
	}
	return nullptr;
}

void UEquipmentSlotComponent::OnRep_Slots() {}
--- Source\EquipmentSystemCore\Private\Components\EquipmentSystemComponent.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/EquipmentSystemComponent.h"

#include "Data/EquipmentCache.h"
#include "Data/EquipmentEntry.h"
#include "Engine/ActorChannel.h"
#include "Instances/EquipmentInstance.h"
#include "Net/UnrealNetwork.h"

UEquipmentSystemComponent::UEquipmentSystemComponent(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer), EquipmentList(this)
{
	SetIsReplicatedByDefault(true);
	bWantsInitializeComponent = true;
}

void UEquipmentSystemComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, EquipmentList);
}

bool UEquipmentSystemComponent::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)
{
	bool bReplicated = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			bReplicated |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return bReplicated;
}

void UEquipmentSystemComponent::ReadyForReplication()
{
	Super::ReadyForReplication();

	// Register all equipment instances ready for replication with the actor component
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FEquipmentEntry& Entry : EquipmentList.Entries)
		{
			if (UEquipmentInstance* Instance = Entry.Instance; IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}

void UEquipmentSystemComponent::InitializeComponent()
{
	Super::InitializeComponent();

	// Cache initialization
	Cache = NewObject<UEquipmentCache>(this, "Cache");
}

void UEquipmentSystemComponent::UninitializeComponent()
{
	TArray<UEquipmentInstance*> Instances;

	// Gathering all instances before removal to avoid side effects affecting the equipment list iterator
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		Instances.Add(Entry.Instance);
	}

	for (UEquipmentInstance* EquipInstance : Instances)
	{
		UnequipItem(EquipInstance);
	}

	Super::UninitializeComponent();
}

UEquipmentInstance* UEquipmentSystemComponent::EquipItem(const TSubclassOf<UEquipmentDefinition>& EquipmentDefinition, UItemInstance* SourceItemInstance)
{
	if (IsValid(EquipmentDefinition))
	{
		if (UEquipmentInstance* Instance = EquipmentList.Add(EquipmentDefinition, SourceItemInstance))
		{
			Instance->OnEquipped();

			if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
			{
				AddReplicatedSubObject(Instance);
			}

			return Instance;
		}
	}
	return nullptr;
}

void UEquipmentSystemComponent::UnequipItem(UEquipmentInstance* ItemInstance)
{
	if (IsValid(ItemInstance))
	{
		if (IsUsingRegisteredSubObjectList())
		{
			RemoveReplicatedSubObject(ItemInstance);
		}

		ItemInstance->OnUnequipped();
		EquipmentList.Remove(ItemInstance);
	}
}

UEquipmentInstance* UEquipmentSystemComponent::GetInstanceOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass)
{
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA(InstanceClass))
			{
				return Instance;
			}
		}
	}
	return nullptr;
}

TArray<UEquipmentInstance*> UEquipmentSystemComponent::GetAllInstancesOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass)
{
	TArray<UEquipmentInstance*> Results;
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA(InstanceClass))
			{
				Results.Add(Instance);
			}
		}
	}
	return Results;
}

UEquipmentDefinition* UEquipmentSystemComponent::GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class) const
{
	if (IsValid(Cache))
	{
		return Cache->GetCachedDefinition(Class);
	}
	if (IsValid(Class))
	{
		return NewObject<UEquipmentDefinition>(GetOuter(), Class);
	}
	return nullptr;
}

UEquipmentInstance* UEquipmentSystemComponent::GetInstanceFromItem(UItemInstance* ItemInstance)
{
	for (FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->GetSourceItem() == ItemInstance)
			{
				return Instance;
			}
		}
	}
	return nullptr;
}


void UEquipmentSystemComponent::PostEquipmentEquipped(const FEquipmentChangeData& Data)
{
	OnEquipmentEquipped.Broadcast(Data);
}

void UEquipmentSystemComponent::PostEquipmentUnequipped(const FEquipmentChangeData& Data)
{
	OnEquipmentUnequipped.Broadcast(Data);
}

void UEquipmentSystemComponent::PostEquipmentChanged(const FEquipmentChangeData& Data)
{
	OnEquipmentChanged.Broadcast(Data);
}
--- Source\EquipmentSystemCore\Private\Data\EquipmentCache.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentCache.h"

#include "Definitions/EquipmentDefinition.h"

UEquipmentCache::UEquipmentCache()
{
	// Register the cache for cleanup after garbage collection
	FCoreUObjectDelegates::GetPostGarbageCollect().AddUObject(this, &UEquipmentCache::Clean);
}

UEquipmentCache::~UEquipmentCache()
{
	// Unregister from the garbage collection delegate
	FCoreUObjectDelegates::GetPostGarbageCollect().RemoveAll(this);
}

UEquipmentDefinition* UEquipmentCache::GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class)
{
	if (!IsValid(Class))
	{
		return nullptr;
	}

	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);
	if (const TWeakObjectPtr<UEquipmentDefinition>* const FoundDefinition = CachedDefinitionMap.Find(Class))
	{
		if (UEquipmentDefinition* Definition = FoundDefinition->Get(); IsValid(Definition))
		{
			return Definition;
		}
	}

	// If the definition is not cached, create a new instance
	UEquipmentDefinition* NewDefinition = NewObject<UEquipmentDefinition>(this, Class);
	CachedDefinitionMap.Add(Class, NewDefinition);

	return NewDefinition;
}

bool UEquipmentCache::IsCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class)
{
	FScopeLock Lock(&CacheLock);
	const bool IsCachedDefinition = CachedDefinitionMap.Contains(Class);
	return IsCachedDefinition;
}

void UEquipmentCache::Clean()
{
	if (IsValid(this))
	{
		// Lock the critical section to ensure thread-safe access to the cache
		FScopeLock Lock(&CacheLock);
		for (auto It = CachedDefinitionMap.CreateIterator(); It; ++It)
		{
			if (It.Value() == nullptr || !It.Value().IsValid())
			{
				It.RemoveCurrent();
			}
		}
	}
}
--- Source\EquipmentSystemCore\Private\Data\EquipmentEntry.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentEntry.h"

#include "Components/EquipmentSystemComponent.h"
#include "Data/EquipmentList.h"
#include "Definitions/EquipmentDefinition.h"
#include "Instances/EquipmentInstance.h"
#include "Log/EquipmentSystemLog.h"

void FEquipmentEntry::PreReplicatedRemove(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnRemoveEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

void FEquipmentEntry::PostReplicatedAdd(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnAddedEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

void FEquipmentEntry::PostReplicatedChange(const FEquipmentList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogEquipmentSystem, Verbose, TEXT("%s: OnChangedEntry (Non-Auth): %s (Last) %s"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), *GetNameSafe(LastInstance.Get()));
	}
}

FString FEquipmentEntry::GetDebugString() const
{
	return FString::Printf(TEXT("%s [Def: %s]"), *GetNameSafe(Instance), *GetNameSafe(EquipmentDefinition.Get()));
}
--- Source\EquipmentSystemCore\Private\Data\EquipmentList.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentList.h"

#include "AbilitySystemComponent.h"
#include "AbilitySystemGlobals.h"
#include "Components/EquipmentSystemComponent.h"
#include "Data/AbilitySet.h"
#include "Data/AbilitySetHandles.h"
#include "Data/EquipmentChangeData.h"
#include "Instances/EquipmentInstance.h"

FEquipmentList::FEquipmentList() {}

FEquipmentList::FEquipmentList(UEquipmentSystemComponent* InOwnerComponent)
	: OwnerComponent(InOwnerComponent) {}

FEquipmentList::~FEquipmentList()
{
	Entries.Empty();
}

void FEquipmentList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (const int32 Index : RemovedIndices)
	{
		if (FEquipmentEntry& Entry = Entries[Index]; Entry.Instance != nullptr)
		{
			Entry.Instance->OnUnequipped();
			Entry.LastInstance = nullptr;

			Internal_OnEntryRemoved(Index, Entry);
		}
	}
}

void FEquipmentList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (const int32 Index : AddedIndices)
	{
		if (FEquipmentEntry& Entry = Entries[Index]; Entry.Instance != nullptr)
		{
			Entry.Instance->OnEquipped();
			Entry.LastInstance = MakeWeakObjectPtr<UEquipmentInstance>(Entry.Instance);

			Internal_OnEntryAdded(Index, Entry);
		}
	}
}

void FEquipmentList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (const int32 Index : ChangedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FEquipmentEntry& Entry = Entries[Index];

			if (IsValid(Entry.Instance))
			{
				Entry.Instance->OnEquipped();
			}

			if (Entry.Instance != Entry.LastInstance.Get() && Entry.LastInstance.IsValid())
			{
				Entry.LastInstance->OnUnequipped();
				Entry.LastInstance = MakeWeakObjectPtr<UEquipmentInstance>(Entry.Instance);
			}

			Internal_OnEntryChanged(Index, Entry);
		}
	}
}

UEquipmentInstance* FEquipmentList::Add(const TSubclassOf<UEquipmentDefinition>& DefinitionClass, UItemInstance* SourceItemInstance)
{
	if (DefinitionClass == nullptr || !IsValid(OwnerComponent))
	{
		return nullptr;
	}

	AActor* OwnerActor = OwnerComponent->GetOwner();
	if (!OwnerActor->HasAuthority())
	{
		return nullptr;
	}

	UEquipmentDefinition* CachedDefinition = OwnerComponent->GetCachedDefinition(DefinitionClass);

	if (!CachedDefinition->CanBeEquipped(OwnerComponent))
	{
		return nullptr;
	}

	// Prepare an instance type to spawn, use the default one by default
	TSubclassOf<UEquipmentInstance> InstanceType = CachedDefinition->InstanceClass;
	if (InstanceType == nullptr)
	{
		InstanceType = UEquipmentDefinition::StaticClass();
	}

	// Add default entry
	FEquipmentEntry& Entry = Entries.AddDefaulted_GetRef();

	Entry.EquipmentDefinition = DefinitionClass;
	Entry.Instance = NewObject<UEquipmentInstance>(OwnerActor, InstanceType);

	UEquipmentInstance* Instance = Entry.Instance;
	// Instance->AsyncLoadAssets();
	Instance->SetDefinition(CachedDefinition);
	Instance->SetInstigator(OwnerActor);
	Instance->SetSourceItem(SourceItemInstance);

	// Give the ability sets
	if (UAbilitySystemComponent* AbilitySystemComp = GetAbilitySystemComponent())
	{
		for (const TObjectPtr<const UAbilitySet>& AbilitySet : CachedDefinition->AbilitySets)
		{
			AbilitySet->GiveToAbilitySystem(AbilitySystemComp, &Entry.Handles, Instance);
		}
	}

	// Ask the instance to spawn attachment actors
	Instance->SpawnActors(CachedDefinition->ActorsToSpawn);
	Instance->OnSpawned();

	// Mark the item dirty for the serializer replication
	MarkItemDirty(Entry);

	return Instance;
}

void FEquipmentList::Remove(UEquipmentInstance* Instance)
{
	for (auto EntryIterator = Entries.CreateIterator(); EntryIterator; ++EntryIterator)
	{
		if (FEquipmentEntry& Entry = *EntryIterator; Entry.Instance == Instance)
		{
			if (UAbilitySystemComponent* AbilitySystemComp = GetAbilitySystemComponent())
			{
				Entry.Handles.TakeFromAbilitySystem(AbilitySystemComp);
			}

			// Ask the instance to destroy its attachment actors
			Instance->DestroyActors();

			EntryIterator.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}

void FEquipmentList::Internal_OnEntryChanged(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = Entry.Instance;
	Data.OldInstance = nullptr;
	Data.ChangeType = EEquipmentChangeType::Modified;

	OwnerComponent->PostEquipmentChanged(Data);
}

void FEquipmentList::Internal_OnEntryAdded(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = Entry.Instance;
	Data.OldInstance = nullptr;
	Data.ChangeType = EEquipmentChangeType::Equipped;

	OwnerComponent->PostEquipmentEquipped(Data);
	OwnerComponent->PostEquipmentChanged(Data);
}

void FEquipmentList::Internal_OnEntryRemoved(const int32 Index, const FEquipmentEntry& Entry) const
{
	FEquipmentChangeData Data;
	Data.Index = Index;
	Data.NewInstance = nullptr;
	Data.OldInstance = Entry.Instance;
	Data.ChangeType = EEquipmentChangeType::Unequipped;

	OwnerComponent->PostEquipmentUnequipped(Data);
	OwnerComponent->PostEquipmentChanged(Data);
}

UAbilitySystemComponent* FEquipmentList::GetAbilitySystemComponent() const
{
	check(OwnerComponent);

	const AActor* OwningActor = OwnerComponent->GetOwner();
	return UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(OwningActor);
}
--- Source\EquipmentSystemCore\Private\Data\EquipmentSlotMapData.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/EquipmentSlotMapData.h"
--- Source\EquipmentSystemCore\Private\Definitions\EquipmentDefinition.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/EquipmentDefinition.h"

#include "Definitions/Fragments/EquipmentFragment.h"
#include "Instances/EquipmentInstance.h"

UEquipmentDefinition::UEquipmentDefinition(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get())
{
	InstanceClass = UEquipmentInstance::StaticClass();
}

#if WITH_EDITOR
void UEquipmentDefinition::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	// Check if the Fragments property has changed
	if (PropertyChangedEvent.Property && PropertyChangedEvent.GetPropertyName() == GET_MEMBER_NAME_CHECKED(UEquipmentDefinition, Fragments))
	{
		TSet<UClass*> FragmentClasses;
		for (int32 i = Fragments.Num() - 1; i >= 0; --i)
		{
			if (const UEquipmentFragment* Fragment = Fragments[i]; IsValid(Fragment) && FragmentClasses.Contains(Fragment->GetClass()))
			{
				// Remove duplicate fragments
				Fragments.RemoveAt(i);

				UE_LOG(LogTemp, Warning, TEXT("Only one fragment per class is allowed. Duplicate fragment removed."));
			}
			else if (Fragment)
			{
				FragmentClasses.Add(Fragment->GetClass());
			}
		}
	}
}
#endif

const UEquipmentFragment* UEquipmentDefinition::FindFragmentByClass(const TSubclassOf<UEquipmentFragment> FragmentClass) const
{
	if (IsValid(FragmentClass))
	{
		for (const UEquipmentFragment* Fragment : Fragments)
		{
			if (IsValid(Fragment) && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}

bool UEquipmentDefinition::CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent)
{
	return K2_CanBeEquipped(EquipmentSystemComponent);
}

bool UEquipmentDefinition::K2_CanBeEquipped_Implementation(UEquipmentSystemComponent* EquipmentSystemComponent)
{
	return true;
}
--- Source\EquipmentSystemCore\Private\Definitions\Fragments\EquipmentFragment.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/EquipmentFragment.h"

void UEquipmentFragment::OnInstanceCreated(UEquipmentInstance* Instance) const {}
--- Source\EquipmentSystemCore\Private\Definitions\Fragments\ItemFragment_Equippable.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Equippable.h"

void UItemFragment_EquipableItem::OnInstanceCreated(UItemInstance* Instance)
{
	Super::OnInstanceCreated(Instance);
}
--- Source\EquipmentSystemCore\Private\GameplayTags\EquipmentGameplayTags.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "GameplayTags/EquipmentGameplayTags.h"

namespace EquipmentSystemGameplayTags
{
	// Plugin bases init state tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_Equipment_Slot, "Equipment.Slot", "Root gameplay tag for equipment slots");
} // namespace EquipmentSystemGameplayTags
--- Source\EquipmentSystemCore\Private\Instances\EquipmentInstance.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/EquipmentInstance.h"

#include "GameFramework/Character.h"
#include "Log/EquipmentSystemLog.h"
#include "Net/UnrealNetwork.h"

#if UE_WITH_IRIS
#endif

UEquipmentInstance::UEquipmentInstance(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

UWorld* UEquipmentInstance::GetWorld() const
{
	if (const APawn* OwningPawn = GetPawn(); IsValid(OwningPawn))
	{
		return OwningPawn->GetWorld();
	}
	return nullptr;
}

void UEquipmentInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, DefinitionClass);
	DOREPLIFETIME(ThisClass, Instigator);
	DOREPLIFETIME(ThisClass, SpawnedActors);
	DOREPLIFETIME(ThisClass, Components);
}

APawn* UEquipmentInstance::GetPawn() const
{
	return Cast<APawn>(GetOuter());
}

APawn* UEquipmentInstance::GetTypedPawn(const TSubclassOf<APawn>& PawnType) const
{
	if (UClass* PawnClass = PawnType->GetClass(); IsValid(PawnClass) && IsValid(PawnType))
	{
		if (GetOuter()->IsA(PawnClass))
		{
			return Cast<APawn>(GetOuter());
		}
	}
	return nullptr;
}

UEquipmentComponent* UEquipmentInstance::AddComponent(const TSubclassOf<UEquipmentComponent> ComponentClass)
{
	if (UEquipmentComponent* const Component = NewObject<UEquipmentComponent>(ComponentClass); IsValid(Component))
	{
		Components.Add(Component);
		return Component;
	}
	return nullptr;
}

const UEquipmentComponent* UEquipmentInstance::FindComponentByClass(const TSubclassOf<UEquipmentComponent> ComponentClass) const
{
	if (IsValid(ComponentClass))
	{
		for (const UEquipmentComponent* Component : Components)
		{
			if (IsValid(Component) && Component->IsA(ComponentClass))
			{
				return Component;
			}
		}
	}

	return nullptr;
}

UObject* UEquipmentInstance::GetInstigator() const
{
	return Instigator;
}

void UEquipmentInstance::SetInstigator(UObject* InInstigator)
{
	Instigator = InInstigator;
}

UItemInstance* UEquipmentInstance::GetSourceItem() const
{
	return SourceItem;
}

TSubclassOf<UEquipmentDefinition> UEquipmentInstance::GetDefinitionClass() const
{
	return DefinitionClass;
}

UEquipmentDefinition* UEquipmentInstance::GetDefinition() const
{
	return Definition.Get();
}

void UEquipmentInstance::SetSourceItem(UItemInstance* InSourceObject)
{
	SourceItem = InSourceObject;
}

void UEquipmentInstance::SetDefinition(UEquipmentDefinition* InDefinition)
{
	Definition = InDefinition;
	if (IsValid(InDefinition))
	{
		DefinitionClass = InDefinition->GetClass();
	}
}

void UEquipmentInstance::SpawnActors(const TArray<FEquipmentActorSet>& ActorsToSpawn)
{
	UWorld* World = GetWorld();
	verifyf(IsValid(World), TEXT("Invalid world to spawn actors for %s"), *GetName());

	if (APawn* OwningPawn = GetPawn(); IsValid(OwningPawn))
	{
		// Use a root scene component as an attachment target by default
		USceneComponent* AttachTarget = OwningPawn->GetRootComponent();
		if (const ACharacter* Character = Cast<ACharacter>(OwningPawn))
		{
			AttachTarget = Character->GetMesh();
		}

		for (const auto& [SlotTag, ActorClass, AttachSocket, AttachTransform] : ActorsToSpawn)
		{
			if (!IsValid(ActorClass))
			{
				UE_LOG(LogEquipmentSystem, Warning, TEXT("Tried to spawn equipment actors with an invalid actor class for %s!"), *GetName());
				continue;
			}

			if (const auto NewActor = World->SpawnActorDeferred<AActor>(ActorClass, FTransform::Identity, OwningPawn); IsValid(NewActor))
			{
				NewActor->SetInstigator(OwningPawn);
				NewActor->FinishSpawning(FTransform::Identity, true);

				// Set relative transform before attaching
				NewActor->SetActorRelativeTransform(AttachTransform);
				NewActor->AttachToComponent(AttachTarget, FAttachmentTransformRules::KeepRelativeTransform, AttachSocket);

				SpawnedActors.Add(NewActor);
			}
		}
		return;
	}

	UE_LOG(LogEquipmentSystem, Error, TEXT("Tried to spawn equipment actors with an invalid pawn !"));
}

void UEquipmentInstance::DestroyActors()
{
	for (AActor* Actor : SpawnedActors)
	{
		if (IsValid(Actor))
		{
			Actor->Destroy();
		}
	}
}

void UEquipmentInstance::OnEquipped()
{
	K2_OnEquipped();
}

void UEquipmentInstance::OnUnequipped()
{
	K2_OnUnequipped();
}

void UEquipmentInstance::OnSpawned() {}

void UEquipmentInstance::OnRep_Instigator() {}
--- Source\EquipmentSystemCore\Private\Instances\Components\EquipmentComponent.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/EquipmentComponent.h"

void UEquipmentComponent::Initialize(UEquipmentInstance* InInstance)
{
	OwningInstance = InInstance;
}

UEquipmentInstance* UEquipmentComponent::GetOwningInstance()
{
	return OwningInstance;
}
--- Source\EquipmentSystemCore\Private\Log\EquipmentSystemLog.cpp ---
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Log/EquipmentSystemLog.h"

DEFINE_LOG_CATEGORY(LogEquipmentSystem);
--- Source\EquipmentSystemCore\Private\Settings\EquipmentSystemSettings.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/EquipmentSystemSettings.h"

DEFINE_LOG_CATEGORY_STATIC(LogEquipmentSettings, Warning, All)

FName UEquipmentSystemSettings::GetContainerName() const
{
	static const FName Name("Project");
	return Name;
}

FName UEquipmentSystemSettings::GetCategoryName() const
{
	static const FName Name("Game");
	return Name;
}

UEquipmentSystemSettings* UEquipmentSystemSettings::Get()
{
	// This is a singleton. Use a default object
	return GetMutableDefault<UEquipmentSystemSettings>();
}

void UEquipmentSystemSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);
}
--- Source\EquipmentSystemCore\Public\EquipmentSystemCore.h ---
﻿#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FEquipmentSystemCoreModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
--- Source\EquipmentSystemCore\Public\Abilities\EquipmentGameplayAbility.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Abilities/GameplayAbilityBase.h"
#include "CoreMinimal.h"
#include "Instances/ItemInstance.h"

#include "EquipmentGameplayAbility.generated.h"

class UItemInstance;
class UEquipmentInstance;

/**
 * @class UEquipmentGameplayAbility
 * @see UGameplayAbilityBase
 * @brief This class represents a gameplay ability specifically for equipment.
 * It extends the base gameplay ability with equipment-specific functionality.
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UEquipmentGameplayAbility : public UGameplayAbilityBase
{
	GENERATED_BODY()

public:
	UEquipmentGameplayAbility(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Gets the source equipment instance for this ability.
	 * @return The UEquipmentInstance associated with this ability.
	 */
	UFUNCTION(BlueprintCallable, Category = "Ability")
	UEquipmentInstance* GetSourceEquipmentInstance() const;

	UFUNCTION(BlueprintCallable, Category = "Ability", BlueprintPure = false, meta = (DeterminesOutputType = InstanceClass))
	UEquipmentInstance* GetTypedSourceEquipmentInstance(const TSubclassOf<UEquipmentInstance>& InstanceClass) const;


	/**
	 * Gets the source item instance for this ability.
	 * @return The UItemInstance associated with this ability's equipment.
	 */
	UFUNCTION(BlueprintCallable, Category = "Ability")
	UItemInstance* GetSourceItemInstance() const;

	UFUNCTION(BlueprintCallable, Category = "Ability", BlueprintPure = false, meta = (DeterminesOutputType = InstanceClass))
	UItemInstance* GetTypedSourceItemInstance(const TSubclassOf<UItemInstance>& InstanceClass) const;

	/** Template method that attempts to get the source object as the specified type.
	 * @tparam T The type to cast the source object to.
	 * @return The source object cast to the specified type, or nullptr if invalid.
	 */
	template <class T> T* TryGetSourceObject() const;

	/** Template method that retrieves the source item instance as the specified type.
	 * @tparam T The type to cast the item instance to.
	 * @return The source item instance cast to the specified type, or nullptr if invalid.
	 */
	template <class T> T* GetTypedSourceItemInstance();

	/** Template method that retrieves the source equipment instance as the specified type.
	 * @tparam T The type to cast the equipment instance to.
	 * @return The source equipment instance cast to the specified type, or nullptr if invalid.
	 */
	template <class T> T* GetTypedSourceEquipmentInstance();

	#if WITH_EDITOR
	/**
	 * Validates the data for this ability in the editor.
	 * @param Context The data validation context.
	 * @return The result of the data validation.
	 */
	virtual EDataValidationResult IsDataValid(FDataValidationContext& Context) const override;
	#endif
};

template <class T> T* UEquipmentGameplayAbility::TryGetSourceObject() const
{
	if (UObject* const SourceObject = GetCurrentSourceObject(); IsValid(SourceObject))
	{
		return Cast<T>(SourceObject);
	}
	return nullptr;
}

template <class T> T* UEquipmentGameplayAbility::GetTypedSourceItemInstance()
{
	if (UItemInstance* Instance = GetSourceItemInstance(); IsValid(Instance))
	{
		return Cast<T>(Instance);
	}
	return nullptr;
}

template <class T> T* UEquipmentGameplayAbility::GetTypedSourceEquipmentInstance()
{
	return TryGetSourceObject<T>();
}
--- Source\EquipmentSystemCore\Public\Actors\EquipmentActor.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "EquipmentActor.generated.h"

UCLASS()
class EQUIPMENTSYSTEMCORE_API AEquipmentActor : public AActor
{
	GENERATED_BODY()

public:
	AEquipmentActor(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	/**
	 * Get the owning pawn of this equipment.
	 * @return The owning pawn if it exists, otherwise nullptr.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment")
	virtual APawn* GetPawn();
};
--- Source\EquipmentSystemCore\Public\Components\EquipmentSlotComponent.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ActorComponent.h"
#include "CoreMinimal.h"
#include "Data/EquipmentSlotSet.h"
#include "EquipmentSlotComponent.generated.h"

class UEquipmentSystemComponent;
class UEquipmentSlotMapData;

UCLASS(BlueprintType, meta = (BlueprintSpawnableComponent))
class EQUIPMENTSYSTEMCORE_API UEquipmentSlotComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UEquipmentSlotComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	virtual void BeginPlay() override;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	UFUNCTION(Server, Reliable, BlueprintCallable, Category = "Equipment", Meta = (Categories = "Equipment.Slot"))
	void Server_EquipItemAtSlot(FGameplayTag SlotTag);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Meta = (Categories = "Equipment.Slot"))
	void AddItemToSlot(FGameplayTag SlotTag, UItemInstance* Item);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Meta = (Categories = "Equipment.Slot"))
	UItemInstance* RemoveItemFromSlot(FGameplayTag SlotTag);

protected:
	void EquipItemInSlot(FGameplayTag SlotTag);
	void UnequipItemInSlot(FGameplayTag SlotTag);

	FEquipmentSlotSet* FindInstanceSetForSlot(FGameplayTag SlotTag);
	bool IsValidSlot(FGameplayTag SlotTag) const;

	UEquipmentSystemComponent* FindEquipmentSystem() const;

	UFUNCTION()
	static void OnRep_Slots();

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TObjectPtr<UEquipmentSlotMapData> SlotMap;

	UPROPERTY(Replicated, ReplicatedUsing = OnRep_Slots)
	TArray<FEquipmentSlotSet> Slots = {};
};
--- Source\EquipmentSystemCore\Public\Components\EquipmentSystemComponent.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ActorComponent.h"
#include "CoreMinimal.h"
#include "Data/EquipmentCache.h"
#include "Data/EquipmentList.h"
#include "Instances/EquipmentInstance.h"

#include "EquipmentSystemComponent.generated.h"

struct FEquipmentChangeData;
class UItemInstance;
class UEquipmentInstance;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEquipmentChanged, const FEquipmentChangeData&, Data);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEquipmentEquipped, const FEquipmentChangeData&, Data);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEquipmentUnequipped, const FEquipmentChangeData&, Data);

/**
 * @class UEquipmentSystemComponent
 * @see UActorComponent
 * @brief This component manages the equipment system for an actor.
 */
UCLASS(BlueprintType, meta = (BlueprintSpawnableComponent))
class EQUIPMENTSYSTEMCORE_API UEquipmentSystemComponent : public UActorComponent
{
	GENERATED_BODY()

	friend FEquipmentList;

public:
	explicit UEquipmentSystemComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	// ~UObject

	// UActorComponent
	virtual void InitializeComponent() override;
	virtual void UninitializeComponent() override;
	// ~UActorComponent

	/**
	 * Equips an item based on the provided equipment definition.
	 * @param EquipmentDefinition The class of the equipment to equip.
	 * @param SourceItemDefinition
	 * @return The equipped UEquipmentInstance.
	 */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
	UEquipmentInstance* EquipItem(const TSubclassOf<UEquipmentDefinition>& EquipmentDefinition, UItemInstance* SourceItemDefinition = nullptr);
	/**
	 * Unequips the specified item instance.
	 * @param ItemInstance The equipment instance to unequip.
	 */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
	void UnequipItem(UEquipmentInstance* ItemInstance);

	/**
	 * Gets an instance of the specified equipment type.
	 * @param InstanceClass The class of the equipment instance to find.
	 * @return The first found UEquipmentInstance of the specified type.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = InstanceClass))
	UEquipmentInstance* GetInstanceOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass);
	/**
	 * Template function to get an instance of a specific equipment type.
	 * @return The first found an instance of the specified type.
	 */
	template <typename T> T* GetInstanceOfType() const;

	/**
	 * Gets all instances of the specified equipment type.
	 * @param InstanceClass The class of the equipment instances to find.
	 * @return An array of UEquipmentInstances of the specified type.
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = InstanceClass))
	TArray<UEquipmentInstance*> GetAllInstancesOfType(const TSubclassOf<UEquipmentInstance>& InstanceClass);

	template <typename T> TArray<T*> GetAllInstancesOfType() const;

	UFUNCTION(BlueprintCallable, Category = "Equipment", meta = (DeterminesOutputType = Class))
	UEquipmentDefinition* GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class) const;

	/**
	 * Gets the equipment instance of the associated ItemInstance
	 * @param ItemInstance The instance of the source item
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Equipment")
	UEquipmentInstance* GetInstanceFromItem(UItemInstance* ItemInstance);

	virtual void PostEquipmentEquipped(const FEquipmentChangeData& Data);
	virtual void PostEquipmentUnequipped(const FEquipmentChangeData& Data);
	virtual void PostEquipmentChanged(const FEquipmentChangeData& Data);

	/** Broadcasts when equipment changes, providing both the new and old instance. */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentChanged OnEquipmentChanged;
	/** Broadcasts when equipment is equipped, providing the instance. */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentEquipped OnEquipmentEquipped;
	/** Broadcasts when equipment is unequipped, providing the instance. */
	UPROPERTY(BlueprintAssignable)
	FOnEquipmentUnequipped OnEquipmentUnequipped;

protected:
	/** The list of equipped items. */
	UPROPERTY(Replicated)
	FEquipmentList EquipmentList;

	/** Equipment definitions cache. Not replicated */
	UPROPERTY()
	TObjectPtr<UEquipmentCache> Cache;
};

template <typename T> T* UEquipmentSystemComponent::GetInstanceOfType() const
{
	return Cast<T>(GetFirstInstanceOfType(T::StaticClass()));
}

template <typename T> TArray<T*> UEquipmentSystemComponent::GetAllInstancesOfType() const
{
	TArray<T*> Instances;
	for (const FEquipmentEntry& Entry : EquipmentList.Entries)
	{
		if (UEquipmentInstance* Instance = Entry.Instance)
		{
			if (Instance->IsA<T>())
			{
				Instances.Add(Cast<T>(Instance));
			}
		}
	}
	return Instances;
}
--- Source\EquipmentSystemCore\Public\Data\EquipmentActorSet.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once
#include "GameplayTagContainer.h"

#include "EquipmentActorSet.generated.h"

USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentActorSet
{
	GENERATED_BODY()

	FEquipmentActorSet() {};

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment", Meta = (Categories = "Equipment.Slot"))
	FGameplayTag SlotTag;

	/** The class of actor to spawn and attach. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	TSubclassOf<AActor> ActorClass;

	/** The socket on the owning actor to attach the spawned actor to. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	FName AttachSocket;

	/** The transform (position, rotation, scale) to apply relative to the socket. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipment")
	FTransform AttachTransform;
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentCache.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "EquipmentCache.generated.h"

class UEquipmentDefinition;

/**
 * UEquipmentCache
 *
 * A cache system for EquipmentDefinition to improve performance by reducing object creation.
 * This class manages a thread-safe cache of EquipmentDefinitions.
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UEquipmentCache : public UObject
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;

public:
	UEquipmentCache();
	virtual ~UEquipmentCache() override;

	/**
	 * Get a cached EquipmentDefinition default object.
	 * If the EquipmentDefinition is not in the cache, it creates a new one and adds it to the cache.
	 *
	 * @param Class The class of the EquipmentDefinition to retrieve.
	 * @return A pointer to the cached or newly created EquipmentDefinition.
	 */
	UEquipmentDefinition* GetCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class);

	/**
	 * Check if the cache contains a cached default object of the given class.
	 *
	 * @param Class The class of the EquipmentDefinition.
	 * @return True if the cache contains a default object of the given class.
	 */
	bool IsCachedDefinition(const TSubclassOf<UEquipmentDefinition>& Class);

private:
	/**
	 * Clears the cache of any EquipmentDefinitions that are no longer rooted.
	 * This method is called after garbage collection.
	 */
	void Clean();

	/** Map to store cached EquipmentDefinitions */
	UPROPERTY()
	TMap<TSubclassOf<UEquipmentDefinition>, TWeakObjectPtr<UEquipmentDefinition>> CachedDefinitionMap;

	/** Critical section to ensure thread-safe access to the cache */
	FCriticalSection CacheLock;
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentChangeData.h ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "EquipmentChangeData.generated.h"

class UEquipmentInstance;
struct FEquipmentEntry;
class UEquipmentnstance;

/**
 * Defines the types of changes that can occur to Equipment entries
 */
UENUM(BlueprintType)
enum class EEquipmentChangeType : uint8
{
	Equipped, ///< Equipment has just been equipped
	Unequipped, ///< Equipment has just been unequipped
	Modified ///< Equipment properties were modified
};

/**
 * @struct FEquipmentChangeData
 * @see UItemInstance, FEquipmentEntry, EEquipmentChangeType
 * @brief Represents a data payload for tracking Equipment item changes including addition, removal, and modification of items
 * @details Contains information about the affected item instance, its index in the Equipment, the type of change, 
 *		  and stack count changes before and after the modification occurred. Used for notifying systems about
 *		  Equipment state changes and maintaining synchronization.
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentChangeData
{
	GENERATED_BODY()

	FEquipmentChangeData() {}

	/**
	 * Constructs an Equipment change data instance with the specified parameters
	 * @param InIndex The index of the Equipment entry that was modified
	 * @param Entry The Equipment entry containing the item instance and stack count
	 * @param InChangeType The type of modification that occurred
	 */
	FEquipmentChangeData(const int32 InIndex, const FEquipmentEntry& Entry, const EEquipmentChangeType InChangeType = EEquipmentChangeType::Equipped);

	/** 
	 * Zero-based index of the modified Equipment entry
	 * Set to INDEX_NONE (-1) when the entry is invalid
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	int32 Index = INDEX_NONE;

	/** 
	 * Reference to the new equipment instance
	 * Contains the equipment's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	TObjectPtr<UEquipmentInstance> NewInstance = nullptr;

	/** 
	 * Reference to the previous equipment instance
	 * Contains the equipment's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Equipment")
	TObjectPtr<UEquipmentInstance> OldInstance = nullptr;

	/** 
	 * Specifies whether the item was added, removed, or modified
	 * Defaults to Added when not specified
	 */
	UPROPERTY(BlueprintReadOnly)
	EEquipmentChangeType ChangeType = EEquipmentChangeType::Equipped;

	/**
	 * Checks if this Equipment change data is valid
	 * @return True if the index is valid (not INDEX_NONE), false otherwise
	 */
	bool IsValid() const { return Index != INDEX_NONE; }
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentEntry.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Data/AbilitySetHandles.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "EquipmentEntry.generated.h"

class UEquipmentDefinition;
class UEquipmentInstance;
/**
 * @class FEquipmentEntry
 *
 * @see FFastArraySerializerItem
 * @brief Entry of single equipped equipment
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;
	friend struct FEquipmentList;

	FEquipmentEntry() {}
	~FEquipmentEntry() {};

	// FFastArraySerializer
	// Functions not virtual in FFAstArraySerializer because called by template
	void PreReplicatedRemove(const FEquipmentList& InArraySerializer) const;
	void PostReplicatedAdd(const FEquipmentList& InArraySerializer) const;
	void PostReplicatedChange(const FEquipmentList& InArraySerializer) const;
	FString GetDebugString() const;
	// ~FFastArraySerializer

protected:
	UPROPERTY(SaveGame)
	TObjectPtr<UEquipmentInstance> Instance = nullptr;

	UPROPERTY(SaveGame)
	TSubclassOf<UEquipmentDefinition> EquipmentDefinition;

	// Authority-only list of granted handles for ability sets
	UPROPERTY(NotReplicated)
	FAbilitySetHandles Handles;

	UPROPERTY(NotReplicated)
	TWeakObjectPtr<UEquipmentInstance> LastInstance;
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentList.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Definitions/EquipmentDefinition.h"
#include "EquipmentEntry.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "EquipmentList.generated.h"

class UItemInstance;
class UAbilitySystemComponent;

struct FNetDeltaSerializeInfo;
struct FReplicationFlags;

/**
 * @struct FEquipmentList
 * @see FFastArraySerializer
 * @brief Represents a list of equipment items that can be efficiently replicated using FastArraySerializer.
 */
USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentList : public FFastArraySerializer
{
	GENERATED_BODY()

	friend class UEquipmentSystemComponent;
	friend FEquipmentEntry;

	FEquipmentList();
	FEquipmentList(UEquipmentSystemComponent* InOwnerComponent);
	~FEquipmentList();

	// FFastArraySerializer
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);

	/** Implements network delta serialization for the equipment list. */
	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParms) { return FastArrayDeltaSerialize<FEquipmentEntry, FEquipmentList>(Entries, DeltaParms, *this); }

	// ~FFastArraySerializer

	/** Add a new equipment instance to the list.
	 * @param DefinitionClass Definition of the type of equipment to add.
	 * @param SourceItemInstance
	 * @return Pointer to entry added */
	UEquipmentInstance* Add(const TSubclassOf<UEquipmentDefinition>& DefinitionClass, UItemInstance* SourceItemInstance = nullptr);

	/**
	 * Remove the specified equipment instance from the list.
	 * @param Instance The instance to remove.
	 */
	void Remove(UEquipmentInstance* Instance);


	/**
	 * Called when an entry is changed.
	 * @param Index The index of the changed entry.
	 * @param Entry The changed entry.
	 */
	void Internal_OnEntryChanged(int32 Index, const FEquipmentEntry& Entry) const;
	/**
	 * Called when an entry is added.
	 * @param Index The index of the added entry.
	 * @param Entry The added entry.
	 */
	void Internal_OnEntryAdded(int32 Index, const FEquipmentEntry& Entry) const;
	/**
	 * Called when an entry is removed.
	 * @param Index The index of the removed entry.
	 * @param Entry The removed entry.
	 */
	void Internal_OnEntryRemoved(int32 Index, const FEquipmentEntry& Entry) const;

private:
	/** Get the ability system component of the owner. */
	UAbilitySystemComponent* GetAbilitySystemComponent() const;

	/** Array of equipment entries */
	UPROPERTY()
	TArray<FEquipmentEntry> Entries;

	/** Owner component of this equipment list */
	UPROPERTY(NotReplicated)
	TObjectPtr<UEquipmentSystemComponent> OwnerComponent = nullptr;
};

// TStructOpsTypeTraits specialization to enable NetDeltaSerializer for FEquipmentList
template <> struct TStructOpsTypeTraits<FEquipmentList> : TStructOpsTypeTraitsBase2<FEquipmentList>
{
	enum
	{
		WithNetDeltaSerializer = true
	};
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentSlotMapData.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"

#include "EquipmentSlotMapData.generated.h"

/**
 *
 */
UCLASS()
class EQUIPMENTSYSTEMCORE_API UEquipmentSlotMapData : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Meta = (Categories = "Equipment.Slot"))
	TArray<FGameplayTag> Slots;
};
--- Source\EquipmentSystemCore\Public\Data\EquipmentSlotSet.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "GameplayTagContainer.h"

#include "EquipmentSlotSet.generated.h"

class UEquipmentInstance;
class UItemInstance;

USTRUCT(BlueprintType)
struct EQUIPMENTSYSTEMCORE_API FEquipmentSlotSet
{
	GENERATED_BODY()

	FEquipmentSlotSet()
		: SlotTag(FGameplayTag::EmptyTag) {};

	FEquipmentSlotSet(const FGameplayTag& InSlotTag)
		: SlotTag(InSlotTag) {};

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Meta = (Categories = "Equipment.Slot"))
	FGameplayTag SlotTag;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TObjectPtr<UItemInstance> ItemInstance = nullptr;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TObjectPtr<UEquipmentInstance> EquipmentInstance = nullptr;
};
--- Source\EquipmentSystemCore\Public\Definitions\EquipmentDefinition.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Data/EquipmentActorSet.h"
#include "UObject/Object.h"

#include "EquipmentDefinition.generated.h"

class UEquipmentSystemComponent;
class UEquipmentInstance;
class UAbilitySet;
class UEquipmentFragment;

/**
 * @class UEquipmentDefinition
 * @see UObject
 * @brief Data asset definition of an item that can be equipped by the pawn.
 * And what to do to the pawn on which it is equipped
 */
UCLASS(Blueprintable, Abstract, BlueprintType)
class EQUIPMENTSYSTEMCORE_API UEquipmentDefinition : public UObject
{
	GENERATED_BODY()

	friend struct FEquipmentList;

public:
	UEquipmentDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
	#endif
	// ~UObject

	/**
	 * Try to find fragment of class FragmentClass in this equipment definition
	 * @param FragmentClass Class of the EquipmentFragment to search
	 * @return Pointer to the found fragment, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UEquipmentFragment* FindFragmentByClass(TSubclassOf<UEquipmentFragment> FragmentClass) const;

	/**
	 * Template function to find fragment of class T in this equipment definition
	 * @return Pointer to the found fragment of type T, or nullptr if not found
	 */
	template <typename T> const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	virtual bool CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent);

	UFUNCTION(BlueprintNativeEvent, BlueprintPure)
	bool K2_CanBeEquipped(UEquipmentSystemComponent* EquipmentSystemComponent);

	/**
	 * Get the display name of this equipment
	 * @return Display name as FText
	 */
	FText GetDisplayName() const { return DisplayName; }

protected:
	/** Display name of the equipment (used by UI) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipable")
	FText DisplayName;

	/** Instance class to spawn */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Equipment")
	TSubclassOf<UEquipmentInstance> InstanceClass;

	/** Actors to spawn on the pawn when this is equipped */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Equipment")
	TArray<FEquipmentActorSet> ActorsToSpawn;

	/** Ability sets granted by this equipment */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Gameplay")
	TArray<TObjectPtr<const UAbilitySet>> AbilitySets;

	/** Equipment fragments for additional functionality */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Fragments", Instanced)
	TArray<TObjectPtr<UEquipmentFragment>> Fragments;
};
--- Source\EquipmentSystemCore\Public\Definitions\Fragments\EquipmentFragment.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "EquipmentFragment.generated.h"

class UEquipmentInstance;

/**
 * @class UEquipmentFragment
 * @see UEquipmentDefinition
 * @brief Represents a fragment of an equipment definition, allow definition extension.
 */
UCLASS(DefaultToInstanced, EditInlineNew, Blueprintable, BlueprintType, Abstract)
class EQUIPMENTSYSTEMCORE_API UEquipmentFragment : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Called when an equipment instance is created.
	 * @param Instance The equipment instance associated with this fragment.
	 */
	virtual void OnInstanceCreated(UEquipmentInstance* Instance) const;
};
--- Source\EquipmentSystemCore\Public\Definitions\Fragments\ItemFragment_Equippable.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Definitions/Fragments/ItemFragment.h"
#include "ItemFragment_Equippable.generated.h"

class UEquipmentSystemComponent;
class UEquipmentDefinition;

/**
 *
 */
UCLASS(DisplayName = "Equipable")
class EQUIPMENTSYSTEMCORE_API UItemFragment_EquipableItem : public UItemFragment
{
	GENERATED_BODY()

public:
	/**
	 * Called when an item instance is created. This method initializes any equipable-specific functionality for the item instance.
	 * @param Instance The item instance associated with this fragment.
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance) override;

	/**
	 * The equipment definition associated with this fragment.
	 * @note This defines the properties and behavior of the equipped item.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Equipable")
	TSubclassOf<UEquipmentDefinition> EquipmentDefinition;
};
--- Source\EquipmentSystemCore\Public\GameplayTags\EquipmentGameplayTags.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "NativeGameplayTags.h"

namespace EquipmentSystemGameplayTags
{
	EQUIPMENTSYSTEMCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Equipment_Slot);
}
--- Source\EquipmentSystemCore\Public\Instances\EquipmentInstance.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/EquipmentComponent.h"
#include "Data/EquipmentActorSet.h"
#include "Definitions/EquipmentDefinition.h"
#include "Engine/World.h"
#include "Instances/Components/ItemComponent.h"

#include "EquipmentInstance.generated.h"

class UEquipmentFragment;
/**
 * @class UEquipmentInstance
 * @see UObject
 * @brief Represents an instance of equipment that can be equipped by a pawn.
 */
UCLASS(BlueprintType, Blueprintable)
class EQUIPMENTSYSTEMCORE_API UEquipmentInstance : public UObject
{
	GENERATED_BODY()

	friend struct FEquipmentList;
	friend class UEquipmentSlotComponent;

public:
	UEquipmentInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual bool IsSupportedForNetworking() const override { return true; }
	virtual UWorld* GetWorld() const override final;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// ~UObject

	/** Get the pawn that this equipment instance is attached to. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	APawn* GetPawn() const;
	/** Get the pawn that this equipment instance is attached to, if applicable. */
	UFUNCTION(BlueprintPure, Category = "Equipment", meta = (DeterminesOutputType = PawnType))
	APawn* GetTypedPawn(const TSubclassOf<APawn>& PawnType) const;
	/** Get the pawn that this equipment instance is attached to, if applicable. */
	template <class T> T* GetPawn() const { return Cast<T>(GetPawn()); }

	/**
	 *	Add a new component object of class ComponentClass to this EquipmentInstance
	 *	@param ComponentClass Class of the EquipmentComponent to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	UEquipmentComponent* AddComponent(TSubclassOf<UEquipmentComponent> ComponentClass);
	/**
	 *	Add a new component object of class ComponentClass to this EquipmentInstance
	 */
	template <typename T> T* AddComponent() { return Cast<T>(AddComponent(T::StaticClass())); }

	/**
	 *	Try to find component of class ComponentClass of this equipment instance
	 *	@param ComponentClass Class of the Equipment Instance's component to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = ComponentClass))
	const UEquipmentComponent* FindComponentByClass(TSubclassOf<UEquipmentComponent> ComponentClass) const;
	/**
	 *	Try to find fragment of class ComponentClass of this equipment instance
	 */
	template <typename T> const T* FindComponentByClass() const { return Cast<T*>(FindComponentByClass(T::StaticClass())); }

	/** Get the instigator object that caused this equipment instance to be equipped. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	UObject* GetInstigator() const;
	/** Set the instigator object for this equipment instance. */
	void SetInstigator(UObject* InInstigator);

	/** Get the source object that caused this equipment instance to be equipped.  (ItemInstance class)*/
	UFUNCTION(BlueprintPure, Category = "Equipment")
	UItemInstance* GetSourceItem() const;

	/**
	 * Gets the equipment definition class associated with this instance.
	 * @return The equipment definition class.
	 */
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UEquipmentDefinition> GetDefinitionClass() const;

	/**
	 * Gets the equipment definition associated with this instance, cached by the Equipment System Component.
	 * @return The equipment definition default object.
	 */
	UFUNCTION(BlueprintCallable)
	UEquipmentDefinition* GetDefinition() const;

	/**
	 * Spawn actors defined in the given array and attach them to the pawn.
	 * @param ActorsToSpawn Array of actor sets defining which actors to spawn and how to attach them. */
	virtual void SpawnActors(const TArray<FEquipmentActorSet>& ActorsToSpawn);
	/** Destroy all actors spawned by this equipment instance. */
	virtual void DestroyActors();
	/** Get an array of actors spawned by this equipment instance. */
	UFUNCTION(BlueprintPure, Category = "Equipment")
	TArray<AActor*> GetSpawnedActors() const { return SpawnedActors; }

	/** Called the equipment instance is equipped. */
	virtual void OnEquipped();
	/** Called the equipment instance is unequipped. */
	virtual void OnUnequipped();

	/** Called the equipment instance is spawned. */
	virtual void OnSpawned();

protected:
	/** Set the source object for this equipment instance. (ItemInstance class)*/
	void SetSourceItem(UItemInstance* InSourceObject);

	/**
	 * Sets the item definition class for this instance.
	 * @param InDefinition - The item definition to set.
	 */
	void SetDefinition(UEquipmentDefinition* InDefinition);

	/** Blueprint event called when this equipment instance is equipped. */
	UFUNCTION(BlueprintImplementableEvent, Category = "Equipment", meta = (DisplayName = "OnEquipped"))
	void K2_OnEquipped();

	/** Blueprint event called when this equipment instance is unequipped. */
	UFUNCTION(BlueprintImplementableEvent, Category = "Equipment", meta = (DisplayName = "OnUnequipped"))
	void K2_OnUnequipped();

	UFUNCTION()
	virtual void OnRep_Instigator();

	UPROPERTY(Replicated)
	TArray<AActor*> SpawnedActors;

	/** The Equipment definition that this instance is based on.
	 * Only replicate the class.
	 */
	UPROPERTY(Replicated)
	TSubclassOf<UEquipmentDefinition> DefinitionClass;

	/** The Equipment Definition default object, cached by the local EquipmentSystemComponent cache */
	UPROPERTY()
	TObjectPtr<UEquipmentDefinition> Definition;

	UPROPERTY()
	TObjectPtr<UItemInstance> SourceItem;

	/** Array of components attached to this item instance. */
	UPROPERTY(Replicated)
	TArray<UEquipmentComponent*> Components;

	UPROPERTY(Replicated, ReplicatedUsing = OnRep_Instigator)
	TObjectPtr<UObject> Instigator;
};
--- Source\EquipmentSystemCore\Public\Instances\Components\EquipmentComponent.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "EquipmentComponent.generated.h"

class UEquipmentInstance;
/**
 * @class UEquipmentComponent
 * @see UObject
 * @brief Base class for modular components that can be added to equipment instances.
 *
 * This class serves as the foundation for creating specialized components
 * that add specific functionalities to item instances. It allows for a flexible
 * and extensible equipment system.
 */
UCLASS(Abstract)
class EQUIPMENTSYSTEMCORE_API UEquipmentComponent : public UObject
{
	GENERATED_BODY()

public:
	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override { Super::GetLifetimeReplicatedProps(OutLifetimeProps); };
	// ~UObject

	virtual void Initialize(UEquipmentInstance* InInstance);

	/** Returns the owning equipment instance of the component. */
	UFUNCTION(BlueprintCallable, BlueprintPure)
	UEquipmentInstance* GetOwningInstance();

	UPROPERTY(Transient, Replicated)
	TObjectPtr<UEquipmentInstance> OwningInstance = nullptr;
};
--- Source\EquipmentSystemCore\Public\Log\EquipmentSystemLog.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogEquipmentSystem, Log, All);
--- Source\EquipmentSystemCore\Public\Settings\EquipmentSystemSettings.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "EquipmentSystemSettings.generated.h"

struct FGameplayTag;

/**
 *
 */
UCLASS(config = "Game", defaultconfig, meta = (DisplayName = "Equipment System Settings"))
class EQUIPMENTSYSTEMCORE_API UEquipmentSystemSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	// UDeveloperSettings
	virtual FName GetContainerName() const override;
	virtual FName GetCategoryName() const override;
	// ~UDeveloperSettings

	/** Accessor and initializer */
	static UEquipmentSystemSettings* Get();

private:
	
	// UObject
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
	// ~UObject

	UPROPERTY(EditAnywhere, Category = "Equipment Slots")
	bool bRestrictSlots = true;
	
	UPROPERTY(EditAnywhere, Category = "Equipment Slots", meta = (EditCondition = "bRestrictSlots", EditConditionHides = "true"))
	TArray<FGameplayTag> SlotTemplates;
};
--- Source\GameplayCore\GameplayCore.Build.cs ---
﻿// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class GameplayCore : ModuleRules
{
	public GameplayCore(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[]
			{
				// ... add public include paths required here ...
			}
		);


		PrivateIncludePaths.AddRange(
			new string[]
			{
				// ... add other private include paths required here ...
			}
		);


		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"GameplayTags"
				// ... add other public dependencies that you statically link with here ...
			}
		);


		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore"
				// ... add private dependencies that you statically link with here ...	
			}
		);


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
		);
	}
}
--- Source\GameplayCore\Private\GameplayCore.cpp ---
﻿// Copyright Epic Games, Inc. All Rights Reserved.

#include "GameplayCore.h"

#define LOCTEXT_NAMESPACE "FGameplayCoreModule"

void FGameplayCoreModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FGameplayCoreModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FGameplayCoreModule, GameplayCore)
--- Source\GameplayCore\Private\Components\ActorFeatureData.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/ActorFeatureData.h"

#include "Components/ActorFeatureRegisteredDelegate.h"

FActorFeatureData::~FActorFeatureData()
{
	for (const TSharedRef<FActorFeatureRegisteredDelegate>& RegisteredDelegate : RegisteredDelegates)
	{
		// This ensures it will not execute if cleared during delegate iteration
		RegisteredDelegate->bRemoved = true;
	}
}
--- Source\GameplayCore\Private\Components\ActorFeatureRegisteredDelegate.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/ActorFeatureRegisteredDelegate.h"

FActorFeatureRegisteredDelegate::FActorFeatureRegisteredDelegate(FActorInitStateChangedDelegate&& InDelegate, const FName InFeatureName, const FGameplayTag InInitState)
	: Delegate(InDelegate), DelegateHandle(FDelegateHandle::EGenerateNewHandleType::GenerateNewHandle), RequiredFeatureName(InFeatureName), RequiredInitState(InInitState), bRemoved(false) {}

FActorFeatureRegisteredDelegate::FActorFeatureRegisteredDelegate(FActorInitStateChangedBPDelegate&& InDelegate, const FName InFeatureName, const FGameplayTag InInitState)
	: BPDelegate(InDelegate), DelegateHandle(FDelegateHandle::EGenerateNewHandleType::GenerateNewHandle), RequiredFeatureName(InFeatureName), RequiredInitState(InInitState), bRemoved(false) {}

void FActorFeatureRegisteredDelegate::Execute(AActor* OwningActor, const FName FeatureName, UObject* Implementer, const FGameplayTag FeatureState) const
{
	if (bRemoved)
	{
		return;
	}

	const FActorInitStateChangedParams Params(OwningActor, FeatureName, Implementer, FeatureState);
	if (Delegate.IsBound())
	{
		ensure(!BPDelegate.IsBound());

		Delegate.Execute(Params);
	}
	else if (BPDelegate.IsBound())
	{
		BPDelegate.Execute(Params);
	}
}
--- Source\GameplayCore\Private\Components\ActorInitStateChangedParams.cpp ---
﻿#include "Components/ActorInitStateChangedParams.h"
--- Source\GameplayCore\Private\Components\GameInitStateInterface.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/GameInitStateInterface.h"

#include "Components/ActorFeatureRegisteredDelegate.h"
#include "Components/GameInitStateSubsystem.h"
#include "GameplayTagContainer.h"

// Add default functionality here for any IGameInitStateInterface functions that are not pure virtual.
AActor* IGameInitStateInterface::GetOwningActor() const
{
	// Removing const because most AActor functions can't handle const
	AActor* FoundActor = const_cast<AActor*>(Cast<AActor>(this));

	if (!FoundActor)
	{
		if (const UActorComponent* FoundComponent = Cast<UActorComponent>(this))
		{
			FoundActor = FoundComponent->GetOwner();
		}
	}

	if (ensure(FoundActor))
	{
		// Subclasses must implement this if they are not actors or components
		return FoundActor;
	}

	return nullptr;
}

UGameInitStateSubsystem* IGameInitStateInterface::GetGameInitStateSubsystem() const
{
	return UGameInitStateSubsystem::GetForActor(GetOwningActor());
}

FGameplayTag IGameInitStateInterface::GetCurrentInitStateFor(FName& FeatureName) const
{
	AActor* OwningActor = GetOwningActor();

	if (const UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor))
	{
		return Manager->GetInitStateForFeature(OwningActor, FeatureName);
	}

	return FGameplayTag();
}

bool IGameInitStateInterface::HasReachedInitState(const FName FeatureName, const FGameplayTag DesiredState) const
{
	AActor* OwningActor = GetOwningActor();

	if (UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor))
	{
		return Manager->HasFeatureReachedInitState(OwningActor, FeatureName, DesiredState);
	}

	return false;
}

TArray<FGameplayTag> IGameInitStateInterface::GetAllInitStatesFor(FName& FeatureName) const
{
	AActor* OwningActor = GetOwningActor();

	if (const UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor))
	{
		return Manager->GetAllInitStatesForFeature(OwningActor, FeatureName);
	}

	return {};
}

void IGameInitStateInterface::RegisterInitStateFeature(FName& FeatureName)
{
	UObject* ThisObject = Cast<UObject>(this);
	AActor* OwningActor = GetOwningActor();

	UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor);

	if (OwningActor && Manager)
	{
		// Manager will be null if this isn't in a game world
		Manager->RegisterFeatureImplementer(OwningActor, FeatureName, ThisObject);
	}
}

void IGameInitStateInterface::UnregisterInitStateFeature(FName& FeatureName)
{
	UObject* ThisObject = Cast<UObject>(this);
	AActor* OwningActor = GetOwningActor();

	if (UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor))
	{
		if (ThisObject == OwningActor)
		{
			// This will clear all the feature states and delegates
			Manager->RemoveActorFeatureData(OwningActor);
		}
		else
		{
			Manager->RemoveFeatureImplementer(OwningActor, ThisObject);
		}

		if (ActorInitStateChangedHandle.IsValid())
		{
			Manager->UnregisterActorInitStateDelegate(OwningActor, ActorInitStateChangedHandle);
		}
	}
}

void IGameInitStateInterface::BindOnActorInitStateChanged(const FName FeatureName, const FGameplayTag RequiredState, const bool bCallIfReached)
{
	UObject* ThisObject = Cast<UObject>(this);
	AActor* OwningActor = GetOwningActor();

	UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor);

	if (ensure(OwningActor && Manager))
	{
		// Bind as a weak lambda because this is not a UObject but is guaranteed to be valid as long as ThisObject is
		FActorInitStateChangedDelegate Delegate = FActorInitStateChangedDelegate::CreateWeakLambda(ThisObject, [this](const FActorInitStateChangedParams& Params) { this->OnActorInitStateChanged(Params); });

		ActorInitStateChangedHandle = Manager->RegisterAndCallForActorInitState(OwningActor, FeatureName, RequiredState, MoveTemp(Delegate), bCallIfReached);
	}
}

bool IGameInitStateInterface::RegisterAndCallForActorInitState(const FName FeatureName, const FGameplayTag RequiredState, const FActorInitStateChangedBPDelegate Delegate, const bool bCallImmediately)
{
	AActor* OwningActor = GetOwningActor();

	UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor);

	if (ensure(OwningActor && Manager))
	{
		return Manager->RegisterAndCallForActorInitState(OwningActor, FeatureName, RequiredState, Delegate, bCallImmediately);
	}

	return false;
}

bool IGameInitStateInterface::UnregisterInitStateDelegate(const FActorInitStateChangedBPDelegate Delegate)
{
	AActor* OwningActor = GetOwningActor();

	if (UGameInitStateSubsystem* Manager = UGameInitStateSubsystem::GetForActor(OwningActor); ensure(OwningActor && Manager))
	{
		return Manager->UnregisterActorInitStateDelegate(OwningActor, Delegate);
	}

	return false;
}

FString IGameInitStateInterface::GetDebugState(FName FeatureName) const
{
	return FString::Printf(TEXT("CurrentState: %s"), *GetCurrentInitStateFor(FeatureName).ToString());
}
--- Source\GameplayCore\Private\Components\GameInitStateSubsystem.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/GameInitStateSubsystem.h"
#include "Components/ActorFeatureData.h"
#include "Components/ActorFeatureState.h"

void UGameInitStateSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{

	Super::Initialize(Collection);

	CurrentStateChange = INDEX_NONE;
}

void UGameInitStateSubsystem::Deinitialize()
{
	Super::Deinitialize();

	#if WITH_EDITORONLY_DATA
	FCoreUObjectDelegates::GetPostGarbageCollect().RemoveAll(this);
	#endif
}

UGameInitStateSubsystem* UGameInitStateSubsystem::GetForActor(const AActor* Actor, const bool bOnlyGameWorlds)
{
	if (Actor)
	{
		if (const UWorld* ActorWorld = Actor->GetWorld())
		{
			if (bOnlyGameWorlds && (!ActorWorld->IsGameWorld() || ActorWorld->IsPreviewWorld()))
			{
				return nullptr;
			}

			return UGameInstance::GetSubsystem<UGameInitStateSubsystem>(ActorWorld->GetGameInstance());
		}
	}

	return nullptr;
}

void UGameInitStateSubsystem::RegisterFeatureImplementer(AActor* Actor, FName FeatureName, UObject* Implementer, const TArray<FGameplayTag>& InitStateTags)
{
	ensure(Actor == nullptr || FeatureName.IsNone());

	auto& [ActorClass, RegisteredStates, RegisteredDelegates] = FindOrAddActorData(Actor);

	FActorFeatureState* FoundState = RegisteredStates.FindByPredicate([FeatureName](const FActorFeatureState& State) { return State.FeatureName == FeatureName; });
	if (!FoundState)
	{
		// We've not found a matching Feature State, create a new one.
		FoundState = &RegisteredStates.Emplace_GetRef(FeatureName);
	}

	FoundState->Implementer = Implementer;
	FoundState->States = InitStateTags;
}

void UGameInitStateSubsystem::RemoveActorFeatureData(AActor* Actor)
{
	ActorFeatureMap.Remove(FObjectKey(Actor));
}

void UGameInitStateSubsystem::RemoveFeatureImplementer(AActor* Actor, UObject* Implementer)
{
	if (Actor == nullptr || Implementer == nullptr)
	{
		return;
	}
	TWeakObjectPtr WeakToRemove(Implementer);

	if (FActorFeatureData* FoundStruct = ActorFeatureMap.Find(FObjectKey(Actor)))
	{
		for (int32 i = FoundStruct->RegisteredStates.Num() - 1; i >= 0; i--)
		{
			// Clear if it matches or is stale
			const UObject* ResolvedObject = FoundStruct->RegisteredStates[i].Implementer.Get();

			if (ResolvedObject == Implementer || (!ResolvedObject && !FoundStruct->RegisteredStates[i].Implementer.IsExplicitlyNull()))
			{
				FoundStruct->RegisteredStates.RemoveAt(i);
			}
		}
	}
}

void UGameInitStateSubsystem::SetFeatureInitStatTags(AActor* Actor, FName FeatureName, TArray<FGameplayTag> InitStateTags)
{
	ensure(Actor == nullptr || FeatureName.IsNone());

	FActorFeatureData& FeatureData = FindOrAddActorData(Actor);

	FActorFeatureState* FoundState = FeatureData.RegisteredStates.FindByPredicate([FeatureName](const FActorFeatureState& State) { return State.FeatureName == FeatureName; });
	if (FoundState)
	{
		FoundState->States = InitStateTags;
		FoundState->CurrentState = InitStateTags[0];
	}

	ProcessFeatureStateChange(Actor, FoundState);
}

bool UGameInitStateSubsystem::IsInitStateCurrentOrLate(const FActorFeatureState& FeatureState, const FGameplayTag RelativeState)
{
	if (!FeatureState.IsValid())
	{
		return false;
	}

	if (FeatureState.CurrentState == RelativeState)
	{
		return true;
	}

	const int32 CurrentStateIndex = FeatureState.States.IndexOfByKey(FeatureState.CurrentState);
	const int32 RelateStateIndex = FeatureState.States.IndexOfByKey(RelativeState);

	return RelateStateIndex > CurrentStateIndex;
}

bool UGameInitStateSubsystem::HasFeatureReachedInitState(AActor* Actor, FName FeatureName, const FGameplayTag StateTag)
{
	FActorFeatureData* FeatureData = ActorFeatureMap.Find(Actor);
	const FActorFeatureState* FoundState = FeatureData->RegisteredStates.FindByPredicate([FeatureName](const FActorFeatureState& State) { return State.FeatureName == FeatureName; });
	return IsInitStateCurrentOrLate(*FoundState, StateTag);
}

FGameplayTag UGameInitStateSubsystem::GetInitStateForFeature(AActor* Actor, const FName FeatureName) const
{
	if (const FActorFeatureState* FoundState = FindFeatureStateStruct(ActorFeatureMap.Find(FObjectKey(Actor)), FeatureName, FGameplayTag()))
	{
		return FoundState->CurrentState;
	}

	return FGameplayTag();
}

TArray<FGameplayTag> UGameInitStateSubsystem::GetAllInitStatesForFeature(AActor* Actor, const FName FeatureName) const
{
	if (const FActorFeatureState* FoundState = FindFeatureStateStruct(ActorFeatureMap.Find(FObjectKey(Actor)), FeatureName, FGameplayTag()))
	{
		return FoundState->States;
	}
	return {};
}

FDelegateHandle UGameInitStateSubsystem::RegisterAndCallForActorInitState(AActor* Actor, FName FeatureName, FGameplayTag RequiredState, FActorInitStateChangedDelegate Delegate, const bool bCallImmediately)
{
	if (ensure(Actor && Delegate.IsBound()))
	{
		// We often register delegates before registering states
		FActorFeatureData& ActorStruct = FindOrAddActorData(Actor);

		const TSharedRef<FActorFeatureRegisteredDelegate> RegisteredDelegate = MakeShared<FActorFeatureRegisteredDelegate>(MoveTemp(Delegate), FeatureName, RequiredState);
		ActorStruct.RegisteredDelegates.Add(RegisteredDelegate);

		if (bCallImmediately)
		{
			// The shared ref keeps the delegate alive in case it gets unregistered
			CallDelegateForMatchingFeatures(Actor, *RegisteredDelegate);
		}

		return RegisteredDelegate->DelegateHandle;
	}

	return FDelegateHandle();
}

bool UGameInitStateSubsystem::UnregisterActorInitStateDelegate(AActor* Actor, FDelegateHandle& Handle)
{
	if (Actor && Handle.IsValid())
	{
		if (FActorFeatureData* ActorStruct = ActorFeatureMap.Find(FObjectKey(Actor)))
		{
			return RemoveActorFeatureDelegateFromList(ActorStruct->RegisteredDelegates, Handle);
		}
	}

	return false;
}

bool UGameInitStateSubsystem::RegisterAndCallForActorInitState(AActor* Actor, FName FeatureName, FGameplayTag RequiredState, FActorInitStateChangedBPDelegate Delegate, const bool bCallImmediately /*= true*/)
{
	if (ensure(Actor && Delegate.IsBound()))
	{
		// We often register delegates before registering states
		FActorFeatureData& ActorStruct = FindOrAddActorData(Actor);

		const TSharedRef<FActorFeatureRegisteredDelegate> RegisteredDelegate = MakeShared<FActorFeatureRegisteredDelegate>(MoveTemp(Delegate), FeatureName, RequiredState);
		ActorStruct.RegisteredDelegates.Add(RegisteredDelegate);

		if (bCallImmediately)
		{
			// The shared ref keeps the delegate alive in case it gets unregistered
			CallDelegateForMatchingFeatures(Actor, *RegisteredDelegate);
		}

		return true;
	}

	return false;
}

bool UGameInitStateSubsystem::UnregisterActorInitStateDelegate(AActor* Actor, const FActorInitStateChangedBPDelegate DelegateToRemove)
{
	if (Actor && DelegateToRemove.IsBound())
	{
		if (FActorFeatureData* ActorStruct = ActorFeatureMap.Find(FObjectKey(Actor)))
		{
			return RemoveActorFeatureDelegateFromList(ActorStruct->RegisteredDelegates, DelegateToRemove);
		}
	}

	return false;
}

void UGameInitStateSubsystem::ProcessFeatureStateChange(AActor* Actor, const FActorFeatureState* StateChange)
{
	StateChangeQueue.Emplace(Actor, *StateChange);

	if (CurrentStateChange == INDEX_NONE)
	{
		// Start processing in order
		CurrentStateChange = 0;

		while (CurrentStateChange < StateChangeQueue.Num())
		{
			CallFeatureStateDelegates(StateChangeQueue[CurrentStateChange].Key, StateChangeQueue[CurrentStateChange].Value);
			CurrentStateChange++;
		}

		// Done processing, clear it
		StateChangeQueue.Empty();
		CurrentStateChange = INDEX_NONE;
	}
}

void UGameInitStateSubsystem::CallFeatureStateDelegates(AActor* Actor, const FActorFeatureState& StateChange)
{
	FActorFeatureData* ActorStruct = ActorFeatureMap.Find(FObjectKey(Actor));
	FActorFeatureDelegateList QueuedDelegates;

	// Should only be called inside ProcessFeatureStateChange
	ensure(CurrentStateChange != INDEX_NONE);

	if (ActorStruct)
	{
		for (TSharedRef<FActorFeatureRegisteredDelegate>& DelegateRef : ActorStruct->RegisteredDelegates)
		{
			if (FActorFeatureRegisteredDelegate& RegisteredDelegate = *DelegateRef; RegisteredDelegate.RequiredFeatureName == StateChange.FeatureName && IsInitStateCurrentOrLate(
				StateChange,
				RegisteredDelegate.RequiredInitState))
			{
				// Queue delegates now in case the registered list changes during execution
				// If new delegates are registered, they are handled at registration time if bCallImmediately is used
				QueuedDelegates.Add(DelegateRef);
			}
		}
	}

	// Now execute the queued delegates, if they are removed Execute will skip them
	for (const TSharedRef<FActorFeatureRegisteredDelegate>& QueuedDelegate : QueuedDelegates)
	{
		QueuedDelegate->Execute(Actor, StateChange.FeatureName, StateChange.Implementer.Get(), StateChange.CurrentState);
	}
}

void UGameInitStateSubsystem::CallDelegateForMatchingFeatures(AActor* Actor, const FActorFeatureRegisteredDelegate& RegisteredDelegate)
{
	const FActorFeatureData* ActorStruct = ActorFeatureMap.Find(FObjectKey(Actor));

	if (ActorStruct == nullptr)
	{
		return;
	}

	// The feature name is mandatory on our version
	if (RegisteredDelegate.RequiredFeatureName.IsNone())
	{
		return;
	}

	if (const FActorFeatureState* FoundState = FindFeatureStateStruct(ActorStruct, RegisteredDelegate.RequiredFeatureName, RegisteredDelegate.RequiredInitState))
	{
		RegisteredDelegate.Execute(Actor, FoundState->FeatureName, FoundState->Implementer.Get(), FoundState->CurrentState);
	}
}

const FActorFeatureState* UGameInitStateSubsystem::FindFeatureStateStruct(const FActorFeatureData* FeatureData, const FName FeatureName, const FGameplayTag RequiredState)
{
	if (FeatureData)
	{
		for (const FActorFeatureState& State : FeatureData->RegisteredStates)
		{
			// We don't want to return invalid states even if it's the valid FeatureName
			if (State.IsValid() && State.FeatureName == FeatureName)
			{
				if (IsInitStateCurrentOrLate(State, RequiredState))
				{
					return &State;
				}
			}
		}
	}

	return nullptr;
}

bool UGameInitStateSubsystem::RemoveActorFeatureDelegateFromList(FActorFeatureDelegateList& DelegateList, FDelegateHandle& SearchHandle)
{
	for (int32 i = DelegateList.Num() - 1; i >= 0; i--)
	{
		if (DelegateList[i]->DelegateHandle == SearchHandle)
		{
			DelegateList[i]->bRemoved = true;
			DelegateList.RemoveAt(i);
			SearchHandle.Reset();
			return true;
		}
	}

	return false;
}

bool UGameInitStateSubsystem::RemoveActorFeatureDelegateFromList(FActorFeatureDelegateList& DelegateList, const FActorInitStateChangedBPDelegate& SearchDelegate)
{
	for (int32 i = DelegateList.Num() - 1; i >= 0; i--)
	{
		if (DelegateList[i]->BPDelegate == SearchDelegate)
		{
			DelegateList[i]->bRemoved = true;
			DelegateList.RemoveAt(i);
			return true;
		}
	}

	return false;
}

FActorFeatureData& UGameInitStateSubsystem::FindOrAddActorData(AActor* Actor)
{
	check(Actor)

	FActorFeatureData& FeatureData = ActorFeatureMap.FindOrAdd(Actor);
	if (!FeatureData.ActorClass.IsValid())
	{
		FeatureData.ActorClass = Actor->GetClass();
	}
	return FeatureData;
}
--- Source\GameplayCore\Private\GameplayTags\GameplayCoreTags.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "GameplayTags/GameplayCoreTags.h"

namespace GameplayCoreTags
{
	// Plugin bases init state tags
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_InitState_Spawned, "InitState.Spawned", "Actor/component has initially spawned and can be extended");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_InitState_DataAvailable, "InitState.DataAvailable", "All required data has been loaded/replicated and is ready for initialization");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_InitState_DataInitialized, "InitState.DataInitialized", "The available data has been initialized for this actor/component, but it is not ready for full gameplay");
	UE_DEFINE_GAMEPLAY_TAG_COMMENT(TAG_InitState_GameplayReady, "InitState.GameplayReady", "The actor/component is fully ready for active gameplay");
} // namespace GameplayCoreTags
--- Source\GameplayCore\Public\GameplayCore.h ---
﻿// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FGameplayCoreModule : public IModuleInterface
{
public:
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
--- Source\GameplayCore\Public\Components\ActorFeatureData.h ---
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "ActorFeatureRegisteredDelegate.h"
#include "ActorFeatureState.h"

#include "ActorFeatureData.generated.h"

/** Always stored as shared refs to avoid being destroyed during execution */
using FActorFeatureDelegateList = TArray<TSharedRef<FActorFeatureRegisteredDelegate>>;

USTRUCT(BlueprintType)
/** Information for each registered actor */
struct GAMEPLAYCORE_API FActorFeatureData
{
	GENERATED_BODY()

	/** Actor class for cross-referencing with the class callbacks */
	TWeakObjectPtr<UClass> ActorClass;

	/** All active features */
	TArray<FActorFeatureState> RegisteredStates;

	/** All delegates bound to this actor */
	FActorFeatureDelegateList RegisteredDelegates;

	/** Properly clear delegate list */
	~FActorFeatureData();
};
--- Source\GameplayCore\Public\Components\ActorFeatureRegisteredDelegate.h ---
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Components/ActorInitStateChangedParams.h"
#include "GameplayTagContainer.h"

#include "ActorFeatureRegisteredDelegate.generated.h"

/** Native delegate called when an actor feature changes init state */
DECLARE_DELEGATE_OneParam(FActorInitStateChangedDelegate, const FActorInitStateChangedParams&);
/** Blueprint delegate called when an actor feature changes init state */
DECLARE_DYNAMIC_DELEGATE_OneParam(FActorInitStateChangedBPDelegate, const FActorInitStateChangedParams&, Params);

/** Holds the list of feature delegates */
USTRUCT(BlueprintType)
struct GAMEPLAYCORE_API FActorFeatureRegisteredDelegate
{
	GENERATED_BODY()

	FActorFeatureRegisteredDelegate()
		: bRemoved(false) {};
	/** Construct from a native or BP Delegate */
	FActorFeatureRegisteredDelegate(FActorInitStateChangedDelegate&& InDelegate, FName InFeatureName = NAME_None, FGameplayTag InInitState = FGameplayTag());
	FActorFeatureRegisteredDelegate(FActorInitStateChangedBPDelegate&& InDelegate, FName InFeatureName = NAME_None, FGameplayTag InInitState = FGameplayTag());

	/** Call the appropriate native/bp delegate, this could invalidate this struct */
	void Execute(AActor* OwningActor, FName FeatureName, UObject* Implementer, FGameplayTag FeatureState) const;

	/** Delegate that is called on notification */
	FActorInitStateChangedDelegate Delegate;

	/** BP delegate that is called on notification */
	FActorInitStateChangedBPDelegate BPDelegate;

	/** A handle assigned to this delegate so it acts like a multicast delegate for removal */
	FDelegateHandle DelegateHandle;

	/** If this is not null, will only activate for specific feature names */
	FName RequiredFeatureName;

	/** If this is not null, will only activate for states >= to this */
	FGameplayTag RequiredInitState;

	/** Indicates this delegate has been removed and will soon be destroyed, do not execute */
	bool bRemoved;
};
--- Source\GameplayCore\Public\Components\ActorFeatureState.h ---
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameplayTagContainer.h"

#include "ActorFeatureState.generated.h"

/** State for a specific object implementing an actor feature, should this be in a map instead of an array? */
USTRUCT(BlueprintType)
struct GAMEPLAYCORE_API FActorFeatureState
{
	GENERATED_BODY()

	FActorFeatureState() {};

	FActorFeatureState(const FName InFeatureName)
		: FeatureName(InFeatureName) {}

	/** The feature this is tracking */
	FName FeatureName;

	/** The state when it was last registered */
	FGameplayTag CurrentState;

	TArray<FGameplayTag> States = {};

	/** The object implementing this feature, this can be null */
	TWeakObjectPtr<UObject> Implementer;

	bool IsValid() const { return !(FeatureName.IsNone() || States.IsEmpty() || !States.Contains(CurrentState)); }
};
--- Source\GameplayCore\Public\Components\ActorInitStateChangedParams.h ---
﻿// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "GameplayTagContainer.h"

#include "ActorInitStateChangedParams.generated.h"

/** Parameters struct for Init State change functions */
USTRUCT(BlueprintType)
struct GAMEPLAYCORE_API FActorInitStateChangedParams
{
	GENERATED_BODY()

	FActorInitStateChangedParams()
		: OwningActor(nullptr), Implementer(nullptr) {}

	FActorInitStateChangedParams(AActor* InOwningActor, const FName InFeatureName, UObject* InImplementer, const FGameplayTag InFeatureState)
		: OwningActor(InOwningActor), FeatureName(InFeatureName), Implementer(InImplementer), FeatureState(InFeatureState) {}

	/** The actor owning the feature that changed */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = Default)
	TObjectPtr<AActor> OwningActor;

	/** Name of the feature that changed */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = Default)
	FName FeatureName;

	/** The object (often a component) that implements the feature */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = Default)
	TObjectPtr<UObject> Implementer;

	/** The new state of the feature */
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = Default)
	FGameplayTag FeatureState;
};
--- Source\GameplayCore\Public\Components\GameInitStateInterface.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "UObject/Interface.h"
#include "GameInitStateInterface.generated.h"

class FActorInitStateChangedBPDelegate;
class UGameInitStateSubsystem;
struct FActorInitStateChangedParams;
struct FActorFeatureRegisteredDelegate;

/** Interface that can be implemented by actors/components to make interacting with the init state system easier */
UINTERFACE(NotBlueprintable)
class GAMEPLAYCORE_API UGameInitStateInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 *
 */
class GAMEPLAYCORE_API IGameInitStateInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:
	/** Returns the Actor this object is bound to, might be this object */
	virtual AActor* GetOwningActor() const;

	/** Gets the component manager corresponding to this object based on owning actor */
	UGameInitStateSubsystem* GetGameInitStateSubsystem() const;

	/** Returns the current feature state of this object, the default behavior is to query the manager */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	virtual FGameplayTag GetCurrentInitStateFor(FName& FeatureName) const;

	/** Checks the component manager to see if we have already reached the desired state or a later one */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	virtual bool HasReachedInitState(FName FeatureName, FGameplayTag DesiredState) const;

	/** Returns the current feature state of this object, the default behavior is to query the manager */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	virtual TArray<FGameplayTag> GetAllInitStatesFor(FName& FeatureName) const;

	/** Override to try and progress the default initialization path, likely using ContinueInitStateChain */
	virtual void CheckDefaultInitialization() {}

	/** Signature for handling a game feature state, this is not registered by default */
	virtual void OnActorInitStateChanged(const FActorInitStateChangedParams& Params) {}

	/** Call to register with the component manager during spawn if this is a game world */
	virtual void RegisterInitStateFeature(FName& FeatureName);

	/** Unregisters state and delegate binding with component manager */
	virtual void UnregisterInitStateFeature(FName& FeatureName);

	/** Call to bind the OnActorInitStateChanged function to the appropriate delegate on the component manager */
	virtual void BindOnActorInitStateChanged(FName FeatureName, FGameplayTag RequiredState, bool bCallIfReached);

	/** Binds a BP delegate to get called on a state change for this feature */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	virtual bool RegisterAndCallForActorInitState(FName FeatureName, FGameplayTag RequiredState, FActorInitStateChangedBPDelegate Delegate, bool bCallImmediately = true);

	/** Unbinds a BP delegate from changes to this feature */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	virtual bool UnregisterInitStateDelegate(FActorInitStateChangedBPDelegate Delegate);

	/** Returns Current state and any additional debug information for the active state */
	virtual FString GetDebugState(FName FeatureName) const;

protected:
	/** Default handle created from calling BindOnActorInitStateChanged */
	FDelegateHandle ActorInitStateChangedHandle;
};
--- Source\GameplayCore\Public\Components\GameInitStateSubsystem.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "ActorFeatureData.h"
#include "ActorFeatureRegisteredDelegate.h"
#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Subsystems/GameInstanceSubsystem.h"

#include "GameInitStateSubsystem.generated.h"

struct FActorFeatureState;

/**
 * This subsystem is highly based on ModularGameplay plugin's GameFrameworkComponentManager from Epic. To better handle initialization.
 *
 * The init state system can be used by components to coordinate their initialization using game-specific states specified as gameplay tags
 * IGameInitStateInterface provides a simple implementation that can be inherited by components
 */
UCLASS()
class GAMEPLAYCORE_API UGameInitStateSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

	/** Utility to get this manager from an actor, will return null if actor is null or not in a world */
	static UGameInitStateSubsystem* GetForActor(const AActor* Actor, bool bOnlyGameWorlds = true);

	/** Adds a new global actor feature state, either before or after an existing one. This will generally be called from game global or game feature initialization */
	void RegisterFeatureImplementer(AActor* Actor, FName FeatureName, UObject* Implementer, const TArray<FGameplayTag>& InitStateTags = {});

	/** Removes an actor and all of it's state information */
	void RemoveActorFeatureData(AActor* Actor);

	/** Removes an implementing object and any feature states it implements */
	void RemoveFeatureImplementer(AActor* Actor, UObject* Implementer);

	void SetFeatureInitStatTags(AActor* Actor, FName FeatureName, TArray<FGameplayTag> InitStateTags);

	/** Returns true if FeatureState comes after the second state (or is equal) */
	static bool IsInitStateCurrentOrLate(const FActorFeatureState& FeatureState, FGameplayTag RelativeState);

	/** Returns true if feature has reached query state or later */
	bool HasFeatureReachedInitState(AActor* Actor, FName FeatureName, FGameplayTag StateTag);

	/** Returns the earliest state found for the given feature */
	FGameplayTag GetInitStateForFeature(AActor* Actor, FName FeatureName) const;
	/** Returns the earliest state found for the given feature */
	TArray<FGameplayTag> GetAllInitStatesForFeature(AActor* Actor, FName FeatureName) const;

	/**
	 * Registers native delegate for feature state change notifications on a specific actor and may call it immediately
	 *
	 * @param Actor				The actor to listen for state changes to, if you don't have a specific actor call the Class version instead
	 * @param FeatureName		If not empty, only listen to state changes for the specified feature
	 * @param RequiredState		If specified, only activate if the init state of the feature is equal to or later than this
	 * @param Delegate			Native delegate to call
	 * @param bCallImmediately	If true and the actor feature is already in the specified state, call delegate immediately after registering
	 * @return DelegateHandle used for later removal
	 */
	FDelegateHandle RegisterAndCallForActorInitState(AActor* Actor, FName FeatureName, FGameplayTag RequiredState, FActorInitStateChangedDelegate Delegate, bool bCallImmediately = true);

	/** Removes a registered delegate bound to a specific actor */
	bool UnregisterActorInitStateDelegate(AActor* Actor, FDelegateHandle& Handle);

	/**
	 * Registers blueprint delegate for feature state change notifications on a specific actor and may call it immediately
	 *
	 * @param Actor				The actor to listen for state changes to, if you don't have a specific actor call the Class version instead
	 * @param FeatureName		If not empty, only listen to state changes for the specified feature
	 * @param RequiredState		If specified, only activate if the init state of the feature is equal to or later than this
	 * @param Delegate			Native delegate to call
	 * @param bCallImmediately	If true and the actor feature is already in the specified state, call delegate immediately after registering
	 * @return true if delegate was registered
	 */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	bool RegisterAndCallForActorInitState(AActor* Actor, FName FeatureName, FGameplayTag RequiredState, FActorInitStateChangedBPDelegate Delegate, bool bCallImmediately = true);

	/** Removes a registered delegate bound to a specific actor */
	UFUNCTION(BlueprintCallable, Category = "InitState")
	bool UnregisterActorInitStateDelegate(AActor* Actor, FActorInitStateChangedBPDelegate DelegateToRemove);

private:
	/** Add to queue for delegate processing */
	void ProcessFeatureStateChange(AActor* Actor, const FActorFeatureState* StateChange);

	/** Call all delegates for a specific actor feature change */
	void CallFeatureStateDelegates(AActor* Actor, const FActorFeatureState& StateChange);

	/** Call the specified delegate for all matching features on the actor, this should be passed a copy of the original delegate */
	void CallDelegateForMatchingFeatures(AActor* Actor, const FActorFeatureRegisteredDelegate& RegisteredDelegate);

	/** Find an appropriate state struct if it exists */
	static const FActorFeatureState* FindFeatureStateStruct(const FActorFeatureData* FeatureData, FName FeatureName, FGameplayTag RequiredState = FGameplayTag());

	/** Gets or creates the actor struct */
	FActorFeatureData& FindOrAddActorData(AActor* Actor);

	/** Try to remove delegate from list, returns true if it removed anything and clear handle if required */
	static bool RemoveActorFeatureDelegateFromList(FActorFeatureDelegateList& DelegateList, FDelegateHandle& SearchHandle);
	static bool RemoveActorFeatureDelegateFromList(FActorFeatureDelegateList& DelegateList, const FActorInitStateChangedBPDelegate& SearchDelegate);

	/** Position in state change queue, INDEX_NONE means not actively handling */
	int32 CurrentStateChange = INDEX_NONE;

	/** A queue of state changes to call delegates for, we don't want recursive callbacks */
	TArray<TPair<AActor*, FActorFeatureState>> StateChangeQueue;

	/** Actors that were registered as tracking feature state */
	TMap<FObjectKey, FActorFeatureData> ActorFeatureMap;
};
--- Source\GameplayCore\Public\GameplayTags\GameplayCoreTags.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "NativeGameplayTags.h"

namespace GameplayCoreTags
{
	GAMEPLAYCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_InitState_Spawned);
	GAMEPLAYCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_InitState_DataAvailable);
	GAMEPLAYCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_InitState_DataInitialized);
	GAMEPLAYCORE_API UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_InitState_GameplayReady);
} // namespace GameplayCoreTags
--- Source\InventorySystemCore\InventorySystemCore.Build.cs ---
﻿using UnrealBuildTool;

public class InventorySystemCore : ModuleRules
{
	public InventorySystemCore(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"DeveloperSettings",
				"GameplayAbilities",
				"NetCore",
				"EquipmentSystemCore"
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore"
			}
		);
	}
}
--- Source\InventorySystemCore\Private\InventorySystemCore.cpp ---
﻿#include "InventorySystemCore.h"

#define LOCTEXT_NAMESPACE "FInventorySystemCoreModule"

void FInventorySystemCoreModule::StartupModule() {}

void FInventorySystemCoreModule::ShutdownModule() {}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FInventorySystemCoreModule, InventorySystemCore)
--- Source\InventorySystemCore\Private\Components\InventorySystemComponent.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Components/InventorySystemComponent.h"

#include "Data/InventoryCache.h"
#include "Data/InventoryEntry.h"
#include "Engine/ActorChannel.h"
#include "Instances/ItemInstance.h"
#include "Net/UnrealNetwork.h"

UInventorySystemComponent::UInventorySystemComponent(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()), InventoryList(this)
{
	PrimaryComponentTick.bCanEverTick = false;
	SetIsReplicatedByDefault(true);

	bReplicateUsingRegisteredSubObjectList = true;
	bWantsInitializeComponent = true;
}

void UInventorySystemComponent::InitializeComponent()
{
	Super::InitializeComponent();

	// Cache initialization
	Cache = NewObject<UInventoryCache>(this);
}

void UInventorySystemComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, InventoryList);
}

bool UInventorySystemComponent::ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)
{
	bool bHasReplicated = Super::ReplicateSubobjects(Channel, Bunch, RepFlags);

	for (FInventoryEntry& Entry : InventoryList.Entries)
	{
		if (UItemInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			bHasReplicated |= Channel->ReplicateSubobject(Instance, *Bunch, *RepFlags);
		}
	}

	return bHasReplicated;
}

void UInventorySystemComponent::ReadyForReplication()
{
	Super::ReadyForReplication();

	// Register all item instances ready for replication with the actor component
	if (IsUsingRegisteredSubObjectList())
	{
		for (const FInventoryEntry& Entry : InventoryList.Entries)
		{
			if (UItemInstance* Instance = Entry.Instance; IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}
}

TArray<UItemInstance*> UInventorySystemComponent::AddItemDefinition(const TSubclassOf<UItemDefinition> ItemDefinition, const int32 Count)
{
	if (!IsValid(ItemDefinition))
	{
		return {};
	}

	TArray<UItemInstance*> Instances = InventoryList.Add(ItemDefinition, Count);

	// Register new instances for replication
	if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		for (UItemInstance* Instance : Instances)
		{
			if (IsValid(Instance))
			{
				AddReplicatedSubObject(Instance);
			}
		}
	}

	return Instances;
}

void UInventorySystemComponent::AddItemInstance(UItemInstance* ItemInstance)
{
	// Verification and authority
	if (!IsValid(ItemInstance))
	{
		return;
	}

	if (const AActor* OwnerActor = GetOwner(); !OwnerActor->HasAuthority())
	{
		return;
	}

	// InventoryList delegation
	InventoryList.AddItemInstance(ItemInstance);

	// Replication management at component level
	if (IsUsingRegisteredSubObjectList() && IsReadyForReplication())
	{
		if (!IsReplicatedSubObjectRegistered(ItemInstance))
		{
			AddReplicatedSubObject(ItemInstance);
		}
	}
}

void UInventorySystemComponent::RemoveItemInstance(UItemInstance* ItemInstance)
{
	InventoryList.Remove(ItemInstance);

	if (ItemInstance && IsUsingRegisteredSubObjectList())
	{
		RemoveReplicatedSubObject(ItemInstance);
	}
}

TArray<FInventoryEntryHandle> UInventorySystemComponent::GetAllStacks() const
{
	return InventoryList.GetAllHandles();
}

int32 UInventorySystemComponent::GetStackCountByDefinition(const TSubclassOf<UItemDefinition> DefinitionClass) const
{
	int32 Count = 0;
	for (const FInventoryEntry& Entry : InventoryList.Entries)
	{
		if (const UItemInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			if (Instance->GetDefinitionClass() == DefinitionClass)
			{
				++Count;
			}
		}
	}

	return Count;
}

int32 UInventorySystemComponent::GetTotalCountByDefinition(const TSubclassOf<UItemDefinition> ItemDefinitionClass) const
{
	int32 TotalCount = 0;
	for (const FInventoryEntry& Entry : InventoryList.Entries)
	{
		if (const UItemInstance* Instance = Entry.Instance; IsValid(Instance))
		{
			if (Instance->GetDefinitionClass() == ItemDefinitionClass)
			{
				TotalCount += Entry.StackCount;
			}
		}
	}

	return TotalCount;
}

UItemDefinition* UInventorySystemComponent::GetCachedDefinition(const TSubclassOf<UItemDefinition>& Class) const
{
	if (IsValid(Cache))
	{
		return Cache->GetCachedDefinition(Class);
	}
	if (IsValid(Class))
	{
		return NewObject<UItemDefinition>(GetOuter(), Class);
	}
	return nullptr;
}

void UInventorySystemComponent::PostInventoryEntryAdded(const FInventoryChangeData& Data)
{
	OnInventoryEntryAdded.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryEntryRemoved(const FInventoryChangeData& Data)
{
	OnInventoryEntryRemoved.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryEntryChanged(const FInventoryChangeData& Data)
{
	OnInventoryEntryChanged.Broadcast(Data);
}

void UInventorySystemComponent::PostInventoryChanged(const FInventoryChangeData& Data)
{
	OnInventoryChanged.Broadcast(Data);
}
--- Source\InventorySystemCore\Private\Data\InventoryCache.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryCache.h"

#include "Definitions/ItemDefinition.h"

UInventoryCache::UInventoryCache()
{
	// Register the cache for cleanup after garbage collection
	FCoreUObjectDelegates::GetPostGarbageCollect().AddUObject(this, &UInventoryCache::Clear);
}

UInventoryCache::~UInventoryCache()
{
	// Unregister from the garbage collection delegate
	FCoreUObjectDelegates::GetPostGarbageCollect().RemoveAll(this);
}

UItemDefinition* UInventoryCache::GetCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass)
{
	if (!IsValid(ItemDefinitionClass))
	{
		return nullptr;
	}

	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);

	if (const TWeakObjectPtr<UItemDefinition>* FoundDefinition = CachedDefinitionMap.Find(ItemDefinitionClass))
	{
		if (UItemDefinition* Definition = FoundDefinition->Get(); IsValid(Definition))
		{
			return Definition;
		}
	}

	// If the definition is not cached, create a new instance
	UItemDefinition* NewDefinition = NewObject<UItemDefinition>(this, ItemDefinitionClass);
	CachedDefinitionMap.Add(ItemDefinitionClass, NewDefinition);

	return NewDefinition;
}

bool UInventoryCache::IsCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const
{
	return CachedDefinitionMap.Contains(ItemDefinitionClass);
}

void UInventoryCache::Clear()
{
	// Lock the critical section to ensure thread-safe access to the cache
	FScopeLock Lock(&CacheLock);

	for (auto& Pair : CachedDefinitionMap)
	{
		if (Pair.Value != nullptr && !Pair.Value->IsRooted())
		{
			CachedDefinitionMap.Remove(Pair.Key);
		}
	}
}
--- Source\InventorySystemCore\Private\Data\InventoryChangeData.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryChangeData.h"

#include "Data/InventoryEntry.h"

FInventoryChangeData::FInventoryChangeData(const int32 InIndex, const FInventoryEntry& Entry, const EInventoryChangeType InChangeType)
{
	Index = InIndex;
	Instance = Entry.Instance;
	OldCount = Entry.LastStackCount;
	NewCount = Entry.StackCount;
	ChangeType = InChangeType;
}
--- Source\InventorySystemCore\Private\Data\InventoryEntry.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryEntry.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventoryList.h"
#include "Instances/ItemInstance.h"
#include "Log/InventorySystemLog.h"

void FInventoryEntry::PreReplicatedRemove(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogInventorySystem, Verbose, TEXT("%s: OnRemoveEntry (Non-Auth): %s. Count: %d"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), StackCount);
	}
}

void FInventoryEntry::PostReplicatedAdd(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(LogInventorySystem, Verbose, TEXT("%s: OnAddedEntry (Non-Auth): %s. Count: %d"), *GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()), *GetNameSafe(Instance), StackCount);
	}
}

void FInventoryEntry::PostReplicatedChange(const FInventoryList& InArraySerializer) const
{
	if (InArraySerializer.OwnerComponent)
	{
		UE_LOG(
			LogInventorySystem,
			Verbose,
			TEXT("%s: OnAddedChanged (Non-Auth): %s. Count: %d   LastCount: %d"),
			*GetNameSafe(InArraySerializer.OwnerComponent->GetOwner()),
			*GetNameSafe(Instance),
			StackCount,
			LastStackCount);
	}
}

FString FInventoryEntry::GetDebugString() const
{
	return FString::Printf(TEXT("(%s)"), *GetNameSafe(Instance));
}
--- Source\InventorySystemCore\Private\Data\InventoryList.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventoryList.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventoryEntry.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "Definitions/Fragments/ItemFragment_Storable.h"
#include "Instances/ItemInstance.h"

FInventoryList::FInventoryList()
	: OwnerComponent(nullptr) {}

FInventoryList::FInventoryList(UInventorySystemComponent* InOwnerComponent)
	: OwnerComponent(InOwnerComponent) {}

void FInventoryList::PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize)
{
	for (const int32 Index : RemovedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			Entry.LastStackCount = 0;

			Internal_OnEntryRemoved(Index, Entry);
		}
	}
}

void FInventoryList::PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize)
{
	for (const int32 Index : AddedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			Entry.LastStackCount = Entry.StackCount;

			Internal_OnEntryAdded(Index, Entry);
		}
	}
}

void FInventoryList::PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize)
{
	for (const int32 Index : ChangedIndices)
	{
		if (Entries.IsValidIndex(Index))
		{
			FInventoryEntry& Entry = Entries[Index];
			ensureMsgf(Entry.LastStackCount != INDEX_NONE, TEXT("LastStackCount is invalid (INDEX_NONE) for entry at index %d. Should replicate this change"), Index);

			Internal_OnEntryChanged(Index, Entry);
			Entry.LastStackCount = Entry.StackCount;
		}
	}
}

TArray<UItemInstance*> FInventoryList::Add(const TSubclassOf<UItemDefinition>& DefinitionClass, const int32 Count)
{
	if (!IsValid(DefinitionClass) || !OwnerComponent)
	{
		return {};
	}

	if (const AActor* OwnerActor = OwnerComponent->GetOwner(); !OwnerActor->HasAuthority())
	{
		return {};
	}

	// Check validity of the definition instance, and storable fragments
	if (!CanAdd(DefinitionClass, false))
	{
		return {};
	}

	TArray<UItemInstance*> Stacks = {};
	int32 RemainingCount = Count;

	const UItemDefinition* CachedDefinition = OwnerComponent->GetCachedDefinition(DefinitionClass);
	if (!IsValid(CachedDefinition))
	{
		return {};
	}

	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();

	// Handles stacking if the object is stackable
	if (StorableFragment->CanStack())
	{
		for (int32 Index = 0; Index < Entries.Num() && RemainingCount > 0; ++Index)
		{
			FInventoryEntry& Entry = Entries[Index];
			if (Entry.Instance->DefinitionClass != DefinitionClass)
			{
				continue;
			}

			const int32 FreeCount = StorableFragment->MaxStackCount - Entry.StackCount;
			const int32 ToAdd = FMath::Min(RemainingCount, FreeCount);

			if (ToAdd > 0)
			{
				Entry.StackCount += ToAdd;
				RemainingCount -= ToAdd;

				Internal_OnEntryChanged(Index, Entry);
				Entry.LastStackCount = Entry.StackCount;
				MarkItemDirty(Entry);

				Stacks.Add(Entry.Instance);
			}
		}
	}

	// Calculate the number of new stacks required
	const int32 MaxStackCount = StorableFragment->CanStack() ? StorableFragment->MaxStackCount : 1;
	const int32 NeededStacks = FMath::DivideAndRoundUp(RemainingCount, MaxStackCount);

	// Create new stacks for the rest
	for (int32 i = 0; i < NeededStacks && RemainingCount > 0; ++i)
	{
		if (!CanAdd(DefinitionClass, true))
		{
			break;
		}

		int32 CurrentCount = RemainingCount;
		if (UItemInstance* NewInstance = CreateItemInstance(DefinitionClass, CurrentCount))
		{
			Stacks.Add(NewInstance);
			RemainingCount = CurrentCount;
		}
	}

	return Stacks;
}

void FInventoryList::Remove(UItemInstance* Instance)
{
	for (auto EntryIterator = Entries.CreateIterator(); EntryIterator; ++EntryIterator)
	{
		if (FInventoryEntry Entry = *EntryIterator; Entry.Instance == Instance)
		{
			Internal_OnEntryRemoved(EntryIterator.GetIndex(), Entry);
			EntryIterator.RemoveCurrent();
			MarkArrayDirty();
		}
	}
}

void FInventoryList::AddItemInstance(UItemInstance* ItemInstance, const int32 Count)
{
	if (!IsValid(ItemInstance))
	{
		return;
	}

	// Check if the item can be added
	if (const TSubclassOf<UItemDefinition> DefinitionClass = ItemInstance->GetDefinitionClass(); !CanAdd(DefinitionClass, true))
	{
		return;
	}

	// Creating and configuring the new input
	FInventoryEntry& NewEntry = Entries.AddDefaulted_GetRef();
	const int32 NewIndex = Entries.Num() - 1;

	NewEntry.Instance = ItemInstance;
	NewEntry.StackCount = Count;
	NewEntry.LastStackCount = Count;

	// Notification du changement
	Internal_OnEntryAdded(NewIndex, NewEntry);
	MarkItemDirty(NewEntry);
}

void FInventoryList::AddItemInstance(const FInventoryEntry& Entry)
{
	AddItemInstance(Entry.Instance, Entry.StackCount);
}

FInventoryEntryHandle FInventoryList::FindHandleOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	if (!IsValid(ItemDefinition))
	{
		return {};
	}

	for (int Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance) && Entry.Instance->GetDefinitionClass() == ItemDefinition)
		{
			return FInventoryEntryHandle(Index, Entry);
		}
	}
	return {};
}

TArray<FInventoryEntryHandle> FInventoryList::GetHandlesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	TArray<FInventoryEntryHandle> Handles = {};

	if (!IsValid(ItemDefinition))
	{
		return Handles;
	}

	for (int32 Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance) && Entry.Instance->GetDefinitionClass()->IsInA(ItemDefinition))
		{
			FInventoryEntryHandle Handle = FInventoryEntryHandle(Index, Entry);
			Handles.Add(Handle);
		}
	}
	return Handles;
}

TArray<FInventoryEntryHandle> FInventoryList::GetAllHandles() const
{
	TArray<FInventoryEntryHandle> Handles = {};

	// Pre-reserve memory for the array
	Handles.Reserve(Entries.Num());

	for (int32 Index = 0; Index < Entries.Num(); ++Index)
	{
		if (const FInventoryEntry& Entry = Entries[Index]; IsValid(Entry.Instance))
		{
			FInventoryEntryHandle Handle = FInventoryEntryHandle(Index, Entry);
			Handles.Add(Handle);
		}
	}
	return Handles;
}

FInventoryEntry* FInventoryList::FindEntryOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	if (!IsValid(ItemDefinition))
	{
		return nullptr;
	}

	return Entries.FindByPredicate([ItemDefinition](const FInventoryEntry& Entry) { return Entry.Instance->GetDefinitionClass()->IsInA(ItemDefinition); });
}

TArray<FInventoryEntry*> FInventoryList::GetEntriesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition)
{
	TArray<FInventoryEntry*> InventoryEntries = {};

	if (!IsValid(ItemDefinition))
	{
		return InventoryEntries;
	}

	for (auto Entry : InventoryEntries)
	{
		if (IsValid(Entry->Instance) && Entry->Instance->GetDefinitionClass()->IsInA(ItemDefinition))
		{
			InventoryEntries.Add(Entry);
		}
	}
	return InventoryEntries;
}

TArray<FInventoryEntry*> FInventoryList::GetAllEntries()
{
	TArray<FInventoryEntry*> InventoryEntries;

	// Pre-reserve memory for the array
	InventoryEntries.Reserve(InventoryEntries.Num());

	for (auto Entry : InventoryEntries)
	{
		InventoryEntries.Add(Entry);
	}
	return InventoryEntries;
}

UItemInstance* FInventoryList::CreateItemInstance(const TSubclassOf<UItemDefinition>& DefinitionClass, int32& Count)
{
	AActor* OwnerActor = OwnerComponent->GetOwner();
	if (!OwnerActor->HasAuthority())
	{
		return nullptr;
	}

	// Get item definition instance
	UItemDefinition* CachedDefinition = OwnerComponent->GetCachedDefinition(DefinitionClass);
	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();
	if (!IsValid(StorableFragment))
	{
		return nullptr;
	}

	// Create a new entry
	FInventoryEntry& Entry = Entries.AddDefaulted_GetRef();
	const int32 Index = Entries.Num();

	Entry.Instance = NewObject<UItemInstance>(OwnerActor);
	Entry.Instance->SetDefinition(CachedDefinition);

	Entry.StackCount = StorableFragment->CanStack() ? FMath::Min(Count, StorableFragment->MaxStackCount) : 1;
	Count -= Entry.StackCount;

	for (auto Fragment : CachedDefinition->Fragments)
	{
		if (IsValid(Fragment))
		{
			Fragment->OnInstanceCreated(Entry.Instance);
		}
	}

	Internal_OnEntryAdded(Index, Entry);
	MarkItemDirty(Entry);

	return Entry.Instance;
}

bool FInventoryList::CanAdd(const TSubclassOf<UItemDefinition>& DefinitionClass, const bool CheckUniqueness)
{
	UItemDefinition* CachedDefinition = OwnerComponent->GetCachedDefinition(DefinitionClass);
	if (!IsValid(CachedDefinition) || !CachedDefinition->CanBeGiven(OwnerComponent))
	{
		return false;
	}

	// If the object has no storable fragment, it cannot be added to the inventory
	const UItemFragment_Storable* StorableFragment = CachedDefinition->FindFragmentByClass<UItemFragment_Storable>();
	if (!IsValid(StorableFragment))
	{
		return false;
	}

	// Check if the object is unique
	if (CheckUniqueness && StorableFragment->IsUnique())
	{
		if (const FInventoryEntryHandle Handle = FindHandleOfType(DefinitionClass); Handle.IsValid())
		{
			return false;
		}
	}
	return true;
}

void FInventoryList::Internal_OnEntryChanged(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Modified;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwnerComponent->PostInventoryEntryChanged(Data);
	OwnerComponent->PostInventoryChanged(Data);
}

void FInventoryList::Internal_OnEntryAdded(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Added;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwnerComponent->PostInventoryEntryAdded(Data);
	OwnerComponent->PostInventoryChanged(Data);
}

void FInventoryList::Internal_OnEntryRemoved(const int32 Index, const FInventoryEntry& Entry) const
{
	FInventoryChangeData Data;
	Data.Index = Index;
	Data.Instance = Entry.Instance;
	Data.ChangeType = EInventoryChangeType::Removed;
	Data.OldCount = Entry.LastStackCount;
	Data.NewCount = Entry.StackCount;

	OwnerComponent->PostInventoryEntryRemoved(Data);
	OwnerComponent->PostInventoryChanged(Data);
}
--- Source\InventorySystemCore\Private\Data\InventorySet.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Data/InventorySet.h"

#include "Components/InventorySystemComponent.h"
#include "Data/InventorySet_ItemSet.h"
#include "Log/InventorySystemLog.h"

void UInventorySet::GiveToInventorySystem(UInventorySystemComponent* InventorySystemComp)
{
	if (!IsValid(InventorySystemComp))
	{
		UE_LOG(LogInventorySystem, Error, TEXT("Tried to give InventorySet [%s] to an invalid InventorySystemComponent"), *GetFName().ToString());
	}

	for (auto& [ItemDefinition, Quantity] : Items)
	{
		if (!IsValid(ItemDefinition) || Quantity <= 0)
		{
			UE_LOG(LogInventorySystem, Error, TEXT("Tried to give an invalid item [%s] or with a invalid quantity [%d] in the InventorySet [%s]"), *GetNameSafe(ItemDefinition), Quantity, *GetFName().ToString());
			continue;
		}

		InventorySystemComp->AddItemDefinition(ItemDefinition, Quantity);
	}
}
--- Source\InventorySystemCore\Private\Definitions\ItemDefinition.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/ItemDefinition.h"

#include "Definitions/Fragments/ItemFragment.h"
#include "Framework/Notifications/NotificationManager.h"
#include "Log/InventorySystemLog.h"
#include "Settings/InventorySystemSettings.h"
#include "Settings/ItemFragmentRule.h"
#include "Widgets/Notifications/SNotificationList.h"

UItemDefinition::UItemDefinition(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.Get()) {}

void UItemDefinition::PostLoad()
{
	UObject::PostLoad();

	#if WITH_EDITORONLY_DATA
	PreviousFragments = Fragments;
	#endif
}

#if WITH_EDITOR
void UItemDefinition::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property && PropertyChangedEvent.GetPropertyName() == GET_MEMBER_NAME_CHECKED(UItemDefinition, Fragments))
	{
		// Check Fragment rules from the Inventory System Settings
		const UInventorySystemSettings* InventorySettings = GetDefault<UInventorySystemSettings>();
		ensureMsgf(IsValid(InventorySettings), TEXT("Invalid Inventory System Settings class get."));

		// Identify newly added fragments
		TMap<int32, UItemFragment*> NewFragments;
		TArray<TSubclassOf<UItemFragment>> ExistingClasses;

		for (int32 Index = 0; Index < Fragments.Num(); ++Index)
		{
			if (UItemFragment* const Fragment = Fragments[Index]; IsValid(Fragment))
			{
				if (!PreviousFragments.Contains(Fragment))
				{
					NewFragments.Add(Index, Fragment);
					continue;
				}
				ExistingClasses.Add(Fragment->GetClass());
			}
		}

		// Quick duplicate check
		for (auto& [Index, NewFragment] : NewFragments)
		{
			TSubclassOf<UItemFragment> NewFragmentClass = NewFragment->GetClass();
			if (ExistingClasses.Contains(NewFragmentClass))
			{
				FString Context = FString::Printf(TEXT("Duplicated item fragment on %s."), *this->GetName());

				FNotificationInfo Info(FText::FromString(Context));
				FSlateNotificationManager::Get().AddNotification(Info)->SetCompletionState(SNotificationItem::CS_Fail);

				UE_LOG(LogInventorySystem, Error, TEXT("Duplicated item fragment %s of %s."), *NewFragmentClass->GetName(), *this->GetName());

				if (Fragments.IsValidIndex(Index))
				{
					Fragments[Index] = nullptr;
				}
			}
		}

		// Check rule validity for new fragments
		for (auto& [Index, NewFragment] : NewFragments)
		{
			TSubclassOf<UItemFragment> NewFragmentClass = NewFragment->GetClass();
			if (const FItemFragmentRule* Rule = InventorySettings->FindRuleForClass(NewFragmentClass))
			{
				if (FString ErrorMessage; !Rule->IsRuleSatisfied(ExistingClasses, ErrorMessage))
				{
					FString Context = FString::Printf(TEXT("Fragment rule not filled on %s."), *this->GetName());

					FNotificationInfo Info(FText::FromString(Context));
					FSlateNotificationManager::Get().AddNotification(Info)->SetCompletionState(SNotificationItem::CS_Fail);

					UE_LOG(LogInventorySystem, Error, TEXT("Fragment rule not filled for fragment %s of %s. %s"), *NewFragmentClass->GetName(), *this->GetName(), *ErrorMessage);

					if (Fragments.IsValidIndex(Index))
					{
						Fragments[Index] = nullptr;
					}
				}
			}
		}

		// Previous fragments update
		PreviousFragments = Fragments;

		PostEditChange();
	}
}
#endif

const UItemFragment* UItemDefinition::FindFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (IsValid(FragmentClass))
	{
		for (const UItemFragment* Fragment : Fragments)
		{
			if (IsValid(Fragment) && Fragment->IsA(FragmentClass))
			{
				return Fragment;
			}
		}
	}

	return nullptr;
}

bool UItemDefinition::HasFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	const bool bFound = FindFragmentByClass(FragmentClass) != nullptr;
	return bFound;
}

bool UItemDefinition::CanBeGiven(UInventorySystemComponent* InventorySystemComponent)
{
	return K2_CanBeGiven(InventorySystemComponent);
}

bool UItemDefinition::K2_CanBeGiven_Implementation(UInventorySystemComponent* InventorySystemComponent)
{
	return true;
}
--- Source\InventorySystemCore\Private\Definitions\Fragments\ItemFragment.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment.h"
--- Source\InventorySystemCore\Private\Definitions\Fragments\ItemFragment_Consumable.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Consumable.h"
#include "Instances/ItemInstance.h"

#include "Instances/Components/ItemComponent_Consumable.h"
#include "Log/InventorySystemLog.h"

void UItemFragment_Consumable::OnInstanceCreated(UItemInstance* Instance)
{
	Super::OnInstanceCreated(Instance);

	if (const auto Component = Instance->AddComponent<UItemComponent_Consumable>(); IsValid(Component))
	{
		Component->CurrentUse = MaxUsesCount;
		Component->Initialize(Instance);
		return;
	}
	
	UE_LOG(LogInventorySystem, Warning, TEXT("Failed to add ItemComponent_Consumable to ItemInstance: %s"), *GetNameSafe(Instance));
}
--- Source\InventorySystemCore\Private\Definitions\Fragments\ItemFragment_Storable.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Definitions/Fragments/ItemFragment_Storable.h"

bool UItemFragment_Storable::CanStack() const
{
	return MaxStackCount > 1;
}

bool UItemFragment_Storable::IsUnique() const
{
	return (StorageFlags & static_cast<int32>(EItemStorageFlags::Unique)) != 0;
}
--- Source\InventorySystemCore\Private\Instances\ItemInstance.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/ItemInstance.h"

#include "Definitions/Fragments/ItemFragment.h"
#include "Net/UnrealNetwork.h"

UItemInstance::UItemInstance(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	OwningController = GetTypedOuter<APlayerController>();
}

void UItemInstance::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	UObject::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, DefinitionClass);
}

UInventorySystemComponent* UItemInstance::GetInventorySystemComponent() const
{
	if (!IsValid(OwningController))
	{
		return nullptr;
	}

	if (UInventorySystemComponent* InventorySystemComp = OwningController->GetComponentByClass<UInventorySystemComponent>(); IsValid(InventorySystemComp))
	{
		return InventorySystemComp;
	}
	return nullptr;
}

APlayerController* UItemInstance::GetOwningController() const
{
	return OwningController;
}

TSubclassOf<UItemDefinition> UItemInstance::GetDefinitionClass() const
{
	return DefinitionClass;
}

UItemDefinition* UItemInstance::GetDefinition() const
{
	return Definition.Get();
}

const UItemFragment* UItemInstance::FindFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (Definition.IsValid() && IsValid(FragmentClass))
	{
		return Definition->FindFragmentByClass(FragmentClass);
	}

	return nullptr;
}

bool UItemInstance::HasFragmentByClass(const TSubclassOf<UItemFragment> FragmentClass) const
{
	if (Definition.IsValid() && IsValid(FragmentClass))
	{
		return Definition->HasFragmentByClass(FragmentClass);
	}

	return false;
}

UItemComponent* UItemInstance::AddComponent(const TSubclassOf<UItemComponent> ComponentClass)
{
	if (UItemComponent* Component = NewObject<UItemComponent>(this, ComponentClass); IsValid(Component))
	{
		Components.Add(Component);
		return Component;
	}
	return nullptr;
}

void UItemInstance::SetDefinition(UItemDefinition* InDefinition)
{
	Definition = InDefinition;
	DefinitionClass = InDefinition->GetClass();
}

const UItemComponent* UItemInstance::FindComponentByClass(const TSubclassOf<UItemComponent> ComponentClass) const
{
	if (IsValid(ComponentClass))
	{
		for (const UItemComponent* Component : Components)
		{
			if (IsValid(Component) && Component->IsA(ComponentClass))
			{
				return Component;
			}
		}
	}

	return nullptr;
}
--- Source\InventorySystemCore\Private\Instances\Components\ItemComponent.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/ItemComponent.h"

void UItemComponent::Initialize(UItemInstance* InInstance)
{
	OwningInstance = InInstance;
}

UItemInstance* UItemComponent::GetOwningInstance()
{
	return OwningInstance;
}
--- Source\InventorySystemCore\Private\Instances\Components\ItemComponent_Consumable.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Instances/Components/ItemComponent_Consumable.h"

#include "Net/UnrealNetwork.h"

void UItemComponent_Consumable::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ThisClass, CurrentUse);
}
--- Source\InventorySystemCore\Private\Interfaces\InventorySystemInterface.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Interfaces/InventorySystemInterface.h"

// Add default functionality here for any IInventorySystemInterface functions that are not pure virtual.
--- Source\InventorySystemCore\Private\Library\InventoryFunctionLibrary.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Library/InventoryFunctionLibrary.h"

#include "Definitions/Fragments/ItemFragment.h"
#include "Definitions/ItemDefinition.h"

const UItemFragment* UInventoryFunctionLibrary::FindItemDefinitionFragment(const TSubclassOf<UItemDefinition> ItemDef, const TSubclassOf<UItemFragment> FragmentClass)
{
	if (IsValid(ItemDef) && IsValid(FragmentClass))
	{
		return GetDefault<UItemDefinition>(ItemDef)->FindFragmentByClass(FragmentClass);
	}
	return nullptr;
}
--- Source\InventorySystemCore\Private\Log\InventorySystemLog.cpp ---
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Log/InventorySystemLog.h"

DEFINE_LOG_CATEGORY(LogInventorySystem);
--- Source\InventorySystemCore\Private\Settings\InventorySystemSettings.cpp ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/InventorySystemSettings.h"

#include "Settings/ItemFragmentRule.h"

#if WITH_EDITOR
const FItemFragmentRule* UInventorySystemSettings::FindRuleForClass(const TSubclassOf<UItemFragment>& FragmentClass) const
{
	return FragmentRules.Find(FragmentClass);
}
#endif
--- Source\InventorySystemCore\Private\Settings\ItemFragmentRule.cpp ---
// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#include "Settings/ItemFragmentRule.h"

#include "Definitions/Fragments/ItemFragment.h"

bool FItemFragmentRule::IsRuleSatisfied(const TArray<TSubclassOf<UItemFragment>>& FragmentClasses, FString& ErrorContext) const
{
	bool bIsSatisfied = true;
	TArray<FString> BlockingClasses;
	TArray<FString> MissingClasses;

	for (TSubclassOf FragmentClass : FragmentClasses)
	{
		if (BlockedFragments.Contains(FragmentClass))
		{
			bIsSatisfied = false;
			BlockingClasses.Add(FragmentClass->GetName());
		}
	}

	for (TSubclassOf FragmentClass : RequiredFragments)
	{
		if (!FragmentClasses.Contains(FragmentClass))
		{
			bIsSatisfied = false;
			MissingClasses.Add(FragmentClass->GetName());
		}
	}

	const FString BlockingClassesString = FString::Join(BlockingClasses, TEXT(", "));
	const FString MissingClassesString = FString::Join(MissingClasses, TEXT(", "));

	ErrorContext = FString::Printf(TEXT("Blocking fragment classes : %s - Missing fragment classes : %s"), *BlockingClassesString, *MissingClassesString);

	return bIsSatisfied;
}
--- Source\InventorySystemCore\Public\InventorySystemCore.h ---
﻿#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FInventorySystemCoreModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
--- Source\InventorySystemCore\Public\Components\InventorySystemComponent.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/ActorComponent.h"
#include "CoreMinimal.h"
#include "Data/InventoryCache.h"
#include "Data/InventoryList.h"
#include "Definitions/ItemDefinition.h"

#include "InventorySystemComponent.generated.h"

class UEquipmentComponent;

/**
 * Multicast delegate that broadcasts inventory change events to all listeners
 * @param Data Detailed information about the inventory change including the affected item, previous state, and type of change
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInventoryChange, const FInventoryChangeData&, Data);

/**
 * @class UInventorySystemComponent
 * @see UActorComponent
 * @brief A component that manages an actor's inventory system with network replication support
 * @details Provides a flexible inventory system that can store, manage, and replicate items.
 * Supports dynamic item addition/removal, quantity tracking, and cache management for optimal performance.
 * Implements a robust replication system for multiplayer games. All operations are replicated to clients
 * and changes can be tracked through delegates.
 */

UCLASS(BlueprintType, ClassGroup = ("Equipment"), meta = (BlueprintSpawnableComponent))
class INVENTORYSYSTEMCORE_API UInventorySystemComponent : public UActorComponent
{
	GENERATED_BODY()

	friend FInventoryList;

public:
	UInventorySystemComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void InitializeComponent() override;
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;
	virtual void ReadyForReplication() override;
	// ~UObject

	/**
	 * Creates and adds new item instances to the inventory based on an item definition
	 * @param ItemDefinition The class definition of the item to create and add
	 * @param Count The quantity of items to add (must be positive)
	 * @return Array of created item instances, empty if addition failed or ItemDefinition is invalid
	 */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "Inventory")
	TArray<UItemInstance*> AddItemDefinition(TSubclassOf<UItemDefinition> ItemDefinition, int32 Count = 1);

	/**
	 * Adds an existing item instance to the inventory.
	 * @param ItemInstance The instance of the item to add.
	 */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "Inventory")
	void AddItemInstance(UItemInstance* ItemInstance);
	/**
	 * Removes an item instance from the inventory.
	 * @param ItemInstance The instance of the item to remove.
	 */
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = "Inventory")
	void RemoveItemInstance(UItemInstance* ItemInstance);

	/**
	 * Retrieves all items currently in the inventory.
	 * @return An array containing all item instances in the inventory.
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory") // BlueprintAuthorityOnly
	TArray<FInventoryEntryHandle> GetAllStacks() const;

	/**
	 * Calculates the sum of all stack counts for items matching the specified definition
	 * @param DefinitionClass The class of items to count
	 * @return Total quantity of all matching items across all stacks
	*/
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	int32 GetStackCountByDefinition(TSubclassOf<UItemDefinition> DefinitionClass) const;

	/**
	 * Counts the number of separate stacks containing items of the specified definition
	 * @param DefinitionClass The class of items to count stacks for
	 * @return Number of inventory slots containing the specified item type
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	int32 GetTotalCountByDefinition(TSubclassOf<UItemDefinition> DefinitionClass) const;

	/**
	 * Retrieves an item definition from the inventory cache
	 * @param DefinitionClass The class of the item definition to retrieve
	 * @return The item definition instance or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory", meta = (DeterminesOutputType = DefinitionClass))
	UItemDefinition* GetCachedDefinition(const TSubclassOf<UItemDefinition>& DefinitionClass) const;

	/**
	 * Called after an item is added to the inventory
	 * @param Data Information about the added inventory entry
	 */
	virtual void PostInventoryEntryAdded(const FInventoryChangeData& Data);

	/**
	 * Called after an item is removed from the inventory
	 * @param Data Information about the removed inventory entry
	 */
	virtual void PostInventoryEntryRemoved(const FInventoryChangeData& Data);

	/**
	 * Called after an inventory entry is modified
	 * @param Data Information about the modified inventory entry
	 */
	virtual void PostInventoryEntryChanged(const FInventoryChangeData& Data);

	/**
	 * Called after any change to the inventory
	 * @param Data Information about the inventory change
	 */
	virtual void PostInventoryChanged(const FInventoryChangeData& Data);

	/** Event fired when an item is added to the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryAdded;

	/** Event fired when an item is removed from the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryRemoved;

	/** Event fired when an inventory entry is modified */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryEntryChanged;

	/** Event fired after any change to the inventory */
	UPROPERTY(BlueprintAssignable, Category = "Inventory")
	FOnInventoryChange OnInventoryChanged;

private:
	/** Replicated list of inventory entries managed by this component. */
	UPROPERTY(Replicated)
	FInventoryList InventoryList;

	/** Inventory definitions cache. Not replicated */
	UPROPERTY()
	TObjectPtr<UInventoryCache> Cache;
};
--- Source\InventorySystemCore\Public\Data\InventoryCache.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "InventoryCache.generated.h"

class UItemDefinition;

/**
 * @class UInventoryCache
 * @see UObject
 * @brief A thread-safe cache system for ItemDefinitions
 * @details This class manages a cache of ItemDefinitions to improve performance by reducing object creation 
 * and providing thread-safe access to cached objects.
 */
UCLASS(HideDropdown, Hidden)
class INVENTORYSYSTEMCORE_API UInventoryCache : public UObject
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;

public:
	UInventoryCache();
	virtual ~UInventoryCache() override;

	/**
	 * Gets or creates a cached ItemDefinition instance in a thread-safe manner
	 * If the ItemDefinition is not in the cache, creates a new one and adds it to the cache
	 *
	 * @param ItemDefinitionClass The class of the ItemDefinition to retrieve or create
	 * @return A pointer to the cached or newly created ItemDefinition instance
	 * @see UItemDefinition
	 */
	UItemDefinition* GetCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass);

	/**
	 * Checks if an ItemDefinition of the specified class exists in the cache
	 *
	 * @param ItemDefinitionClass The class of the ItemDefinition to check
	 * @return True if the cache contains a valid instance of the specified class, false otherwise
	 * @see UItemDefinition
	 */
	bool IsCachedDefinition(const TSubclassOf<UItemDefinition>& ItemDefinitionClass) const;

private:
	/**
	 * Clears the cache of any ItemDefinitions that are no longer rooted
	 * This method is called after garbage collection and is thread-safe
	 * @see CacheLock
	 */
	void Clear();

	/**
	 * Storage for cached ItemDefinition instances
	 * Maps ItemDefinition classes to their corresponding cached instances
	 */
	UPROPERTY()
	TMap<TSubclassOf<UItemDefinition>, TWeakObjectPtr<UItemDefinition>> CachedDefinitionMap;

	/**
	 * Synchronization primitive for thread-safe access to the CachedDefinitionMap
	 * Used to prevent concurrent modifications to the cache
	 */
	FCriticalSection CacheLock;
};
--- Source\InventorySystemCore\Public\Data\InventoryChangeData.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "InventoryChangeData.generated.h"

struct FInventoryEntry;
class UItemInstance;

/**
 * Defines the types of changes that can occur to inventory entries
 */
UENUM(BlueprintType)
enum class EInventoryChangeType : uint8
{
	Added, ///< Item was added to the inventory
	Removed, ///< Item was removed from the inventory
	Modified ///< Item's properties were modified (e.g. stack count)
};

/**
 * @struct FInventoryChangeData
 * @see UItemInstance, FInventoryEntry, EInventoryChangeType
 * @brief Represents a data payload for tracking inventory item changes including addition, removal, and modification of items
 * @details Contains information about the affected item instance, its index in the inventory, the type of change, 
 *		  and stack count changes before and after the modification occurred. Used for notifying systems about
 *		  inventory state changes and maintaining synchronization.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryChangeData
{
	GENERATED_BODY()

	FInventoryChangeData() {}

	/**
	 * Constructs an inventory change data instance with the specified parameters
	 * @param InIndex The index of the inventory entry that was modified
	 * @param Entry The inventory entry containing the item instance and stack count
	 * @param InChangeType The type of modification that occurred
	 */
	FInventoryChangeData(const int32 InIndex, const FInventoryEntry& Entry, const EInventoryChangeType InChangeType = EInventoryChangeType::Added);

	/** 
	 * Zero-based index of the modified inventory entry
	 * Set to INDEX_NONE (-1) when the entry is invalid
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 Index = INDEX_NONE;

	/** 
	 * Reference to the affected item instance
	 * Contains the item's definition and properties
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	TObjectPtr<UItemInstance> Instance = nullptr;

	/** 
	 * Specifies whether the item was added, removed, or modified
	 * Defaults to Added when not specified
	 */
	UPROPERTY(BlueprintReadOnly)
	EInventoryChangeType ChangeType = EInventoryChangeType::Added;

	/** 
	 * Stack count before the inventory modification occurred
	 * Used to track quantity changes
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 OldCount = 0;

	/** 
	 * Stack count after the inventory modification occurred
	 * Represents the current quantity
	 */
	UPROPERTY(BlueprintReadOnly, Category = "Inventory")
	int32 NewCount = 0;

	/**
	 * Checks if this inventory change data is valid
	 * @return True if the index is valid (not INDEX_NONE), false otherwise
	 */
	bool IsValid() const { return Index != INDEX_NONE; }
};
--- Source\InventorySystemCore\Public\Data\InventoryEntry.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "InventoryEntry.generated.h"

class UItemInstance;

/**
 * @struct FInventoryEntry
 * @see FFastArraySerializerItem, UItemInstance, FInventoryList
 * @brief Represents a single inventory entry with item instance and stack management
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryEntry : public FFastArraySerializerItem
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;
	friend struct FInventoryList;
	friend struct FInventoryChangeData;
	friend struct FInventoryEntryHandle;

	FInventoryEntry() {};

	~FInventoryEntry() {};

	// FFastArraySerializer
	// Functions not virtual in FFAstArraySerializer because called by template
	void PreReplicatedRemove(const FInventoryList& InArraySerializer) const;
	void PostReplicatedAdd(const FInventoryList& InArraySerializer) const;
	void PostReplicatedChange(const FInventoryList& InArraySerializer) const;
	FString GetDebugString() const;
	// ~FFastArraySerializer

private:
	/**
	 * The actual item instance being stored in this inventory entry
	 * This instance contains the item's data and properties
	 */
	UPROPERTY()
	TObjectPtr<UItemInstance> Instance = nullptr;

	/**
	 * Current number of items in this stack
	 * Represents how many items of this type are grouped together
	 */
	UPROPERTY()
	int32 StackCount = 0;

	/** 
	 * Used to detect local stack changes without replication
	 * Helps with client-side prediction of stack modifications
	 * @note Not replicated - used for client prediction only
	 */
	UPROPERTY(NotReplicated)
	int32 LastStackCount = INDEX_NONE;
};
--- Source\InventorySystemCore\Public\Data\InventoryEntryHandle.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

#include "InventoryEntryHandle.generated.h"

class UItemInstance;

/**
 * @struct FInventoryEntryHandle
 * @see UItemInstance
 * @brief Represents a handle to an inventory entry, providing access to its index, item instance, and stack count.
 * @details This structure acts as a lightweight wrapper around inventory entry data, allowing access to the entry's
 * position in the inventory, its associated item instance, and the current stack count. Used throughout the inventory
 * system to reference and manipulate inventory entries.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryEntryHandle
{
	GENERATED_BODY()

	FInventoryEntryHandle()
		: ItemInstance(nullptr), StackCount(0) {}

	/**
	 * Creates a handle from an existing inventory entry
	 * @param InIndex Index of the entry in the inventory
	 * @param InEntry The inventory entry to reference
	 */
	FInventoryEntryHandle(const int32 InIndex, const FInventoryEntry& InEntry)
		: EntryIndex(InIndex)
	{
		EntryIndex = InIndex;
		ItemInstance = InEntry.Instance;
		StackCount = InEntry.StackCount;
	}

	/**
	 * Creates a handle with specified values
	 * @param InIndex Index of the entry in the inventory
	 * @param InInstance The item instance to reference
	 * @param InStackCount Number of items in the stack
	 */
	FInventoryEntryHandle(const int32 InIndex, UItemInstance* InInstance, const int32 InStackCount)
		: EntryIndex(InIndex), ItemInstance(InInstance), StackCount(InStackCount) {}

	/**
	 * Checks if this handle references a valid inventory entry
	 * @return true if the handle points to a valid entry, false otherwise
	 */
	bool IsValid() const { return EntryIndex != INDEX_NONE; }

	/**
	 * Index of the inventory entry in the inventory list
	 * Defaults to INDEX_NONE (-1) if the handle is invalid
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 EntryIndex = INDEX_NONE;

	/**
	 * The item instance associated with this inventory entry
	 * Contains the actual item data and properties
	 */
	UPROPERTY(BlueprintReadOnly)
	UItemInstance* ItemInstance;

	/**
	 * Current number of items in this stack
	 * Represents how many items of this type are grouped together
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 StackCount;
};
--- Source\InventorySystemCore\Public\Data\InventoryList.h ---
﻿// Copyright (C) [Year] [Company Name]. All Rights Reserved.

#pragma once

#include "InventoryChangeData.h"
#include "InventoryEntry.h"
#include "InventoryEntryHandle.h"
#include "Net/Serialization/FastArraySerializer.h"

#include "InventoryList.generated.h"

class UItemDefinition;
struct FNetDeltaSerializeInfo;
struct FReplicationFlags;

/**
 * @class FInventoryList
 * @see FFastArraySerializer
 * @brief A replicated container that manages a list of inventory entries
 * @details Handles the storage, replication, and management of inventory entries including
 * addition, removal, and modification of items. Utilizes FastArraySerializer for efficient
 * network replication and provides interfaces for item manipulation and querying.
 */
USTRUCT(BlueprintType)
struct INVENTORYSYSTEMCORE_API FInventoryList : public FFastArraySerializer
{
	GENERATED_BODY()

	friend class UInventorySystemComponent;
	friend FInventoryEntry;

	FInventoryList();
	FInventoryList(UInventorySystemComponent* InOwnerComponent);

	// FFastArraySerializer
	// Functions not virtual in FFAstArraySerializer because called by template
	/**
	 * Called before entries are removed during replication
	 * @param RemovedIndices Indices of entries being removed
	 * @param FinalSize Final size of the array after removal
	 */
	void PreReplicatedRemove(const TArrayView<int32> RemovedIndices, int32 FinalSize);

	/**
	 * Called after entries are added during replication
	 * @param AddedIndices Indices of newly added entries
	 * @param FinalSize Final size of the array after addition
	 */
	void PostReplicatedAdd(const TArrayView<int32> AddedIndices, int32 FinalSize);

	/**
	 * Called after entries are changed during replication
	 * @param ChangedIndices Indices of modified entries
	 * @param FinalSize Current size of the array
	 */
	void PostReplicatedChange(const TArrayView<int32> ChangedIndices, int32 FinalSize);
	// void PostReplicatedReceive(const FFastArraySerializer::FPostReplicatedReceiveParameters& Parameters);

	bool NetDeltaSerialize(FNetDeltaSerializeInfo& DeltaParams) { return FastArrayDeltaSerialize<FInventoryEntry, FInventoryList>(Entries, DeltaParams, *this); }
	// ~FFastArraySerializer

	/**
	 * Adds an item to the inventory list from its definition.
	 * @param DefinitionClass The item definition class to add.
	 * @param Count The number of items to add.
	 * @return Item instances if added successfully, otherwise returns an empty array.
	 */
	TArray<UItemInstance*> Add(const TSubclassOf<UItemDefinition>& DefinitionClass, int32 Count = 1);
	/**
	 * Removes an item from the inventory.
	 * @param Instance The item instance to remove.
	 */
	void Remove(UItemInstance* Instance);

	void AddItemInstance(UItemInstance* ItemInstance, int32 Count = 1);

	void AddItemInstance(const FInventoryEntry& Entry);

	/**
	 * Finds the handle of the first entry of a specific item definition.
	 * @param ItemDefinition The item definition class to find.
	 * @return The inventory entry handle if found, otherwise an invalid handle.
	 */
	FInventoryEntryHandle FindHandleOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);
	/**
	 * Gets all handles of a specific item definition.
	 * @param ItemDefinition The item definition class to find.
	 * @return An array of inventory entry handles.
	 */
	TArray<FInventoryEntryHandle> GetHandlesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);
	/**
	 * Gets all handles in the inventory.
	 * @return An array of all inventory entry handles.
	 */
	TArray<FInventoryEntryHandle> GetAllHandles() const;

	/**
	 * Finds the first entry of a specific item definition.
	 * @param ItemDefinition The item definition class to find.
	 * @return The inventory entry if found, otherwise nullptr.
	 */
	FInventoryEntry* FindEntryOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);

	/**
	 * Gets all entries matching the specified item definition
	 * @param ItemDefinition The item definition class to find
	 * @return Array of inventory entries matching the definition
	 * @see FInventoryEntry
	 */
	static TArray<FInventoryEntry*> GetEntriesOfType(const TSubclassOf<UItemDefinition>& ItemDefinition);
	/**
	 * Gets all entries currently in the inventory
	 * @return Array containing all inventory entries
	 * @see FInventoryEntry
	 */
	static TArray<FInventoryEntry*> GetAllEntries();

protected:
	/** The inventory system component that owns this list. Not replicated */
	UPROPERTY(NotReplicated)
	TObjectPtr<UInventorySystemComponent> OwnerComponent;

	/** Array of inventory entries managed by this list */
	UPROPERTY()
	TArray<FInventoryEntry> Entries;

	UItemInstance* CreateItemInstance(const TSubclassOf<UItemDefinition>& DefinitionClass, int32& Count);

	/**
	 * Checks if an item of the specified definition can be added
	 * @param DefinitionClass The item definition class to check
	 * @param CheckUniqueness
	 * @return True if the item can be added, false otherwise
	 */
	bool CanAdd(const TSubclassOf<UItemDefinition>& DefinitionClass, bool CheckUniqueness = true);

	/**
	 * Called when an entry is changed.
	 * @param Index The index of the changed entry.
	 * @param Entry The changed entry.
	 */
	void Internal_OnEntryChanged(int32 Index, const FInventoryEntry& Entry) const;
	/**
	 * Called when an entry is added.
	 * @param Index The index of the added entry.
	 * @param Entry The added entry.
	 */
	void Internal_OnEntryAdded(int32 Index, const FInventoryEntry& Entry) const;
	/**
	 * Called when an entry is removed.
	 * @param Index The index of the removed entry.
	 * @param Entry The removed entry.
	 */
	void Internal_OnEntryRemoved(int32 Index, const FInventoryEntry& Entry) const;
};

// Required to specify that this structure uses a NetDeltaSerializer method to help serialization operation decision
template <> struct TStructOpsTypeTraits<FInventoryList> : TStructOpsTypeTraitsBase2<FInventoryList>
{
	enum
	{
		WithNetDeltaSerializer = true
	};
};
--- Source\InventorySystemCore\Public\Data\InventorySet.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"

#include "InventorySet.generated.h"

struct FInventorySet_ItemSet;
class UItemDefinition;
class UInventorySystemComponent;

/**
 * @class UInventorySet
 * @see UPrimaryDataAsset
 * @brief Data asset storing a predefined set of items to be granted together
 * @details Used to define groups of items that can be given to an inventory system component at once.
 * Commonly used for starting equipment, loot drops, or quest rewards.
 */
UCLASS()
class INVENTORYSYSTEMCORE_API UInventorySet : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	/**
	 * Grants all items defined in this set to the specified inventory system component
	 * @param InventorySystemComp The target inventory component that will receive the items
	 * @see UInventorySystemComponent
	 */
	void GiveToInventorySystem(UInventorySystemComponent* InventorySystemComp);

protected:
	/**
	 * Collection of item definitions and their quantities to be granted together
	 * Each entry specifies an item type and how many of that item should be given
	 */
	UPROPERTY(EditDefaultsOnly, Category = "Items", meta = (TitleProperty = "[{Quantity}] {ItemDefinition}"))
	TArray<FInventorySet_ItemSet> Items;
};
--- Source\InventorySystemCore\Public\Data\InventorySet_ItemSet.h ---
#pragma once

#include "Definitions/ItemDefinition.h"

#include "InventorySet_ItemSet.generated.h"

/**
 * @class FInventorySet_ItemSet
 * @see UItemDefinition
 * @brief Data structure used by the InventorySet to manage item definitions and quantities
 * @details Represents a set of items to be added to an inventory, containing both the item definition
 * and the quantity to be given. Used primarily for initial inventory setup and item grants.
 */
USTRUCT(BlueprintType)
struct FInventorySet_ItemSet
{
	GENERATED_BODY()

	/**
	 * Checks if the item in this set can be equipped
	 * @return True if the item definition is valid and represents an equippable item
	 */
	bool IsEquipable() const;

	/** The item definition class that defines the type of item to be given */
	UPROPERTY(EditDefaultsOnly, DisplayName = "Definition")
	TSubclassOf<UItemDefinition> ItemDefinition = nullptr;

	/** The number of items of this type to give */
	UPROPERTY(EditDefaultsOnly)
	int Quantity = 1.0f;
};
--- Source\InventorySystemCore\Public\Definitions\ItemDefinition.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "ItemDefinition.generated.h"

class UInventorySystemComponent;
class UItemFragment;

/**
 * @class UItemDefinition
 * @see UObject
 * @brief Data asset definition of an item that can be given/owned by a character
 * @details Represents a template for items in the inventory system. Contains basic item information 
 * like name and description, and can be extended with fragments for additional functionality.
 * This is an abstract class that should be inherited to create specific item types.
 */
UCLASS(Blueprintable, Abstract, BlueprintType)
class INVENTORYSYSTEMCORE_API UItemDefinition : public UObject
{
	GENERATED_BODY()

public:
	UItemDefinition(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void PostLoad() override;
	#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
	#endif
	// ~UObject

	/**
	 * Searches for a specific fragment type in this item definition
	 * @param FragmentClass The class type of fragment to find
	 * @return The found fragment instance, or nullptr if not found
	 * @see UItemFragment
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UItemFragment* FindFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;

	/**
	 * Checks if this item definition contains a specific fragment type
	 * @param FragmentClass The class type of fragment to check
	 * @return True if the fragment exists, false otherwise
	 * @see UItemFragment
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false)
	bool HasFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;
	/**
	 * Template version of FindFragmentByClass for convenient type-safe fragment access
	 * @tparam T The specific fragment class type to find
	 * @return Typed pointer to the found fragment, or nullptr if not found
	 * @see FindFragmentByClass
	 */
	template <typename T> const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	/**
	 * Checks if this item can be given to the specified inventory
	 * @param InventorySystemComponent The target inventory component
	 * @return True if the item can be given, false otherwise
	 * @see UInventorySystemComponent
	 */
	virtual bool CanBeGiven(UInventorySystemComponent* InventorySystemComponent);

	/**
	 * Blueprint accessible version of CanBeGiven
	 * @param InventorySystemComponent The target inventory component
	 * @return True if the item can be given, false otherwise
	 * @see CanBeGiven
	 */
	UFUNCTION(BlueprintNativeEvent, BlueprintPure)
	bool K2_CanBeGiven(UInventorySystemComponent* InventorySystemComponent);

	// TODO : Add item categories

	/** The display name of the item shown in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Definition")
	FText DisplayName;

	/** Detailed description of the item shown in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Definition")
	FText Description;

	/** Collection of fragments that define the item's behavior and properties */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Fragments", Instanced)
	TArray<TObjectPtr<UItemFragment>> Fragments;

	#if WITH_EDITORONLY_DATA
	UPROPERTY(Transient)
	TArray<UItemFragment*> PreviousFragments;
	#endif
};
--- Source\InventorySystemCore\Public\Definitions\Fragments\ItemFragment.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "ItemFragment.generated.h"

class UItemInstance;

/**
 * @class UItemFragment
 * @see UItemDefinition
 * @brief Represents a fragment of an item definition, allowing definition extension.
 * @details Item fragments are components that can be attached to item definitions to extend their functionality.
 * They are instantiated along with the item instance and can contain both data and behavior.
 */
UCLASS(DefaultToInstanced, EditInlineNew, Blueprintable, BlueprintType, Abstract)
class INVENTORYSYSTEMCORE_API UItemFragment : public UObject
{
	GENERATED_BODY()

public:
	/**
	 * Called when the ItemInstance is created and this fragment is attached to it
	 * @param Instance The item instance that owns this fragment
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance){}
};
--- Source\InventorySystemCore\Public\Definitions\Fragments\ItemFragment_Consumable.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemFragment.h"

#include "ItemFragment_Consumable.generated.h"

class UGameplayEffect;

/**
 * @class UItemFragment_Consumable
 * @see UItemFragment
 * @brief Fragment that adds consumable behavior to an item
 * @details Allows items to be consumed and apply gameplay effects to the user. 
 * The fragment can be configured with multiple effects and a maximum number of uses.
 */
UCLASS(DefaultToInstanced, EditInlineNew, Blueprintable, BlueprintType, DisplayName = "Consumable")
class INVENTORYSYSTEMCORE_API UItemFragment_Consumable : public UItemFragment
{
	GENERATED_BODY()

public:
	/**
	 * Initializes the consumable fragment when the item instance is created
	 * @param Instance The item instance that owns this fragment
	 */
	virtual void OnInstanceCreated(UItemInstance* Instance) override;

	/**
	 * List of gameplay effects to apply when the item is consumed
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Consumable")
	TArray<TSubclassOf<UGameplayEffect>> Effects = {};

	/**
	 * Maximum number of times this item can be consumed
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Consumable", meta = (ClampMin = 1))
	int32 MaxUsesCount = 1;
};
--- Source\InventorySystemCore\Public\Definitions\Fragments\ItemFragment_Storable.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemFragment.h"
#include "ItemFragment_Storable.generated.h"

/**
 * @enum EItemStorageFlags
 * @brief Enum defining various storage flags for items. These flags can be combined to describe the storage properties of an item.
 */
UENUM(BlueprintType, meta = (Bitflags, UseEnumValuesAsPinnedByValue = true))
enum class EItemStorageFlags : uint8
{
	None = 0 UMETA(ToolTip = "No special storage properties.", Hidden),
	Unique = 1 UMETA(ToolTip = "This item should be unique in the inventory. For stacks, only one stack can exist."),
	PersistentOnDeath = 2 UMETA(ToolTip = "The item can't be lost on player death")
};

ENUM_CLASS_FLAGS(EItemStorageFlags);

/**
 * @class UItemFragment_Storable
 * @see UItemFragment
 * @brief UItemFragment_Storable defines storage properties for an item. This fragment can be attached to item definitions to specify how they behave in inventory systems.
 */
UCLASS(DisplayName = "Storable")
class INVENTORYSYSTEMCORE_API UItemFragment_Storable : public UItemFragment
{
	GENERATED_BODY()

public:
	/** Visual representation of the item in the UI */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Appearance")
	FSlateBrush UIBrush;

	/** Determines how many items can be grouped in a single inventory slot. The minimum value is 1 for unstackable items */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (ClampMin = 1))
	int MaxStackCount = 1;

	/** Individual item weight in kilograms. Used for inventory weight calculations. Minimum value is 0 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (ClampMin = 0, Units = "kg"))
	float Weight = 0.f;

	/** Combination of EItemStorageFlags that define special storage behaviors like uniqueness or persistence */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Storage", meta = (Bitmask, BitmaskEnum = "/Script/InventorySystemCore.EItemStorageFlags"))
	int32 StorageFlags;

	/**
	 * Checks if this item can be stacked with others of the same type
	 * @return True if the item can be stacked (MaxStackCount > 1), false otherwise
	 */
	UFUNCTION(BlueprintCallable)
	bool CanStack() const;

	/**
	 * Checks if this item is marked as unique in storage
	 * @return True if the item has the Unique storage flag set
	 */
	UFUNCTION(BlueprintCallable)
	bool IsUnique() const;
};
--- Source\InventorySystemCore\Public\Instances\ItemInstance.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "Components/InventorySystemComponent.h"
#include "Components/ItemComponent.h"
#include "CoreMinimal.h"
#include "Definitions/ItemDefinition.h"
#include "UObject/Object.h"

#include "ItemInstance.generated.h"

struct FInventoryList;

/**
 * @class UItemInstance
 * @see UObject
 * @brief This class represents an instance of an item within the inventory system. It holds a reference
 * to the item definition and provides functionalities related to item management.
 * This class uses a component-based architecture to allow for flexible
 * and efficient item instances. Each instance can have multiple components
 * that add specific functionalities.
 */
UCLASS(BlueprintType, Blueprintable)
class INVENTORYSYSTEMCORE_API UItemInstance : public UObject
{
	GENERATED_BODY()

	friend struct FInventoryList;

public:
	explicit UItemInstance(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

	// UObject
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	virtual bool IsSupportedForNetworking() const override { return true; }
	// ~UObject

	/**
	 * Gets the inventory system component that owns this item instance
	 * @return The owning inventory system component
	 */
	UFUNCTION(BlueprintCallable, Category = "Instance")
	UInventorySystemComponent* GetInventorySystemComponent() const;

	/**
	 * Gets the player controller that owns this item instance
	 * @return The owning player controller
	 */
	UFUNCTION(BlueprintCallable, Category = "Instance")
	APlayerController* GetOwningController() const;
	/**
	 * Gets the owning controller cast to the specified type
	 * @return The owning controller cast to type T, or nullptr if cast fails
	 */
	template <typename T> const T* GetOwningController() const { return Cast<T>(GetOwningController(T::StaticClass())); }

	/**
	 * Gets the item definition class associated with this instance.
	 * @return The item definition class.
	 */
	UFUNCTION(BlueprintCallable)
	TSubclassOf<UItemDefinition> GetDefinitionClass() const;

	/**
	 * Gets the item definition associated with this instance, cached by the Inventory System Component.
	 * @return The item definition default object.
	 */
	UFUNCTION(BlueprintCallable)
	UItemDefinition* GetDefinition() const;

	/**
	 * Try to find fragment of class FragmentClass in this item's definition
	 * @param FragmentClass Class of the ItemFragment to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	const UItemFragment* FindFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;
	/**
	 * Try to find fragment of class FragmentClass in this item's definition
	 */
	template <typename T> const T* FindFragmentByClass() const { return Cast<T>(FindFragmentByClass(T::StaticClass())); }

	UFUNCTION(BlueprintCallable, BlueprintPure = false)
	bool HasFragmentByClass(TSubclassOf<UItemFragment> FragmentClass) const;

	/**
	 *	Try to find fragment of class FragmentClass in this item definition
	 *	@param ComponentClass Class of the ItemFragment to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = FragmentClass))
	UItemComponent* AddComponent(TSubclassOf<UItemComponent> ComponentClass);
	/**
	 *	Try to find fragment of class FragmentClass in this item definition
	 */
	template <typename T> T* AddComponent() { return Cast<T>(AddComponent(T::StaticClass())); }

	/**
	 *	Try to find component of class ComponentClass of this item instance
	 *	@param ComponentClass Class of the Item Instance's component to search
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure = false, meta = (DeterminesOutputType = ComponentClass))
	const UItemComponent* FindComponentByClass(TSubclassOf<UItemComponent> ComponentClass) const;
	/**
	 * Try to find a component of type T attached to this item instance
	 * @return The found component cast to type T, or nullptr if not found or cast fails
	 */
	template <typename T> const T* FindComponentByClass() const { return Cast<T*>(FindComponentByClass(T::StaticClass())); }

protected:
	/**
	 * Sets the item definition class for this instance.
	 * @param InDefinition - The item definition to set.
	 */
	void SetDefinition(UItemDefinition* InDefinition);

	/** The item definition that this instance is based on.
	 * Only replicate the class.
	 */
	UPROPERTY(Replicated)
	TSubclassOf<UItemDefinition> DefinitionClass;

	/** The Item Definition default object, cached by the local InventorySystemComponent cache */
	UPROPERTY()
	TWeakObjectPtr<UItemDefinition> Definition;

	/** Components attached to this item instance providing additional functionality */
	UPROPERTY(Replicated)
	TArray<UItemComponent*> Components;

	/** Cached pointer to the player controller that owns this item instance */
	UPROPERTY(Transient)
	mutable APlayerController* OwningController;
};
--- Source\InventorySystemCore\Public\Instances\Components\ItemComponent.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "ItemComponent.generated.h"

class UItemInstance;

/**
 * @class UItemComponent
 * @see UItemInstance
 * @brief Base class for modular components that can be added to item instances.
 * @details This class serves as the foundation for creating specialized components
 * that add specific functionalities to item instances. Components are attached to item
 * instances to extend their capabilities. Each component can implement its own replication
 * logic and functionality while maintaining a modular design approach.
 */
UCLASS(Abstract)
class INVENTORYSYSTEMCORE_API UItemComponent : public UObject
{
	GENERATED_BODY()

public:
	// UObject
	/**
	 * Sets up property replication for the component
	 * @param OutLifetimeProps Array of lifetime properties to be filled with replication properties
	 */
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override { Super::GetLifetimeReplicatedProps(OutLifetimeProps); };
	// ~UObject
	
	virtual void Initialize(UItemInstance* InInstance);
	
	/**
	 * Returns the item instance that owns this fragment
	 * @return The owning item instance, or nullptr if not attached
	 */
	UFUNCTION(BlueprintCallable, BlueprintPure)
	UItemInstance* GetOwningInstance();

protected:
	
	/** The item instance that owns this fragment instance */
	UPROPERTY(Transient)
	TObjectPtr<UItemInstance> OwningInstance = nullptr;
};
--- Source\InventorySystemCore\Public\Instances\Components\ItemComponent_Consumable.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "ItemComponent.h"
#include "ItemComponent_Consumable.generated.h"

class UGameplayAbility;

/**
 * @class UItemComponent_Consumable
 * @see UItemComponent
 * @brief Component for items that can be consumed or used over time.
 * @details This component tracks the usage state of consumable items, such as 
 * potions, food, or other items that can be depleted. It maintains a replicated 
 * current use value that represents the item's consumption progress.
 */
UCLASS()
class INVENTORYSYSTEMCORE_API UItemComponent_Consumable : public UItemComponent
{
	GENERATED_BODY()

public:
	// UObject
	/**
	 * Sets up property replication for the consumable component
	 * @param OutLifetimeProps Array of properties to be replicated
	 */
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TSubclassOf<UGameplayAbility> AbilityClass;
	
	/** Tracks the current usage progress of the consumable item. 0 means unused, higher values indicate usage progress */
	UPROPERTY(Replicated)
	float CurrentUse = 0.0f;

};
--- Source\InventorySystemCore\Public\Interfaces\InventorySystemInterface.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "InventorySystemInterface.generated.h"

class UInventorySystemComponent;

/**
 * @class UInventorySystemInterface
 * @see IInventorySystemInterface
 * @brief Interface class for the Unreal Engine's interface system
 * @details This is the UObject interface declaration required by Unreal Engine.
 * Do not modify this class as it's only used for UObject system registration.
 */
UINTERFACE(MinimalAPI, BlueprintType, meta = (CannotImplementInterfaceInBlueprint))
class UInventorySystemInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * @class IInventorySystemInterface
 * @see UInventorySystemComponent
 * @brief Interface providing access to an actor's inventory system component
 * @details This interface should be implemented by actors that need to expose
 * their inventory system functionality. The component can be owned by the implementing
 * actor or by another actor (e.g., PlayerState owning inventory for its Pawn).
 */
class INVENTORYSYSTEMCORE_API IInventorySystemInterface
{
	GENERATED_BODY()

public:
	/**
	 * Retrieves the inventory system component associated with this actor
	 * @return The inventory system component to use. May be located on another actor
	 */
	UFUNCTION(BlueprintCallable, Category = "Inventory")
	virtual UInventorySystemComponent* GetInventorySystemComponent() const = 0;
};
--- Source\InventorySystemCore\Public\Library\InventoryFunctionLibrary.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "InventoryFunctionLibrary.generated.h"

class UItemFragment;
class UItemDefinition;


/**
 * @class UInventoryFunctionLibrary
 * @see UBlueprintFunctionLibrary
 * @brief Function library containing utility functions for the Inventory System.
 * @details Provides helper functions to interact with item definitions and their fragments.
 */
UCLASS()
class INVENTORYSYSTEMCORE_API UInventoryFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	/**
	 * Finds a specific fragment in an item definition
	 * @param ItemDef The item definition class to search in
	 * @param FragmentClass The type of fragment to find
	 * @return The found fragment instance, or nullptr if not found
	 */
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = FragmentClass))
	static const UItemFragment* FindItemDefinitionFragment(TSubclassOf<UItemDefinition> ItemDef, TSubclassOf<UItemFragment> FragmentClass);
};
--- Source\InventorySystemCore\Public\Log\InventorySystemLog.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogInventorySystem, Log, All);
--- Source\InventorySystemCore\Public\Settings\InventorySystemSettings.h ---
﻿// Licensed under the MIT License. See the LICENSE file in the project root for full license information.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "Settings/ItemFragmentRule.h"
#include "Definitions/Fragments/ItemFragment.h"
#include "InventorySystemSettings.generated.h"

/**
 *
 */
UCLASS(config = "GameplayCoreSettings", DefaultConfig, DisplayName = "Inventory")
class INVENTORYSYSTEMCORE_API UInventorySystemSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	// UDeveloperSettings
	virtual FName GetCategoryName() const override { return TEXT("Gameplay"); }
	// ~UDeveloperSettings

	#if WITH_EDITOR
	// Try to find the matching rules for the given fragment class
	const FItemFragmentRule* FindRuleForClass(const TSubclassOf<UItemFragment>& FragmentClass) const;
	#endif

	#if WITH_EDITORONLY_DATA
	// List of rules between fragments
	UPROPERTY(config, EditAnywhere, Category = "Fragment Rules")
	TMap<TSubclassOf<UItemFragment>, FItemFragmentRule> FragmentRules;
	#endif

	// TODO : Add item categories
};
--- Source\InventorySystemCore\Public\Settings\ItemFragmentRule.h ---
// Copyright 2025 TARA Gaming Limited. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"

#include "ItemFragmentRule.generated.h"

class UItemFragment;


/**
 * @struct FItemFragmentRule
 * @see UItemFragment
 * @brief Defines rules for validating item fragments in the inventory system.
 * This structure allows specifying blocked and required fragments for validation purposes.
 * It can be used to enforce rules on item composition within the inventory system.
 */
USTRUCT(BlueprintType)
struct FItemFragmentRule
{
	GENERATED_BODY()

	/**
		 * Checks whether the rule is satisfied based on the provided fragment classes.
		 * @param FragmentClasses The array of fragment classes to validate against the rule.
		 * @param ErrorContext A string that will contain details about blocking or missing fragments if the rule is not
		 * satisfied for error context message.
		 * @return True if the rule is satisfied, false otherwise.
		 */
	bool IsRuleSatisfied(const TArray<TSubclassOf<UItemFragment>>& FragmentClasses, FString& ErrorContext) const;

	/**
	 * List of fragment classes that are blocked (cannot coexist with this fragment).
	 */
	UPROPERTY(EditAnywhere)
	TArray<TSubclassOf<UItemFragment>> BlockedFragments;

	/**
	 * List of fragment classes that are required (must be present for this fragment to be valid).
	 */
	UPROPERTY(EditAnywhere)
	TArray<TSubclassOf<UItemFragment>> RequiredFragments;
};